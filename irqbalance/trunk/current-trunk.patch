Index: powermode.c
===================================================================
--- powermode.c	(.../tags/irqbalance-0.56)	(revision 33)
+++ powermode.c	(.../trunk)	(revision 33)
@@ -40,7 +40,8 @@
 	char *line = NULL;
 	size_t size = 0;
 	char *c;
-	uint64_t dummy, irq, softirq;
+	uint64_t dummy __attribute__((unused));
+	uint64_t irq, softirq;
 	file = fopen("/proc/stat", "r");
 	if (!file)
 		return;
Index: cputree.c
===================================================================
--- cputree.c	(.../tags/irqbalance-0.56)	(revision 33)
+++ cputree.c	(.../trunk)	(revision 33)
@@ -47,6 +47,7 @@
 /* Users want to be able to keep interrupts away from some cpus; store these in a cpumask_t */
 cpumask_t banned_cpus;
 
+cpumask_t cpu_possible_map;
 
 /* 
    it's convenient to have the complement of banned_cpus available so that 
@@ -158,6 +159,8 @@
 	memset(cpu, 0, sizeof(struct cpu_core));
 
 	cpu->number = strtoul(&path[27], NULL, 10);
+
+	cpu_set(cpu->number, cpu_possible_map);
 	
 	cpu_set(cpu->number, cpu->mask);
 
@@ -219,15 +222,15 @@
 	core_count++;
 }
 
-static void dump_irqs(int spaces, GList *interrupts)
+static void dump_irqs(int spaces, GList *dump_interrupts)
 {
 	struct interrupt *irq;
-	while (interrupts) {
+	while (dump_interrupts) {
 		int i;
-		for (i=0; i<spaces;i++) printf(" ");
-		irq = interrupts->data;
+		for (i=0; i<spaces; i++) printf(" ");
+		irq = dump_interrupts->data;
 		printf("Interrupt %i (%s/%u) \n", irq->number, classes[irq->class], (unsigned int)irq->workload);
-		interrupts = g_list_next(interrupts);
+		dump_interrupts = g_list_next(dump_interrupts);
 	}
 }
 
Index: placement.c
===================================================================
--- placement.c	(.../tags/irqbalance-0.56)	(revision 33)
+++ placement.c	(.../trunk)	(revision 33)
@@ -272,7 +272,7 @@
 		}
 		if ((!cpus_empty(irq->node_mask)) &&
 		    (!cpus_equal(irq->mask, irq->node_mask)) &&
-		    (!cpus_full(irq->node_mask))) {
+		    (!__cpus_full(&irq->node_mask, num_possible_cpus()))) {
 			irq->old_mask = irq->mask;
 			irq->mask = irq->node_mask;
 		}
Index: cpumask.h
===================================================================
--- cpumask.h	(.../tags/irqbalance-0.56)	(revision 33)
+++ cpumask.h	(.../trunk)	(revision 33)
@@ -1,7 +1,7 @@
 #ifndef __LINUX_CPUMASK_H
 #define __LINUX_CPUMASK_H
 
-#define NR_CPUS 256
+#define NR_CPUS 4096
 /*
  * Cpumasks provide a bitmap suitable for representing the
  * set of CPU's in a system, one bit position per CPU number.
Index: bitmap.c
===================================================================
--- bitmap.c	(.../tags/irqbalance-0.56)	(revision 33)
+++ bitmap.c	(.../trunk)	(revision 33)
@@ -74,6 +74,19 @@
 	return 1;
 }
 
+int __bitmap_weight(const unsigned long *bitmap, int bits)
+{
+	int k, w = 0, lim = bits/BITS_PER_LONG;
+
+	for (k = 0; k < lim; k++)
+		w += hweight_long(bitmap[k]);
+
+	if (bits % BITS_PER_LONG)
+		w += hweight_long(bitmap[k] & BITMAP_LAST_WORD_MASK(bits));
+
+	return w;
+}
+
 int __bitmap_equal(const unsigned long *bitmap1,
 		const unsigned long *bitmap2, int bits)
 {
Index: irqlist.c
===================================================================
--- irqlist.c	(.../tags/irqbalance-0.56)	(revision 33)
+++ irqlist.c	(.../trunk)	(revision 33)
@@ -28,6 +28,7 @@
 #include <unistd.h>
 #include <sys/types.h>
 #include <dirent.h>
+#include <errno.h>
 
 #include "types.h"
 #include "irqbalance.h"
@@ -39,6 +40,7 @@
 void get_affinity_hint(struct interrupt *irq, int number)
 {
 	char buf[PATH_MAX];
+	cpumask_t tempmask;
 	char *line = NULL;
 	size_t size = 0;
 	FILE *file;
@@ -51,7 +53,9 @@
 		fclose(file);
 		return;
 	}
-	cpumask_parse_user(line, strlen(line), irq->node_mask);
+	cpumask_parse_user(line, strlen(line), tempmask);
+	if (!__cpus_full(&tempmask, num_possible_cpus()))
+		irq->node_mask = tempmask;
 	fclose(file);
 	free(line);
 }
@@ -64,7 +68,7 @@
 	DIR *dir;
 	struct dirent *entry;
 	char *c, *c2;
-	int nr , count = 0;
+	int nr , count = 0, can_set = 1;
 	char buf[PATH_MAX];
 	sprintf(buf, "/proc/irq/%i", number);
 	dir = opendir(buf);
@@ -77,7 +81,7 @@
 			size_t size = 0;
 			FILE *file;
 			sprintf(buf, "/proc/irq/%i/smp_affinity", number);
-			file = fopen(buf, "r");
+			file = fopen(buf, "r+");
 			if (!file)
 				continue;
 			if (getline(&line, &size, file)==0) {
@@ -86,7 +90,13 @@
 				continue;
 			}
 			cpumask_parse_user(line, strlen(line), irq->mask);
-			fclose(file);
+			/*
+			 * Check that we can write the affinity, if
+			 * not take it out of the list.
+			 */
+			fputs(line, file);
+			if (fclose(file) && errno == EIO)
+				can_set = 0;
 			free(line);
 		} else if (strcmp(entry->d_name,"allowed_affinity")==0) {
 			char *line = NULL;
@@ -119,7 +129,7 @@
 			count++;
 
 	/* if there is no choice in the allowed mask, don't bother to balance */
-	if (count<2)
+	if ((count<2) || (can_set == 0))
 		 irq->balance_level = BALANCE_NONE;
 		
 
Index: Makefile.am
===================================================================
--- Makefile.am	(.../tags/irqbalance-0.56)	(revision 33)
+++ Makefile.am	(.../trunk)	(revision 33)
@@ -21,7 +21,7 @@
 # 
 
 AUTOMAKE_OPTIONS = no-dependencies
-EXTRA_DIST = README INSTALL COPYING autogen.sh m4/cap-ng.m4
+EXTRA_DIST = README INSTALL COPYING autogen.sh cap-ng.m4
  
 INCLUDES = -I${top_srcdir} 
 LIBS = $(CAPNG_LDADD) $(GLIB_LIBS)
@@ -31,6 +31,7 @@
 sbin_PROGRAMS = irqbalance
 irqbalance_SOURCES = activate.c bitmap.c classify.c cputree.c irqbalance.c \
 	irqlist.c network.c numa.c placement.c powermode.c procinterrupts.c
+dist_man_MANS = irqbalance.1
 
 CONFIG_CLEAN_FILES = debug*.list config/*
 clean-generic:
Index: network.c
===================================================================
--- network.c	(.../tags/irqbalance-0.56)	(revision 33)
+++ network.c	(.../trunk)	(revision 33)
@@ -160,10 +160,8 @@
 	}
 
 	while (!feof(file)) {
-		uint64_t rxcount;
-		uint64_t txcount;
-		uint64_t delta;
-		int dummy;
+		uint64_t dummy __attribute__((unused));
+		uint64_t rxcount, txcount, delta;
 		char *c, *c2;
 		if (getline(&line, &size, file)==0)
 			break;
