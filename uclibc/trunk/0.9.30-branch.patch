From f12e73b50c47896faf4498a5085f9bfbd828a1c3 Mon Sep 17 00:00:00 2001
From: Bernhard Reutner-Fischer <rep.dot.nop@gmail.com>
Date: Thu, 05 Mar 2009 17:18:44 +0000
Subject: - Use __always_inline instead of __inline__ (r25540 from trunk)

---
diff --git a/ldso/ldso/arm/dl-sysdep.h b/ldso/ldso/arm/dl-sysdep.h
index c3fc4e5..1512cc2 100644
--- a/ldso/ldso/arm/dl-sysdep.h
+++ b/ldso/ldso/arm/dl-sysdep.h
@@ -15,7 +15,7 @@
   GOT_BASE[1] = (unsigned long) MODULE; \
 }
 
-static __inline__ unsigned long arm_modulus(unsigned long m, unsigned long p)
+static __always_inline unsigned long arm_modulus(unsigned long m, unsigned long p)
 {
 	unsigned long i,t,inc;
 	i=p; t=0;
@@ -72,7 +72,7 @@ unsigned long _dl_linux_resolver(struct elf_resolve * tpnt, int reloc_entry);
    first element of the GOT.  We used to use the PIC register to do this
    without a constant pool reference, but GCC 4.2 will use a pseudo-register
    for the PIC base, so it may not be in r10.  */
-static __inline__ Elf32_Addr __attribute__ ((unused))
+static __always_inline Elf32_Addr __attribute__ ((unused))
 elf_machine_dynamic (void)
 {
   Elf32_Addr dynamic;
@@ -104,7 +104,7 @@ elf_machine_dynamic (void)
 }
 
 /* Return the run-time load address of the shared object.  */
-static __inline__ Elf32_Addr __attribute__ ((unused))
+static __always_inline Elf32_Addr __attribute__ ((unused))
 elf_machine_load_address (void)
 {
 	extern void __dl_start __asm__ ("_dl_start");
@@ -128,7 +128,7 @@ elf_machine_load_address (void)
 	return pcrel_addr - got_addr;
 }
 
-static __inline__ void
+static __always_inline void
 elf_machine_relative (Elf32_Addr load_off, const Elf32_Addr rel_addr,
 		      Elf32_Word relative_count)
 {
diff --git a/ldso/ldso/bfin/dl-sysdep.h b/ldso/ldso/bfin/dl-sysdep.h
index 52df4c9..818c29e 100644
--- a/ldso/ldso/bfin/dl-sysdep.h
+++ b/ldso/ldso/bfin/dl-sysdep.h
@@ -213,7 +213,7 @@ while (0)
 #endif
 
 #include <elf.h>
-static __inline__ void
+static __always_inline void
 elf_machine_relative (DL_LOADADDR_TYPE load_off, const Elf32_Addr rel_addr,
 		      Elf32_Word relative_count)
 {
diff --git a/ldso/ldso/cris/dl-sysdep.h b/ldso/ldso/cris/dl-sysdep.h
index c68541d..d3e9574 100644
--- a/ldso/ldso/cris/dl-sysdep.h
+++ b/ldso/ldso/cris/dl-sysdep.h
@@ -39,7 +39,7 @@ extern unsigned long _dl_linux_resolver(struct elf_resolve *tpnt, int reloc_entr
      || ((type) == R_CRIS_GLOB_DAT)) * ELF_RTYPE_CLASS_PLT)	\
    | (((type) == R_CRIS_COPY) * ELF_RTYPE_CLASS_COPY))
 
-static __inline__ Elf32_Addr
+static __always_inline Elf32_Addr
 elf_machine_dynamic(void)
 {
 	/* Don't just set this to an asm variable "r0" since that's not logical
@@ -61,7 +61,7 @@ elf_machine_dynamic(void)
    there's some other symbol we could use, that we don't *have* to force a
    GOT entry for.  */
 
-static __inline__ Elf32_Addr
+static __always_inline Elf32_Addr
 elf_machine_load_address(void)
 {
 	Elf32_Addr gotaddr_diff;
@@ -95,7 +95,7 @@ elf_machine_load_address(void)
 	return gotaddr_diff;
 }
 
-static __inline__ void
+static __always_inline void
 elf_machine_relative(Elf32_Addr load_off, const Elf32_Addr rel_addr,
                      Elf32_Word relative_count)
 {
diff --git a/ldso/ldso/i386/dl-sysdep.h b/ldso/ldso/i386/dl-sysdep.h
index 7090c92..910c111 100644
--- a/ldso/ldso/i386/dl-sysdep.h
+++ b/ldso/ldso/i386/dl-sysdep.h
@@ -42,8 +42,8 @@ extern unsigned long _dl_linux_resolver(struct elf_resolve * tpnt, int reloc_ent
 /* Return the link-time address of _DYNAMIC.  Conveniently, this is the
    first element of the GOT.  This must be inlined in a function which
    uses global data.  */
-static __inline__ Elf32_Addr elf_machine_dynamic (void) attribute_unused;
-static __inline__ Elf32_Addr
+static __always_inline Elf32_Addr elf_machine_dynamic (void) attribute_unused;
+static __always_inline Elf32_Addr
 elf_machine_dynamic (void)
 {
 	register Elf32_Addr *got __asm__ ("%ebx");
@@ -52,8 +52,8 @@ elf_machine_dynamic (void)
 
 
 /* Return the run-time load address of the shared object.  */
-static __inline__ Elf32_Addr elf_machine_load_address (void) attribute_unused;
-static __inline__ Elf32_Addr
+static __always_inline Elf32_Addr elf_machine_load_address (void) attribute_unused;
+static __always_inline Elf32_Addr
 elf_machine_load_address (void)
 {
 	/* It doesn't matter what variable this is, the reference never makes
@@ -66,7 +66,7 @@ elf_machine_load_address (void)
 	return addr;
 }
 
-static __inline__ void
+static __always_inline void
 elf_machine_relative (Elf32_Addr load_off, const Elf32_Addr rel_addr,
 		      Elf32_Word relative_count)
 {
diff --git a/ldso/ldso/m68k/dl-sysdep.h b/ldso/ldso/m68k/dl-sysdep.h
index e42be31..c771a9e 100644
--- a/ldso/ldso/m68k/dl-sysdep.h
+++ b/ldso/ldso/m68k/dl-sysdep.h
@@ -41,7 +41,7 @@ extern unsigned long _dl_linux_resolver (struct elf_resolve *, int);
 /* Return the link-time address of _DYNAMIC.  Conveniently, this is the
    first element of the GOT.  This must be inlined in a function which
    uses global data.  */
-static __inline__ Elf32_Addr
+static __always_inline Elf32_Addr
 elf_machine_dynamic (void)
 {
 	register Elf32_Addr *got __asm__ ("%a5");
@@ -50,7 +50,7 @@ elf_machine_dynamic (void)
 
 
 /* Return the run-time load address of the shared object.  */
-static __inline__ Elf32_Addr
+static __always_inline Elf32_Addr
 elf_machine_load_address (void)
 {
 	Elf32_Addr addr;
@@ -60,7 +60,7 @@ elf_machine_load_address (void)
 	return addr;
 }
 
-static __inline__ void
+static __always_inline void
 elf_machine_relative (Elf32_Addr load_off, const Elf32_Addr rel_addr,
 		      Elf32_Word relative_count)
 {
diff --git a/ldso/ldso/mips/dl-sysdep.h b/ldso/ldso/mips/dl-sysdep.h
index 312b9e8..29dde50 100644
--- a/ldso/ldso/mips/dl-sysdep.h
+++ b/ldso/ldso/mips/dl-sysdep.h
@@ -163,7 +163,7 @@ void _dl_perform_mips_global_got_relocations(struct elf_resolve *tpnt, int lazy)
 
 #define OFFSET_GP_GOT 0x7ff0
 
-static __inline__ ElfW(Addr) *
+static __always_inline ElfW(Addr) *
 elf_mips_got_from_gpreg (ElfW(Addr) gpreg)
 {
 	/* FIXME: the offset of gp from GOT may be system-dependent. */
@@ -173,7 +173,7 @@ elf_mips_got_from_gpreg (ElfW(Addr) gpreg)
 /* Return the link-time address of _DYNAMIC.  Conveniently, this is the
    first element of the GOT.  This must be inlined in a function which
    uses global data.  We assume its $gp points to the primary GOT.  */
-static __inline__ ElfW(Addr)
+static __always_inline ElfW(Addr)
 elf_machine_dynamic (void)
 {
 	register ElfW(Addr) gp __asm__ ("$28");
@@ -192,7 +192,7 @@ elf_machine_dynamic (void)
 #endif
 
 /* Return the run-time load address of the shared object.  */
-static __inline__ ElfW(Addr)
+static __always_inline ElfW(Addr)
 elf_machine_load_address (void)
 {
 	ElfW(Addr) addr;
@@ -208,7 +208,7 @@ elf_machine_load_address (void)
 	return addr;
 }
 
-static __inline__ void
+static __always_inline void
 elf_machine_relative (ElfW(Addr) load_off, const ElfW(Addr) rel_addr,
 		      ElfW(Word) relative_count)
 {
diff --git a/ldso/ldso/powerpc/dl-sysdep.h b/ldso/ldso/powerpc/dl-sysdep.h
index 7684822..de97ef0 100644
--- a/ldso/ldso/powerpc/dl-sysdep.h
+++ b/ldso/ldso/powerpc/dl-sysdep.h
@@ -90,7 +90,7 @@ void _dl_init_got(unsigned long *lpnt,struct elf_resolve *tpnt);
 #define ELF_MACHINE_PLTREL_OVERLAP 1
 
 /* Return the value of the GOT pointer.  */
-static __inline__ Elf32_Addr * __attribute__ ((const))
+static __always_inline Elf32_Addr * __attribute__ ((const))
 ppc_got (void)
 {
 	Elf32_Addr *got;
@@ -109,14 +109,14 @@ ppc_got (void)
 
 /* Return the link-time address of _DYNAMIC, stored as
    the first value in the GOT. */
-static __inline__ Elf32_Addr __attribute__ ((const))
+static __always_inline Elf32_Addr __attribute__ ((const))
 elf_machine_dynamic (void)
 {
 	return *ppc_got();
 }
 
 /* Return the run-time load address of the shared object.  */
-static __inline__ Elf32_Addr __attribute__ ((const))
+static __always_inline Elf32_Addr __attribute__ ((const))
 elf_machine_load_address (void)
 {
   Elf32_Addr *branchaddr;
@@ -164,7 +164,7 @@ elf_machine_load_address (void)
   return runtime_dynamic - elf_machine_dynamic ();
 }
 
-static __inline__ void
+static __always_inline void
 elf_machine_relative (Elf32_Addr load_off, const Elf32_Addr rel_addr,
 		      Elf32_Word relative_count)
 {
diff --git a/ldso/ldso/sh/dl-sysdep.h b/ldso/ldso/sh/dl-sysdep.h
index fd0f236..56f1bac 100644
--- a/ldso/ldso/sh/dl-sysdep.h
+++ b/ldso/ldso/sh/dl-sysdep.h
@@ -25,7 +25,7 @@
 struct elf_resolve;
 extern unsigned long _dl_linux_resolver(struct elf_resolve * tpnt, int reloc_entry);
 
-static __inline__ unsigned int
+static __always_inline unsigned int
 _dl_urem(unsigned int n, unsigned int base)
 {
   int res;
@@ -100,7 +100,7 @@ _dl_urem(unsigned int n, unsigned int base)
 /* Return the link-time address of _DYNAMIC.  Conveniently, this is the
    first element of the GOT.  This must be inlined in a function which
    uses global data.  */
-static __inline__ Elf32_Addr __attribute__ ((unused))
+static __always_inline Elf32_Addr __attribute__ ((unused))
 elf_machine_dynamic (void)
 {
 	register Elf32_Addr *got;
@@ -109,7 +109,7 @@ elf_machine_dynamic (void)
 }
 
 /* Return the run-time load address of the shared object.  */
-static __inline__ Elf32_Addr __attribute__ ((unused))
+static __always_inline Elf32_Addr __attribute__ ((unused))
 elf_machine_load_address (void)
 {
 	Elf32_Addr addr;
@@ -151,7 +151,7 @@ elf_machine_load_address (void)
     } \
   }
 
-static __inline__ void
+static __always_inline void
 elf_machine_relative (Elf32_Addr load_off, const Elf32_Addr rel_addr,
 		      Elf32_Word relative_count)
 {
diff --git a/ldso/ldso/sh64/dl-sysdep.h b/ldso/ldso/sh64/dl-sysdep.h
index 21bfffc..b8a6f7a 100644
--- a/ldso/ldso/sh64/dl-sysdep.h
+++ b/ldso/ldso/sh64/dl-sysdep.h
@@ -42,7 +42,7 @@ extern unsigned long _dl_linux_resolver(struct elf_resolve * tpnt, int reloc_ent
 /* Return the link-time address of _DYNAMIC.  Conveniently, this is the
    first element of the GOT.  This must be inlined in a function which
    uses global data.  */
-static __inline__ Elf32_Addr elf_machine_dynamic(void)
+static __always_inline Elf32_Addr elf_machine_dynamic(void)
 {
 	register Elf32_Addr *got;
 
@@ -70,7 +70,7 @@ static __inline__ Elf32_Addr elf_machine_dynamic(void)
 }
 
 /* Return the run-time load address of the shared object.  */
-static __inline__ Elf32_Addr elf_machine_load_address(void)
+static __always_inline Elf32_Addr elf_machine_load_address(void)
 {
 	Elf32_Addr addr;
 
@@ -123,7 +123,7 @@ static __inline__ Elf32_Addr elf_machine_load_address(void)
 	}						\
 }
 
-static __inline__ void
+static __always_inline void
 elf_machine_relative(Elf32_Addr load_off, const Elf32_Addr rel_addr,
 		     Elf32_Word relative_count)
 {
diff --git a/ldso/ldso/sparc/dl-sysdep.h b/ldso/ldso/sparc/dl-sysdep.h
index 27cb97e..020f252 100644
--- a/ldso/ldso/sparc/dl-sysdep.h
+++ b/ldso/ldso/sparc/dl-sysdep.h
@@ -49,7 +49,7 @@ unsigned long _dl_linux_resolver(struct elf_resolve * tpnt, int reloc_entry);
 
 #ifndef COMPILE_ASM
 /* Cheap modulo implementation, taken from arm/ld_sysdep.h. */
-static __inline__ unsigned long
+static __always_inline unsigned long
 sparc_mod(unsigned long m, unsigned long p)
 {
 	unsigned long i, t, inc;
@@ -127,7 +127,7 @@ do {    register Elf32_Addr pc __asm__("o7"); \
 /* Return the link-time address of _DYNAMIC.  Conveniently, this is the
    first element of the GOT.  This must be inlined in a function which
    uses global data.  */
-static __inline__ Elf32_Addr
+static __always_inline Elf32_Addr
 elf_machine_dynamic (void)
 {
 	register Elf32_Addr *got __asm__ ("%l7");
@@ -138,7 +138,7 @@ elf_machine_dynamic (void)
 }
 
 /* Return the run-time load address of the shared object.  */
-static __inline__ Elf32_Addr
+static __always_inline Elf32_Addr
 elf_machine_load_address (void)
 {
 	register Elf32_Addr *pc __asm__ ("%o7"), *got __asm__ ("%l7");
@@ -157,7 +157,7 @@ elf_machine_load_address (void)
 	return (Elf32_Addr) got - *got + (pc[2] - pc[3]) * 4 - 4;
 }
 
-static __inline__ void
+static __always_inline void
 elf_machine_relative (Elf32_Addr load_off, const Elf32_Addr rel_addr,
 		      Elf32_Word relative_count)
 {
diff --git a/ldso/ldso/xtensa/dl-sysdep.h b/ldso/ldso/xtensa/dl-sysdep.h
index b58feff..aa70d37 100644
--- a/ldso/ldso/xtensa/dl-sysdep.h
+++ b/ldso/ldso/xtensa/dl-sysdep.h
@@ -87,7 +87,7 @@ extern unsigned long _dl_linux_resolver (struct elf_resolve *, int);
   (((type) == R_XTENSA_JMP_SLOT) * ELF_RTYPE_CLASS_PLT)
 
 /* Return the link-time address of _DYNAMIC.  */
-static __inline__ Elf32_Addr
+static __always_inline Elf32_Addr
 elf_machine_dynamic (void)
 {
   /* This function is only used while bootstrapping the runtime linker.
@@ -97,7 +97,7 @@ elf_machine_dynamic (void)
 }
 
 /* Return the run-time load address of the shared object.  */
-static __inline__ Elf32_Addr
+static __always_inline Elf32_Addr
 elf_machine_load_address (void)
 {
   Elf32_Addr addr, tmp;
@@ -118,7 +118,7 @@ elf_machine_load_address (void)
   return addr - 3;
 }
 
-static __inline__ void
+static __always_inline void
 elf_machine_relative (Elf32_Addr load_off, const Elf32_Addr rel_addr,
 		      Elf32_Word relative_count)
 {
--
cgit v0.8.2.1
From aa148d76e87a63863808529a6687d053adc5a46d Mon Sep 17 00:00:00 2001
From: Bernhard Reutner-Fischer <rep.dot.nop@gmail.com>
Date: Thu, 12 Mar 2009 16:51:53 +0000
Subject: honour NO_LONG_DOUBLE_MATH

  This fixes compilation errors on hosts that turn off long double support
  for C99 like powerpc32.
---
diff --git a/include/math.h b/include/math.h
index 83a154d..f579624 100644
--- a/include/math.h
+++ b/include/math.h
@@ -118,7 +118,7 @@ __BEGIN_DECLS
 # undef	__MATH_PRECNAME
 
 # if (__STDC__ - 0 || __GNUC__ - 0) \
-     && (defined __UCLIBC_HAS_LONG_DOUBLE_MATH__ || defined __LDBL_COMPAT)
+     && (!defined __NO_LONG_DOUBLE_MATH || defined __LDBL_COMPAT)
 #  ifdef __LDBL_COMPAT
 
 #   ifdef __USE_ISOC99
@@ -230,7 +230,7 @@ enum
   };
 
 /* Return number of classification appropriate for X.  */
-# ifndef __UCLIBC_HAS_LONG_DOUBLE_MATH__
+# ifdef __NO_LONG_DOUBLE_MATH
 #  define fpclassify(x) \
      (sizeof (x) == sizeof (float) ? __fpclassifyf (x) : __fpclassify (x))
 # else
@@ -242,7 +242,7 @@ enum
 # endif
 
 /* Return nonzero value if sign of X is negative.  */
-# ifndef __UCLIBC_HAS_LONG_DOUBLE_MATH__
+# ifdef __NO_LONG_DOUBLE_MATH
 #  define signbit(x) \
      (sizeof (x) == sizeof (float) ? __signbitf (x) : __signbit (x))
 # else
@@ -254,7 +254,7 @@ enum
 # endif
 
 /* Return nonzero value if X is not +-Inf or NaN.  */
-# ifndef __UCLIBC_HAS_LONG_DOUBLE_MATH__
+# ifdef __NO_LONG_DOUBLE_MATH
 #  define isfinite(x) \
      (sizeof (x) == sizeof (float) ? __finitef (x) : __finite (x))
 # else
@@ -270,7 +270,7 @@ enum
 
 /* Return nonzero value if X is a NaN.  We could use `fpclassify' but
    we already have this functions `__isnan' and it is faster.  */
-# ifndef __UCLIBC_HAS_LONG_DOUBLE_MATH__
+# ifdef __NO_LONG_DOUBLE_MATH
 #  define isnan(x) \
      (sizeof (x) == sizeof (float) ? __isnanf (x) : __isnan (x))
 # else
@@ -282,7 +282,7 @@ enum
 # endif
 
 /* Return nonzero value is X is positive or negative infinity.  */
-# ifndef __UCLIBC_HAS_LONG_DOUBLE_MATH__
+# ifdef __NO_LONG_DOUBLE_MATH
 #  define isinf(x) \
      (sizeof (x) == sizeof (float) ? __isinff (x) : __isinf (x))
 # else
diff --git a/include/tgmath.h b/include/tgmath.h
index 685a345..5fb683f 100644
--- a/include/tgmath.h
+++ b/include/tgmath.h
@@ -36,7 +36,7 @@
 
 #if __GNUC_PREREQ (2, 7)
 
-# ifndef __UCLIBC_HAS_LONG_DOUBLE_MATH__
+# ifdef __NO_LONG_DOUBLE_MATH
 #  define __tgml(fct) fct
 # else
 #  define __tgml(fct) fct ## l
diff --git a/libc/sysdeps/linux/alpha/bits/mathdef.h b/libc/sysdeps/linux/alpha/bits/mathdef.h
index cbfaf68..3b52ec7 100644
--- a/libc/sysdeps/linux/alpha/bits/mathdef.h
+++ b/libc/sysdeps/linux/alpha/bits/mathdef.h
@@ -78,3 +78,7 @@ typedef double double_t;
 
 # endif /* GNUC before 3.4 */
 #endif /* COMPLEX_H */
+
+#if !defined __NO_LONG_DOUBLE_MATH && !defined __UCLIBC_HAS_LONG_DOUBLE_MATH__
+# define __NO_LONG_DOUBLE_MATH	1
+#endif
diff --git a/libc/sysdeps/linux/alpha/bits/wordsize.h b/libc/sysdeps/linux/alpha/bits/wordsize.h
index 029a7df..22fc641 100644
--- a/libc/sysdeps/linux/alpha/bits/wordsize.h
+++ b/libc/sysdeps/linux/alpha/bits/wordsize.h
@@ -18,13 +18,13 @@
 
 #define __WORDSIZE	64
 
-#if defined __UCLIBC_HAS_LONG_DOUBLE_MATH__ && !defined __LONG_DOUBLE_MATH_OPTIONAL
+#if !defined __NO_LONG_DOUBLE_MATH && !defined __LONG_DOUBLE_MATH_OPTIONAL
 
 /* Signal that we didn't used to have a `long double'. The changes all
    the `long double' function variants to be redirects to the double
    functions.  */
 # define __LONG_DOUBLE_MATH_OPTIONAL	1
 # ifndef __LONG_DOUBLE_128__
-#  undef __UCLIBC_HAS_LONG_DOUBLE_MATH__
+#  define __NO_LONG_DOUBLE_MATH		1
 # endif
 #endif
diff --git a/libc/sysdeps/linux/arm/bits/mathdef.h b/libc/sysdeps/linux/arm/bits/mathdef.h
index 22722e3..e013e74 100644
--- a/libc/sysdeps/linux/arm/bits/mathdef.h
+++ b/libc/sysdeps/linux/arm/bits/mathdef.h
@@ -34,3 +34,11 @@ typedef double double_t;	/* `double' expressions are evaluated as
 # define FP_ILOGBNAN	(2147483647)
 
 #endif	/* ISO C99 */
+
+#ifndef __NO_LONG_DOUBLE_MATH
+/* Signal that we do not really have a `long double'.  This disables the
+   declaration of all the `long double' function variants.  */
+/* XXX The FPA does support this but the patterns in GCC are currently
+   turned off.  */
+# define __NO_LONG_DOUBLE_MATH	1
+#endif
diff --git a/libc/sysdeps/linux/common/bits/mathdef.h b/libc/sysdeps/linux/common/bits/mathdef.h
index 1927299..00c6724 100644
--- a/libc/sysdeps/linux/common/bits/mathdef.h
+++ b/libc/sysdeps/linux/common/bits/mathdef.h
@@ -35,3 +35,9 @@ typedef double double_t;	/* `double' expressions are evaluated as
 # define FP_ILOGBNAN	2147483647
 
 #endif	/* ISO C99 */
+
+#ifndef __NO_LONG_DOUBLE_MATH
+/* Signal that we do not really have a `long double'.  The disables the
+   declaration of all the `long double' function variants.  */
+# define __NO_LONG_DOUBLE_MATH	1
+#endif
diff --git a/libc/sysdeps/linux/i386/bits/mathdef.h b/libc/sysdeps/linux/i386/bits/mathdef.h
index ec42ed5..a3786fc 100644
--- a/libc/sysdeps/linux/i386/bits/mathdef.h
+++ b/libc/sysdeps/linux/i386/bits/mathdef.h
@@ -44,3 +44,7 @@ typedef long double double_t;	/* `double' expressions are evaluated as
 # define FP_ILOGBNAN	(-2147483647 - 1)
 
 #endif	/* ISO C99 */
+
+#if !defined __NO_LONG_DOUBLE_MATH && !defined __UCLIBC_HAS_LONG_DOUBLE_MATH__
+# define __NO_LONG_DOUBLE_MATH	1
+#endif
diff --git a/libc/sysdeps/linux/ia64/bits/mathdef.h b/libc/sysdeps/linux/ia64/bits/mathdef.h
index 3dc2860..5da23cc 100644
--- a/libc/sysdeps/linux/ia64/bits/mathdef.h
+++ b/libc/sysdeps/linux/ia64/bits/mathdef.h
@@ -35,3 +35,7 @@ typedef double double_t;	/* `double' expressions are evaluated as
 # define FP_ILOGBNAN	2147483647
 
 #endif	/* ISO C99 */
+
+#if !defined __NO_LONG_DOUBLE_MATH && !defined __UCLIBC_HAS_LONG_DOUBLE_MATH__
+# define __NO_LONG_DOUBLE_MATH	1
+#endif
diff --git a/libc/sysdeps/linux/m68k/bits/mathdef.h b/libc/sysdeps/linux/m68k/bits/mathdef.h
index 65cf8d4..a69e930 100644
--- a/libc/sysdeps/linux/m68k/bits/mathdef.h
+++ b/libc/sysdeps/linux/m68k/bits/mathdef.h
@@ -36,3 +36,7 @@ typedef long double double_t;	/* `double' expressions are evaluated as
 # define FP_ILOGBNAN	(2147483647)
 
 #endif	/* ISO C99 */
+
+#if !defined __NO_LONG_DOUBLE_MATH && !defined __UCLIBC_HAS_LONG_DOUBLE_MATH__
+# define __NO_LONG_DOUBLE_MATH	1
+#endif
diff --git a/libc/sysdeps/linux/mips/bits/mathdef.h b/libc/sysdeps/linux/mips/bits/mathdef.h
index b741f65..331da13 100644
--- a/libc/sysdeps/linux/mips/bits/mathdef.h
+++ b/libc/sysdeps/linux/mips/bits/mathdef.h
@@ -39,8 +39,10 @@ typedef double double_t;	/* `double' expressions are evaluated as
 
 #endif	/* ISO C99 */
 
-#if defined __UCLIBC_HAS_LONG_DOUBLE_MATH__ && _MIPS_SIM == _ABIO32
+#if ! defined __NO_LONG_DOUBLE_MATH && _MIPS_SIM == _ABIO32
 /* Signal that we do not really have a `long double'.  This disables the
    declaration of all the `long double' function variants.  */
-# error defined __UCLIBC_HAS_LONG_DOUBLE_MATH__ and _MIPS_SIM == _ABIO32
+# define __NO_LONG_DOUBLE_MATH	1
+#elif !defined __NO_LONG_DOUBLE_MATH && !defined __UCLIBC_HAS_LONG_DOUBLE_MATH__
+# define __NO_LONG_DOUBLE_MATH	1
 #endif
diff --git a/libc/sysdeps/linux/nios/bits/mathdef.h b/libc/sysdeps/linux/nios/bits/mathdef.h
index 22722e3..e013e74 100644
--- a/libc/sysdeps/linux/nios/bits/mathdef.h
+++ b/libc/sysdeps/linux/nios/bits/mathdef.h
@@ -34,3 +34,11 @@ typedef double double_t;	/* `double' expressions are evaluated as
 # define FP_ILOGBNAN	(2147483647)
 
 #endif	/* ISO C99 */
+
+#ifndef __NO_LONG_DOUBLE_MATH
+/* Signal that we do not really have a `long double'.  This disables the
+   declaration of all the `long double' function variants.  */
+/* XXX The FPA does support this but the patterns in GCC are currently
+   turned off.  */
+# define __NO_LONG_DOUBLE_MATH	1
+#endif
diff --git a/libc/sysdeps/linux/nios2/bits/mathdef.h b/libc/sysdeps/linux/nios2/bits/mathdef.h
index 22722e3..e013e74 100644
--- a/libc/sysdeps/linux/nios2/bits/mathdef.h
+++ b/libc/sysdeps/linux/nios2/bits/mathdef.h
@@ -34,3 +34,11 @@ typedef double double_t;	/* `double' expressions are evaluated as
 # define FP_ILOGBNAN	(2147483647)
 
 #endif	/* ISO C99 */
+
+#ifndef __NO_LONG_DOUBLE_MATH
+/* Signal that we do not really have a `long double'.  This disables the
+   declaration of all the `long double' function variants.  */
+/* XXX The FPA does support this but the patterns in GCC are currently
+   turned off.  */
+# define __NO_LONG_DOUBLE_MATH	1
+#endif
diff --git a/libc/sysdeps/linux/powerpc/bits/mathdef.h b/libc/sysdeps/linux/powerpc/bits/mathdef.h
index 81a46dd..f28bace 100644
--- a/libc/sysdeps/linux/powerpc/bits/mathdef.h
+++ b/libc/sysdeps/linux/powerpc/bits/mathdef.h
@@ -65,11 +65,13 @@ typedef double double_t;
 
 #endif	/* ISO C99 */
 
-#ifdef __UCLIBC_HAS_LONG_DOUBLE_MATH__
+#ifndef __NO_LONG_DOUBLE_MATH
 #include <bits/wordsize.h>
 /* Signal that we do not really have a `long double'.  The disables the
    declaration of all the `long double' function variants.  */
 # if __WORDSIZE == 32
-#  undef __UCLIBC_HAS_LONG_DOUBLE_MATH__
+#  define __NO_LONG_DOUBLE_MATH	1
+# elif !defined __UCLIBC_HAS_LONG_DOUBLE_MATH__
+#  define __NO_LONG_DOUBLE_MATH	1
 # endif  /* __WORDSIZE == 32 */
-#endif  /* __UCLIBC_HAS_LONG_DOUBLE_MATH__ */
+#endif  /* __NO_LONG_DOUBLE_MATH */
diff --git a/libc/sysdeps/linux/powerpc/bits/wordsize.h b/libc/sysdeps/linux/powerpc/bits/wordsize.h
index dc19246..cf93423 100644
--- a/libc/sysdeps/linux/powerpc/bits/wordsize.h
+++ b/libc/sysdeps/linux/powerpc/bits/wordsize.h
@@ -7,13 +7,13 @@
 # define __WORDSIZE	32
 #endif
 
-#if defined __UCLIBC_HAS_LONG_DOUBLE_MATH__ && !defined __LONG_DOUBLE_MATH_OPTIONAL
+#if !defined __NO_LONG_DOUBLE_MATH && !defined __LONG_DOUBLE_MATH_OPTIONAL
 
 /* Signal the glibc ABI didn't used to have a `long double'.
    The changes all the `long double' function variants to be redirects
    to the double functions.  */
 # define __LONG_DOUBLE_MATH_OPTIONAL   1
 # ifndef __LONG_DOUBLE_128__
-#  undef __UCLIBC_HAS_LONG_DOUBLE_MATH__
+#  define __NO_LONG_DOUBLE_MATH        1
 # endif
 #endif
diff --git a/libc/sysdeps/linux/sh/bits/mathdef.h b/libc/sysdeps/linux/sh/bits/mathdef.h
index c419fcd..2b8caf1 100644
--- a/libc/sysdeps/linux/sh/bits/mathdef.h
+++ b/libc/sysdeps/linux/sh/bits/mathdef.h
@@ -61,3 +61,9 @@ typedef double double_t;
 # define FP_ILOGBNAN	0x7fffffff
 
 #endif	/* ISO C99 */
+
+#ifndef __NO_LONG_DOUBLE_MATH
+/* Signal that we do not really have a `long double'.  The disables the
+   declaration of all the `long double' function variants.  */
+# define __NO_LONG_DOUBLE_MATH	1
+#endif
diff --git a/libc/sysdeps/linux/sparc/bits/mathdef.h b/libc/sysdeps/linux/sparc/bits/mathdef.h
index b1a0d91..7f9bbee 100644
--- a/libc/sysdeps/linux/sparc/bits/mathdef.h
+++ b/libc/sysdeps/linux/sparc/bits/mathdef.h
@@ -57,13 +57,15 @@ typedef double double_t;
 
 #endif	/* ISO C99 */
 
-#ifdef __UCLIBC_HAS_LONG_DOUBLE_MATH__
+#ifndef __NO_LONG_DOUBLE_MATH
 
 # if __WORDSIZE == 32
 /* Signal that in 32bit ABI we do not really have a `long double'.
    The disables the declaration of all the `long double' function
    variants.  */
-#  undef __UCLIBC_HAS_LONG_DOUBLE_MATH__
+#  define __NO_LONG_DOUBLE_MATH	1
+# elif !defined __UCLIBC_HAS_LONG_DOUBLE_MATH__
+#  define __NO_LONG_DOUBLE_MATH	1
 # endif
 
 #endif
diff --git a/libc/sysdeps/linux/sparc/bits/mathinline.h b/libc/sysdeps/linux/sparc/bits/mathinline.h
index 66ca047..c774dea 100644
--- a/libc/sysdeps/linux/sparc/bits/mathinline.h
+++ b/libc/sysdeps/linux/sparc/bits/mathinline.h
@@ -37,7 +37,7 @@
 
 # if __WORDSIZE == 32
 
-#  ifdef __UCLIBC_HAS_LONG_DOUBLE_MATH__
+#  ifndef __NO_LONG_DOUBLE_MATH
 
 #   define __unordered_cmp(x, y) \
   (__extension__							      \
@@ -157,7 +157,7 @@ __NTH (__signbit (double __x))
   return __u.__i[0] < 0;
 }
 
-#    ifdef __UCLIBC_HAS_LONG_DOUBLE_MATH__
+#    ifndef __NO_LONG_DOUBLE_MATH
 __MATH_INLINE int
 __NTH (__signbitl (long double __x))
 {
@@ -219,7 +219,7 @@ __NTH (sqrtl (long double __x))
   _Qp_sqrt (&__r, &__x);
   return __r;
 }
-#   elif defined __UCLIBC_HAS_LONG_DOUBLE_MATH__
+#   elif !defined __NO_LONG_DOUBLE_MATH
 __MATH_INLINE long double
 sqrtl (long double __x) __THROW
 {
@@ -257,7 +257,7 @@ __ieee754_sqrtl (long double __x)
   _Qp_sqrt(&__r, &__x);
   return __r;
 }
-#   elif defined __UCLIBC_HAS_LONG_DOUBLE_MATH__
+#   elif !defined __NO_LONG_DOUBLE_MATH
 __MATH_INLINE long double
 __ieee754_sqrtl (long double __x)
 {
diff --git a/libc/sysdeps/linux/sparc/bits/wordsize.h b/libc/sysdeps/linux/sparc/bits/wordsize.h
index c8e5bfd..c0e600e 100644
--- a/libc/sysdeps/linux/sparc/bits/wordsize.h
+++ b/libc/sysdeps/linux/sparc/bits/wordsize.h
@@ -6,7 +6,7 @@
 # define __WORDSIZE	32
 #endif
 
-#if 0 /* uClibc: done in mathdefs.h: defined __UCLIBC_HAS_LONG_DOUBLE_MATH__ && !defined __LONG_DOUBLE_MATH_OPTIONAL*/
+#if 0 /* uClibc: done in mathdefs.h: !defined __NO_LONG_DOUBLE_MATH && !defined __LONG_DOUBLE_MATH_OPTIONAL*/
 
 # if __WORDSIZE == 32
 /* Signal that in 32bit ABI we didn't used to have a `long double'.
@@ -14,7 +14,7 @@
    to the double functions.  */
 #  define __LONG_DOUBLE_MATH_OPTIONAL   1
 #  ifndef __LONG_DOUBLE_128__
-#   undef __UCLIBC_HAS_LONG_DOUBLE_MATH__
+#   define __NO_LONG_DOUBLE_MATH        1
 #  endif
 # endif
 #endif
diff --git a/libc/sysdeps/linux/x86_64/bits/mathdef.h b/libc/sysdeps/linux/x86_64/bits/mathdef.h
index 7b16189..b0567e4 100644
--- a/libc/sysdeps/linux/x86_64/bits/mathdef.h
+++ b/libc/sysdeps/linux/x86_64/bits/mathdef.h
@@ -46,3 +46,7 @@ typedef long double double_t;	/* `double' expressions are evaluated as
 # define FP_ILOGBNAN	(-2147483647 - 1)
 
 #endif	/* ISO C99 */
+
+#if !defined __NO_LONG_DOUBLE_MATH && !defined __UCLIBC_HAS_LONG_DOUBLE_MATH__
+# define __NO_LONG_DOUBLE_MATH	1
+#endif
diff --git a/libc/sysdeps/linux/xtensa/bits/mathdef.h b/libc/sysdeps/linux/xtensa/bits/mathdef.h
index 99a4a31..0177fa9 100644
--- a/libc/sysdeps/linux/xtensa/bits/mathdef.h
+++ b/libc/sysdeps/linux/xtensa/bits/mathdef.h
@@ -36,8 +36,8 @@ typedef double double_t;	/* `double' expressions are evaluated as
 
 #endif	/* ISO C99 */
 
-#if defined __UCLIBC_HAS_LONG_DOUBLE_MATH__
+#ifndef __NO_LONG_DOUBLE_MATH
 /* Signal that we do not really have a `long double'.  The disables the
    declaration of all the `long double' function variants.  */
-# undef __UCLIBC_HAS_LONG_DOUBLE_MATH__
+# define __NO_LONG_DOUBLE_MATH	1
 #endif
diff --git a/libm/ldouble_wrappers.c b/libm/ldouble_wrappers.c
index 76365fc..4bc2977 100644
--- a/libm/ldouble_wrappers.c
+++ b/libm/ldouble_wrappers.c
@@ -13,6 +13,16 @@
 #include "math.h"
 #include <complex.h>
 
+#if defined __NO_LONG_DOUBLE_MATH
+# define int_WRAPPER_C99(func) /* not needed */
+# else
+# define int_WRAPPER_C99(func) \
+int func##l(long double x) \
+{ \
+    return func((double) x); \
+} \
+libm_hidden_def(func##l)
+#endif
 
 /* Implement the following, as defined by SuSv3 */
 #if 0
@@ -543,46 +553,28 @@ long double truncl (long double x)
 #endif
 
 
-#ifdef __DO_C99_MATH__
+#if defined __DO_C99_MATH__
 
 #ifdef L_fpclassifyl
-int __fpclassifyl (long double x)
-{
-	return __fpclassify ( (double) x );
-}
-libm_hidden_def(__fpclassifyl)
+int_WRAPPER_C99(__fpclassify)
 #endif
 
 #ifdef L_finitel
-int __finitel (long double x)
-{
-	return __finite ( (double)x );
-}
-libm_hidden_def(__finitel)
+int_WRAPPER_C99(__finite)
 #endif
 
 #ifdef L_signbitl
-int __signbitl (long double x)
-{
-	return __signbitl ( (double)x );
-}
-libm_hidden_def(__signbitl)
+int_WRAPPER_C99(__signbit)
 #endif
 
 #ifdef L_isnanl
-int __isnanl (long double x)
-{
-	return __isnan ( (double)x );
-}
-libm_hidden_def(__isnanl)
+int_WRAPPER_C99(__isnan)
 #endif
 
 #ifdef L_isinfl
-int __isinfl (long double x)
-{
-	return __isinf ( (double)x );
-}
-libm_hidden_def(__isinfl)
+int_WRAPPER_C99(__isinf)
 #endif
 
-#endif
+#endif /* DO_C99_MATH */
+
+#undef int_WRAPPER_C99
diff --git a/libm/nan.c b/libm/nan.c
index ec221ea..eee3b1c 100644
--- a/libm/nan.c
+++ b/libm/nan.c
@@ -45,7 +45,7 @@ float nanf (const char *tagp)
 }
 libm_hidden_def(nanf)
 
-#if defined __UCLIBC_HAS_LONG_DOUBLE_MATH__
+#if defined __UCLIBC_HAS_LONG_DOUBLE_MATH__ && !defined __NO_LONG_DOUBLE_MATH
 libm_hidden_proto(nanl)
 long double nanl (const char *tagp)
 {
--
cgit v0.8.2.1
From 43d920900b2e285729cc8fdf9f9fad600aabb3b9 Mon Sep 17 00:00:00 2001
From: Bernhard Reutner-Fischer <rep.dot.nop@gmail.com>
Date: Wed, 25 Mar 2009 19:26:54 +0000
Subject: - do not pass -Wl with -shared in LDFLAGS_NOSTRIP (Peter S. Mazinger)

---
diff --git a/Rules.mak b/Rules.mak
index 99c11cc..f5fb15b 100644
--- a/Rules.mak
+++ b/Rules.mak
@@ -393,7 +393,7 @@ ifeq ($(TARGET_ARCH),frv)
 	# -shared by itself would get us global function descriptors
 	# and calls through PLTs, dynamic resolution of symbols, etc,
 	# which would break as well, but -Bsymbolic comes to the rescue.
-	export LDPIEFLAG:=-Wl,-shared -Wl,-Bsymbolic
+	export LDPIEFLAG:=-shared -Wl,-Bsymbolic
 	UCLIBC_LDSO=ld.so.1
 endif
 
@@ -520,7 +520,7 @@ endif
 
 CFLAGS += $(call check_gcc,-std=gnu99,)
 
-LDFLAGS_NOSTRIP:=$(CPU_LDFLAGS-y) -Wl,-shared \
+LDFLAGS_NOSTRIP:=$(CPU_LDFLAGS-y) -shared \
 	-Wl,--warn-common -Wl,--warn-once -Wl,-z,combreloc
 # binutils-2.16.1 warns about ignored sections, 2.16.91.0.3 and newer are ok
 #LDFLAGS_NOSTRIP+=$(call check_ld,--gc-sections)
--
cgit v0.8.2.1
From 65119bba48b4ec904e81e99b701c8388afdb09a0 Mon Sep 17 00:00:00 2001
From: Bernhard Reutner-Fischer <rep.dot.nop@gmail.com>
Date: Mon, 27 Apr 2009 20:07:23 +0000
Subject: - getaddrinfo: runp->ifa_addr indeed can be NULL, don't dereference it

- ifaddrs.c: cosmetics, no code changes
  (Both r24336 from trunk)
---
diff --git a/libc/inet/getaddrinfo.c b/libc/inet/getaddrinfo.c
index e3e514c..3a7731d 100644
--- a/libc/inet/getaddrinfo.c
+++ b/libc/inet/getaddrinfo.c
@@ -187,6 +187,8 @@ static unsigned __check_pf(void)
 		}
 
 		for (runp = ifa; runp != NULL; runp = runp->ifa_next) {
+			if (runp->ifa_addr == NULL)
+				continue;
 #if defined __UCLIBC_HAS_IPV4__
 			if (runp->ifa_addr->sa_family == PF_INET)
 				seen |= SEEN_IPV4;
@@ -234,7 +236,7 @@ static int addrconfig(sa_family_t af)
 		ret = 1; /* Assume PF_UNIX. */
 		if (s < 0) {
 			if (errno != EMFILE)
-	        		ret = 0;
+				ret = 0;
 		} else
 			close(s);
 	}
diff --git a/libc/inet/ifaddrs.c b/libc/inet/ifaddrs.c
index 46be5f6..ae2526a 100644
--- a/libc/inet/ifaddrs.c
+++ b/libc/inet/ifaddrs.c
@@ -452,10 +452,7 @@ getifaddrs (struct ifaddrs **ifap)
 
   /* Allocate memory for all entries we have and initialize next
      pointer.  */
-  ifas = (struct ifaddrs_storage *) calloc (1,
-					    (newlink + newaddr)
-					    * sizeof (struct ifaddrs_storage)
-					    + ifa_data_size);
+  ifas = calloc (1, (newlink + newaddr) * sizeof (ifas[0]) + ifa_data_size);
   if (ifas == NULL)
     {
       result = -1;
--
cgit v0.8.2.1
