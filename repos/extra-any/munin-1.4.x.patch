Index: plugins/node.d.linux/memory.in
===================================================================
--- plugins/node.d.linux/memory.in	(.../tags/1.4.6)	(revision 4638)
+++ plugins/node.d.linux/memory.in	(.../branches/1.4-stable)	(revision 4638)
@@ -186,7 +186,7 @@
 	print "inact_clean.draw LINE1\n";
 	print "inact_clean.info Memory not currently used.\n";
     }
-    for my $field qw(apps buffers swap cached free slab swap_cache page_tables vmalloc_used committed mapped active active_anon active_cache inactive inact_dirty inact_laundry inact_clean) {
+    for my $field (qw(apps buffers swap cached free slab swap_cache page_tables vmalloc_used committed mapped active active_anon active_cache inactive inact_dirty inact_laundry inact_clean)) {
     	my ($warning, $critical) = get_thresholds($field);
 	my $total = $mems{MemTotal};
 	$total = $mems{SwapTotal} if($field eq "swap");
Index: plugins/node.d/ejabberd_.in
===================================================================
--- plugins/node.d/ejabberd_.in	(.../tags/1.4.6)	(revision 4638)
+++ plugins/node.d/ejabberd_.in	(.../branches/1.4-stable)	(revision 4638)
@@ -220,7 +220,7 @@
 	done;
     elif [ "$MODE" = "uptime" ]; then
 	echo 'graph_title Uptime of ejabberd server'
-	echo 'uptime in days'
+	echo 'graph_vlabel uptime in days'
 	echo "uptime.label uptime"
 	echo 'uptime.draw AREA'
     fi
@@ -237,7 +237,7 @@
 if [ "$MODE" = "users" ]; then
     for host in $vhosts; do
 	formathost=$(echo $host | tr '.' '_')
-	echo "connected_users_$formathost.value $($EJCTL vhost $host stats onlineusers)"; 
+	echo "connected_users_$formathost.value $($EJCTL stats-host onlineusers $host)"; 
 	echo "connected_unique_users_$formathost.value $($EJCTL connected-users | awk -v var=$host -F/ '{users[$1]} END {for (user in users) {if (index(user,var)) {count++}} print count}')"; 
     done
     exit 0
@@ -246,7 +246,7 @@
 if [ "$MODE" = "registrations" ]; then
     for host in $vhosts; do
 	formathost=$(echo $host | tr '.' '_')
-	num=$($EJCTL vhost $host stats registeredusers)
+	num=$($EJCTL stats-host registeredusers $host)
         if [ "$?" != 0 ]; then
             num="U"
         fi
@@ -259,7 +259,7 @@
    for host in $vhosts; do
 	formathost=$(echo $host | tr '.' '_')
 		for status in $statuses; do
-			num=$($EJCTL vhost $host status-num $status)
+			num=$($EJCTL status-num-host $status $host)
 			if [ "$?" != 0 ]; then
 				num="U"
 			fi
@@ -284,12 +284,12 @@
         for host in $vhosts; do
                 for num in $days; do
                         formathost=$(echo $host | tr '.' '_')
-                        echo "usersindays_${formathost}_${num}.value $($EJCTL vhost $host num-active-users $num)";
+                        echo "usersindays_${formathost}_${num}.value $($EJCTL num-active-users $host $num)";
                 done;
         done;
 	exit 0
 fi
 
 if [ "$MODE" = "uptime" ]; then
-	echo "uptime.value $($EJCTL stats uptime-seconds | awk '{printf "%.2f", $1/86400}')"
+	echo "uptime.value $($EJCTL stats uptimeseconds | awk '{printf "%.2f", $1/86400}')"
 fi
Index: plugins/node.d/bind9.in
===================================================================
--- plugins/node.d/bind9.in	(.../tags/1.4.6)	(revision 4638)
+++ plugins/node.d/bind9.in	(.../branches/1.4-stable)	(revision 4638)
@@ -31,10 +31,11 @@
 =cut
 
 use strict;
-use Munin::Common::Defaults; 
+use Munin::Common::Defaults;
 
 my $QUERYLOG = $ENV{logfile} || '/var/log/bind9/query.log';
 my $STATEFILE= $Munin::Common::Defaults::MUNIN_PLUGSTATE.'/bind9.state';
+
 my $OTHER=0;
 my %IN;
 
@@ -54,18 +55,18 @@
 
 
 sub do_stats {
-    my $k; 
+    my $k;
 
     open(Q,"< $QUERYLOG") or die "$!";
     while (<Q>) {
-	chomp;
-	if (/client \d+\.\d+.\d+.\d+\#\d+: (view \S+\: |)query\: \S+ (\w+) (\w+)/) {
-	    if ($2 eq 'IN' and $3 !~ /^TYPE/) {
+        chomp;
+        if (/: (view \S+\: |)query\: \S+ (\w+) (\w+)/) {
+            if ($2 eq 'IN' and $3 !~ /^TYPE/) {
                 $IN{$3}++;
-	    } else {
-		$OTHER++;
-	    }
-	}
+            } else {
+                $OTHER++;
+            }
+        }
     }
     close(Q);
 
@@ -73,8 +74,8 @@
 
     open(Q,"> $STATEFILE") or die;
     foreach $k (keys %IN) {
-	print "query_$k.value ",$IN{$k},"\n";
-	print Q "$k ",$IN{$k},"\n";
+        print "query_$k.value ",$IN{$k},"\n";
+        print Q "$k ",$IN{$k},"\n";
     }
     close(Q);
 
@@ -96,7 +97,7 @@
     get_state;
 
     foreach $k (keys %IN) {
-	print "query_$k.label $k
+        print "query_$k.label $k
 query_$k.type DERIVE
 query_$k.min 0
 query_$k.draw STACK
Index: plugins/node.d/smart_.in
===================================================================
--- plugins/node.d/smart_.in	(.../tags/1.4.6)	(revision 4638)
+++ plugins/node.d/smart_.in	(.../branches/1.4-stable)	(revision 4638)
@@ -4,8 +4,8 @@
 # Wildcard-plugin to monitor S.M.A.R.T attribute values through smartctl,
 # which is part of smartmontools package:
 #         http://smartmontools.sourceforge.net/
-# 
-# To monitor a S.M.A.R.T device, link smart_<device> to this file. 
+#
+# To monitor a S.M.A.R.T device, link smart_<device> to this file.
 # E.g.
 #    ln -s /usr/share/munin/plugins/smart_ /etc/munin/plugins/smart_hda
 # ...will monitor /dev/hda.
@@ -16,10 +16,10 @@
 #   group disk
 #
 # Parameters
-# 	smartpath     - Specify path to smartctl program (Default: /usr/sbin/smartctl)
-# 	smartargs     - Override '-a' argument passed to smartctl with '-A -i'+smartargs
+#       smartpath     - Specify path to smartctl program (Default: /usr/sbin/smartctl)
+#       smartargs     - Override '-a' argument passed to smartctl with '-A -i'+smartargs
 #       ignorestandby - Ignore the standby state of the drive and perform SMART query. Default: False
-# 
+#
 # Parameters can be specified on a per-drive basis, eg:
 #   [smart_hda]
 #   user root
@@ -39,7 +39,7 @@
 #   env.smartargs -H -l error -d 3ware,2
 #
 # Author: Nicolas Stransky  <Nico@stransky.cx>
-# 
+#
 # v1.0 22/08/2004 - First draft
 # v1.2 28/08/2004 - Clean up the code, add a verbose option
 # v1.3 14/11/2004 - Compatibility with python<2.2. See comments in the code
@@ -181,7 +181,7 @@
         verboselog('No state file, reading S.M.A.R.T values for the first time')
         read_values(hard_drive[0])
         pickle.dump(smart_values,open_state_file(hard_drive,"w"))
-        smart_values_state=smart_values 
+        smart_values_state=smart_values
 
     verboselog('Printing configuration')
     print('graph_title S.M.A.R.T values for drive '+string.join(hard_drive,","))
@@ -211,7 +211,7 @@
             sys.exit(1)
     else :
         verboselog('No state file, reading S.M.A.R.T values for the first time')
-        exit(1)
+        sys.exit(1)
 
     verboselog('Printing unknown values for all attributes in state file')
     attributes=smart_values_state.keys()
@@ -264,7 +264,7 @@
                             drives.append(drive)
                     except :
                         continue
-            except : 
+            except :
                 verboselog('Failed to list devices in /sys/block')
         else :
             verboselog('Not running linux2.6, failing back to /proc/partitions')
@@ -275,7 +275,7 @@
                     words=string.split(l)
                     if len(words)==0 or words[0][0] not in string.digits : continue
                     if words[0] in ['1','9','58','254'] : continue # Ignore RAM, md, LVM and LVM2 devices
-                    if words[-1][-1] not in string.digits : 
+                    if words[-1][-1] not in string.digits :
                         try :
                             verboselog('Trying '+words[-1]+'...')
                             exit_status=read_values(words[-1])
@@ -370,13 +370,13 @@
         print_config(hard_drive)
         sys.exit(0)
     elif sys.argv[1]=="autoconf" :
-        if os.path.exists(os.getenv('smartpath','/usr/sbin/smartctl')) : 
+        if os.path.exists(os.getenv('smartpath','/usr/sbin/smartctl')) :
             if not find_smart_drives():
                 print('no (no drives accessible)')
             else :
                 print('yes')
             sys.exit(0)
-        else : 
+        else :
             print('no (smartmontools not found)')
             sys.exit(0)
     elif sys.argv[1]=="suggest" :
@@ -395,7 +395,7 @@
 read_values(hard_drive[0])
 if not emptyoutput: update_state_file(hard_drive)
 print_plugin_values(hard_drive)
-exit(0)
+sys.exit(0)
 
 
 ### The following is the smart_ plugin documentation, intended to be used with munindoc
@@ -415,7 +415,7 @@
 
 To monitor a S.M.A.R.T device, create a link in the service directory
 of the munin-node named smart_<device>, which is pointing to this file.
- 
+
 E.g.
 
 ln -s /usr/share/munin/plugins/smart_ /etc/munin/plugins/smart_hda
Index: plugins/node.d/users.in
===================================================================
--- plugins/node.d/users.in	(.../tags/1.4.6)	(revision 4638)
+++ plugins/node.d/users.in	(.../branches/1.4-stable)	(revision 4638)
@@ -74,12 +74,12 @@
 	print "pts.colour 00FFFF\n";
 	print "X.label X displays\n";
 	print "X.draw AREASTACK\n";
-	print "X.info Users logged in on a X display\n";
+	print "X.info Users logged in on an X display\n";
 	print "X.colour 000000\n";
 	print "other.label Other users\n";
-	print "other.info Users loged in by indeterminate method\n";
+	print "other.info Users logged in by indeterminate method\n";
 	print "other.colour FF0000\n";
-	foreach my $field qw(tty pty pts X other) {
+	foreach my $field (qw(tty pty pts X other)) {
 		print_thresholds($field);
 	}
 	exit 0;
Index: plugins/node.d/slapd_.in
===================================================================
--- plugins/node.d/slapd_.in	(.../tags/1.4.6)	(revision 4638)
+++ plugins/node.d/slapd_.in	(.../branches/1.4-stable)	(revision 4638)
@@ -13,7 +13,8 @@
 # performing different functions:
 # slapd_statistics_bytes
 # slapd_statistics_pdu
-# slapd_statistics_other
+# slapd_statistics_referrals
+# slapd_statistics_entries
 # slapd_connections
 # slapd_waiters
 # slapd_operations
@@ -199,6 +200,9 @@
     }
 }
 
+# Determine action based on filename first
+(my $action = $0) =~ s/^.*slapd_([\w\d_]+)$/$1/;
+
 if ($ARGV[0]) {
     if ($ARGV[0] eq 'autoconf') {
         # Check for Net::LDAP
@@ -238,28 +242,25 @@
         print "yes\n";
         exit 0;
     } elsif ($ARGV[0] eq "config") {
-        if ($0 =~ /slapd_([\w\d_]+)$/) {
-            my $action = $1;
-            &config ($1);
-        } else {
-            die ("Can't run config without a symlinked name\n");
+        if(!exists $ops{$action}) {
+            die "Unknown action specified: $action";
         }
+        &config ($action);
     } elsif ($ARGV[0] eq "suggest") {
         print join ("\n", keys (%ops)), "\n";
     }
     exit 0;
 }
 
-# We won't run this without parameters.
-die ("Can't run without a symlinked name\n") if $0 =~ /slapd_$/;
+# If $action isn't in %ops, we quit
+if(!exists $ops{$action}) {
+    die "Unknown action specified: $action";
+}
 
 # Default scope for LDAP searches. We'll change to other scopes if
 # necessary.
 $scope = "one";
 
-# The filename is teh key
-(my $action = $0) =~ s/^.*slapd_([\w\d_]+)$/$1/;
-
 # Net::LDAP variant
 my $ldap = Net::LDAP->new ($server, version => 3)
     or die "Failed to connect to server $server: $@";
Index: node/lib/Munin/Node/OS.pm
===================================================================
--- node/lib/Munin/Node/OS.pm	(.../tags/1.4.6)	(revision 4638)
+++ node/lib/Munin/Node/OS.pm	(.../branches/1.4-stable)	(revision 4638)
@@ -12,6 +12,7 @@
 use Munin::Common::Timeout;
 
 use POSIX ();
+use Sys::Hostname;
 
 sub get_uid {
     my ($class, $user) = @_;
@@ -36,24 +37,12 @@
     }
 }
 
+sub get_fq_hostname { 
+    my $short = Sys::Hostname::hostname();
 
-sub get_fq_hostname {
-    my ($class) = @_;
-
-    my $hostname = eval {
-        require Sys::Hostname;
-        return (gethostbyname(Sys::Hostname::hostname()))[0];
-    };
-    return $hostname if $hostname;
-
-    $hostname = `hostname`;
-    chomp($hostname);
-    $hostname =~ s/\s//g;
-    return $hostname;
+    return (gethostbyname $short)[0] || $short || "unknown";
 }
 
-
-
 sub check_perms_if_paranoid {
     my ($class, $target) = @_;
     my @stat;
Index: common/lib/Munin/Common/Config.pm
===================================================================
--- common/lib/Munin/Common/Config.pm	(.../tags/1.4.6)	(revision 4638)
+++ common/lib/Munin/Common/Config.pm	(.../branches/1.4-stable)	(revision 4638)
@@ -38,7 +38,7 @@
 	"onlynullcdef", "group_order", "pipe", "pipe_command",
 	"unknown_limit", "num_unknowns", "dropdownlimit",
 	"max_graph_jobs", "max_cgi_graph_jobs", "munin_cgi_graph_jobs",
-        "max_html_jobs", );
+        "max_html_jobs", "num_messages");
 
 my %bools = map { $_ => 1} qw(yes no true false on off 1 0);
 
Index: master/lib/Munin/Master/Node.pm
===================================================================
--- master/lib/Munin/Master/Node.pm	(.../tags/1.4.6)	(revision 4638)
+++ master/lib/Munin/Master/Node.pm	(.../branches/1.4-stable)	(revision 4638)
@@ -157,7 +157,11 @@
 sub list_plugins {
     my ($self) = @_;
 
-    my $host = $self->{configref}{use_node_name}
+    # Check for one on this node- if not, use the global one
+    my $use_node_name = defined($self->{configref}{use_node_name})
+        ? $self->{configref}{use_node_name}
+        : $config->{use_node_name};
+    my $host = $use_node_name
         ? $self->{node_name}
         : $self->{host};
 
Index: master/lib/Munin/Master/LimitsOld.pm
===================================================================
--- master/lib/Munin/Master/LimitsOld.pm	(.../tags/1.4.6)	(revision 4638)
+++ master/lib/Munin/Master/LimitsOld.pm	(.../branches/1.4-stable)	(revision 4638)
@@ -44,8 +44,7 @@
 use POSIX qw ( strftime );
 use Getopt::Long;
 use Time::HiRes;
-use Text::Balanced qw ( extract_multiple extract_delimited
-    extract_quotelike extract_bracketed );
+use Text::Balanced qw ( extract_bracketed );
 use Log::Log4perl qw ( :easy );
 
 use Munin::Master::Logger;
@@ -105,6 +104,9 @@
 
 
 sub limits_main {
+    # We're liable to receive SIGPIPEs if the given commands don't work
+    $SIG{PIPE} = 'IGNORE';
+
     my $update_time = Time::HiRes::time;
 
     my $lockfile = "$config->{rundir}/munin-limits.lock";
@@ -121,6 +123,8 @@
 
     process_limits();
 
+    close_pipes();
+
     &munin_writeconfig("$config->{dbdir}/limits", \%notes);
 
     $update_time = sprintf("%.2f", (Time::HiRes::time - $update_time));
@@ -130,7 +134,17 @@
     INFO "[INFO] munin-limits finished ($update_time sec)";
 }
 
+sub close_pipes {
+    foreach my $cont (@{munin_get_children($config->{"contact"})}) {
+        if($cont->{pipe}) {
+            my $c = munin_get_node_name($cont);
 
+            DEBUG "[DEBUG] Closing pipe for contact $c";
+            close $cont->{pipe} or WARN "[WARNING] Failed to close pipe for contact $c: $!";
+        }
+    }
+}
+
 sub process_limits {
 
     # Make array of what needs to be checked
@@ -576,8 +590,10 @@
     foreach my $c (split(/\s+/, $contactlist)) {
         next if $c eq "none";
         my $contactobj = munin_get_node($config, ["contact", $c]);
-        next unless defined $contactobj;
-        next unless defined munin_get($contactobj, "command", undef);
+        if(!defined $contactobj) {
+            WARN("[WARNING] Missing configuration options for contact $c; skipping");
+            next;
+        }
         if (@limit_contacts and !grep (/^$c$/, @limit_contacts)) {
             next;
         }
@@ -589,8 +605,12 @@
         if (!$hash->{'state_changed'} and !$obsess) {
             next;    # No need to send notification
         }
-        DEBUG "state has changed, notifying $c";
-        my $precmd = munin_get($contactobj, "command");
+        DEBUG "[DEBUG] state has changed, notifying $c";
+        my $precmd = munin_get($contactobj, "command", undef);
+        if(!defined $precmd) {
+            WARN("[WARNING] Missing command option for contact $c; skipping");
+            next;
+        }
         my $pretxt = munin_get(
             $contactobj,
             "text",
@@ -603,113 +623,59 @@
         $txt =~ s/\\n/\n/g;
         $txt =~ s/\\t/\t/g;
 
-        # In some cases we want to reopen the command
+        if($cmd =~ /^\s*([|><]+)/) {
+            WARN "[WARNING] Found \"$1\" at beginning of command.  This should no longer be necessary and will be removed from the command before execution";
+            $cmd =~ s/^\s*[|><]+//;
+        }
+
         my $maxmess = munin_get($contactobj, "max_messages", 0);
         my $curmess = munin_get($contactobj, "num_messages", 0);
         my $curcmd  = munin_get($contactobj, "pipe_command", undef);
         my $pipe    = munin_get($contactobj, "pipe",         undef);
         if ($maxmess and $curmess >= $maxmess) {
-            close($pipe);
+            DEBUG "[DEBUG] Resetting pipe for $c because max messages was reached";
+            close($pipe) or WARN "[WARNING] Failed to close pipe for $c: $!";
             $pipe = undef;
-            munin_set_var_loc($contactobj, ["pipe"], undef);
-            DEBUG "[DEBUG] Closing \"$c\" -> command (max number of messages reached).";
+            munin_set($contactobj, "pipe", undef);
         }
         elsif ($curcmd and $curcmd ne $cmd) {
-            close($pipe);
+            DEBUG "[DEBUG] Resetting pipe for $c because the command has changed";
+            close($pipe) or WARN "[WARNING] Failed to close pipe for $c: $!";
             $pipe = undef;
-            munin_set_var_loc($contactobj, ["pipe"], undef);
-            DEBUG "[DEBUG] Closing \"$c\" -> command (command has changed).";
+            munin_set($contactobj, "pipe", undef);
         }
 
         if (!defined $pipe) {
-            my @cmd = extract_multiple(
-                message_expand($hash, $cmd),
-                [sub {extract_delimited($_[0], q{"'})}, qr/\S+/],
-                undef, 1
-            );
-            @cmd = map {
-                my $c = $_;
-                $c =~ s/['"]$//;
-                $c =~ s/^['"]//;
-                $c;
-            } @cmd;
-            $contactobj->{"num_messages"} = 0;
-            if ($cmd[0] eq "|") {
-                $cmd[0] = "|-";
+            DEBUG "[DEBUG] Opening pipe for $c";
+            pipe(my $r, my $w) or WARN "[WARNING] Failed to open pipe for $c: $!";
+            my $pid = fork();
+            defined($pid) or WARN "[WARNING] Failed fork for pipe for $c: $!";
+            if($pid) { # parent
+                DEBUG "[DEBUG] Opened pipe for $c as pid $pid";
+
+                close $r;
+                $pipe = $w;
+                munin_set($contactobj, "pipe_command", $cmd);
+                munin_set($contactobj, "pipe",         $pipe);
+                munin_set($contactobj, "num_messages", 0);
+                $curmess = 0;
+            } else { # child
+                close $w;
+                open(STDIN, "<&", $r);
+                exec($cmd) or WARN "[WARNING] Failed to exec for contact $c in pid $$";
+                exit;
             }
-            elsif ($cmd[0] !~ /^[|>]/) {
-                unshift(@cmd, "|-");
-            }
-            DEBUG("[DEBUG] opening \"$c\" for writing: \""
-		  . join('" "', @cmd)
-		  . "\".");
-            if ($cmd[0] eq ">") {
-                ## no critic
-                if (!open($pipe, join(' ', @cmd))) {
-                    FATAL("[FATAL] Could not open "
-			  . join(' ', @cmd[1 .. $#cmd])
-			  . " for writing: $!");
-                    exit 3;
-                }
-                ## critic
-            }
-            else {
-                my $pid = open($pipe, "|-");
-                if (!defined $pid) {
-                    FATAL "Fatal: Unable to  fork: $!";
-                    exit 3;
-                }
-                if (!$pid) {    # Child
-                                # Fork of stdout-to-log filter
-                    my $logstdout;
-                    my $logstderr;
-                    my $logpid = open($logstdout, "|-");
-                    if (!defined $logpid) {
-                        FATAL "Fatal: Unable to  fork: $!";
-                        exit 3;
-                    }
-                    if (!$logpid) {    # Child
-                        while (<STDIN>) {
-                            chomp;
-                            INFO "Command \"$c\" stdout: $_";
-                        }
-                        exit 0;
-                    }
-                    close(STDOUT);
-                    *STDOUT = \$logstdout;
-                    $logpid = open($logstderr, "|-");
-                    if (!defined $logpid) {
-                        FATAL "Fatal: Unable to  fork: $!";
-                        exit 3;
-                    }
-                    if (!$logpid) {    # Child
-                        while (<STDIN>) {
-                            chomp;
-                            FATAL "Command \"$c\" stderr: $_";
-                        }
-                        exit 0;
-                    }
-                    open(STDOUT, ">&", $logstdout);
-                    open(STDERR, ">&", $logstderr);
+        }
 
-                    exec(@cmd[1 .. $#cmd])
-                        or WARN("[WARNING] Could not run command \""
-                            . join(' ', @cmd[1 .. $#cmd])
-                            . "\": $!");
-                    exit 5;
+        DEBUG "[DEBUG] sending message to $c: \"$txt\"";
+        if(defined $pipe and !print $pipe $txt, "\n") {
+            WARN "[WARNING] Writing to pipe for $c failed: $!";
+            close($pipe) or WARN "[WARNING] Failed to close pipe for $c: $!";
+            $pipe = undef;
+            munin_set($contactobj, "pipe", undef);
+        }
 
-                    # NOTREACHED
-                }
-            }
-            munin_set_var_loc($contactobj, ["pipe_command"], $cmd);
-            munin_set_var_loc($contactobj, ["pipe"],         $pipe);
-        }
-        DEBUG "[DEBUG] sending message: \"$txt\"";
-        print $pipe $txt, "\n" if (defined $pipe);
-        DEBUG "[DEBUG] explicitely closing pipe as suggested by schamane on #732";
-        close $pipe if (defined $pipe);
-        $contactobj->{"num_messages"}
-            = 1 + munin_get($contactobj, "num_messages", 0);   # $num_messages++
+        munin_set($contactobj, "num_messages", $curmess + 1);
     }
 }
 
