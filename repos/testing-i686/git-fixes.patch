diff --git a/Makefile.am b/Makefile.am
index f4239de..83948ab 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -18,6 +18,7 @@
 #  IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 #  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
+ACLOCAL_AMFLAGS = -I m4 ${ACLOCAL_FLAGS}
 
 SUBDIRS = uxa src man
 MAINTAINERCLEANFILES = ChangeLog INSTALL
diff --git a/configure.ac b/configure.ac
index 529a294..5a1baac 100644
--- a/configure.ac
+++ b/configure.ac
@@ -21,18 +21,24 @@
 # Process this file with autoconf to produce a configure script
 
 # Initialize Autoconf
-AC_PREREQ([2.60])
+AC_PREREQ([2.63])
 AC_INIT([xf86-video-intel],
         [2.14.0],
         [https://bugs.freedesktop.org/enter_bug.cgi?product=xorg],
         [xf86-video-intel])
 AC_CONFIG_SRCDIR([Makefile.am])
 AC_CONFIG_HEADERS([config.h])
-AC_CONFIG_AUX_DIR(.)
+AC_CONFIG_AUX_DIR([build-aux])
+AC_CONFIG_MACRO_DIR([m4])
 
 # Initialize Automake
-AM_INIT_AUTOMAKE([foreign dist-bzip2])
-AM_MAINTAINER_MODE
+AM_INIT_AUTOMAKE([1.10 foreign dist-bzip2])
+AM_MAINTAINER_MODE([enable])
+
+# Support silent build rules, requires at least automake-1.11. Disable
+# by either passing --disable-silent-rules to configure or passing V=1
+# to make
+m4_ifdef([AM_SILENT_RULES], [AM_SILENT_RULES([yes])])
 
 # Require X.Org macros 1.8 or later for MAN_SUBSTS set by XORG_MANPAGE_SECTIONS
 m4_ifndef([XORG_MACROS_VERSION],
@@ -50,8 +56,8 @@ m4_ifndef([XORG_DRIVER_CHECK_EXT],
   depending on your distribution, try package 'xserver-xorg-dev' or 'xorg-x11-server-devel'])])
 
 # Initialize libtool
-AC_DISABLE_STATIC
-AC_PROG_LIBTOOL
+LT_PREREQ([2.2])
+LT_INIT([disable-static])
 
 PKG_CHECK_MODULES(GEN4ASM, [intel-gen4asm >= 1.1], [gen4asm=yes], [gen4asm=no])
 AM_CONDITIONAL(HAVE_GEN4ASM, test x$gen4asm = xyes)
@@ -85,6 +91,12 @@ AC_ARG_ENABLE(kms-only, AS_HELP_STRING([--enable-kms-only],
               [KMS_ONLY="$enableval"],
               [KMS_ONLY=no])
 
+AC_ARG_ENABLE(debug,
+	      AS_HELP_STRING([--enable-debug],
+			     [Enables internal debugging [[default=yes]]]),
+              [DEBUG="$enableval"],
+              [DEBUG=yes])
+
 # Store the list of server defined optional extensions in REQUIRED_MODULES
 XORG_DRIVER_CHECK_EXT(RANDR, randrproto)
 XORG_DRIVER_CHECK_EXT(RENDER, renderproto)
@@ -138,15 +150,19 @@ fi
 AC_MSG_CHECKING([whether to include XvMC support])
 AC_MSG_RESULT([$XVMC])
 AM_CONDITIONAL(XVMC, test x$XVMC = xyes)
-if test "$XVMC" = yes; then
+if test "x$XVMC" = xyes; then
 	AC_DEFINE(ENABLE_XVMC,1,[Enable XvMC support])
 fi
 
 AM_CONDITIONAL(KMS_ONLY, test x$KMS_ONLY = xyes)
-if test "$KMS_ONLY" = yes; then
+if test "x$KMS_ONLY" = xyes; then
 	AC_DEFINE(KMS_ONLY,1,[Assume KMS support])
 fi
 
+if test "x$DEBUG" = xno; then
+	AC_DEFINE(NDEBUG,1,[Disable internal debugging])
+fi
+
 DRIVER_NAME=intel
 AC_SUBST([DRIVER_NAME])
 AC_SUBST([moduledir])
diff --git a/src/i915_render.c b/src/i915_render.c
index 6d844e5..d04e8e1 100644
--- a/src/i915_render.c
+++ b/src/i915_render.c
@@ -302,12 +302,10 @@ static Bool i915_texture_setup(PicturePtr picture, PixmapPtr pixmap, int unit)
 	ScrnInfoPtr scrn = xf86Screens[picture->pDrawable->pScreen->myNum];
 	intel_screen_private *intel = intel_get_screen_private(scrn);
 	uint32_t format, pitch, filter;
-	int w, h, i;
 	uint32_t wrap_mode, tiling_bits;
+	int i;
 
 	pitch = intel_pixmap_pitch(pixmap);
-	w = picture->pDrawable->width;
-	h = picture->pDrawable->height;
 	intel->scale_units[unit][0] = 1. / pixmap->drawable.width;
 	intel->scale_units[unit][1] = 1. / pixmap->drawable.height;
 
@@ -546,8 +544,8 @@ i915_emit_composite_primitive(PixmapPtr dest,
 {
 	ScrnInfoPtr scrn = xf86Screens[dest->drawable.pScreen->myNum];
 	intel_screen_private *intel = intel_get_screen_private(scrn);
-	Bool is_affine_src, is_affine_mask = TRUE;
-	int per_vertex, num_floats;
+	Bool is_affine_src = TRUE, is_affine_mask = TRUE;
+	int per_vertex;
 	int tex_unit = 0;
 	int src_unit = -1, mask_unit = -1;
 	float src_x[3], src_y[3], src_w[3], mask_x[3], mask_y[3], mask_w[3];
@@ -666,8 +664,6 @@ i915_emit_composite_primitive(PixmapPtr dest,
 		}
 	}
 
-	num_floats = 3 * per_vertex;
-
 	OUT_VERTEX(dstX + w);
 	OUT_VERTEX(dstY + h);
 	if (! intel->render_source_is_solid) {
diff --git a/src/i965_video.c b/src/i965_video.c
index 235dfb9..e16a575 100644
--- a/src/i965_video.c
+++ b/src/i965_video.c
@@ -414,8 +414,8 @@ static void i965_create_dst_surface_state(ScrnInfoPtr scrn,
 	    intel_emit_reloc(surf_bo, offset + offsetof(struct brw_surface_state, ss1),
 			     pixmap_bo, 0, I915_GEM_DOMAIN_SAMPLER, 0);
 
-	dest_surf_state->ss2.height = scrn->virtualY - 1;
-	dest_surf_state->ss2.width = scrn->virtualX - 1;
+	dest_surf_state->ss2.height = pixmap->drawable.height - 1;
+	dest_surf_state->ss2.width = pixmap->drawable.width - 1;
 	dest_surf_state->ss2.mip_count = 0;
 	dest_surf_state->ss2.render_target_rotation = 0;
 	dest_surf_state->ss3.pitch = intel_pixmap_pitch(pixmap) - 1;
@@ -770,7 +770,7 @@ static drm_intel_bo *i965_create_cc_state(ScrnInfoPtr scrn)
 }
 
 static void
-i965_emit_video_setup(ScrnInfoPtr scrn, drm_intel_bo * surface_state_binding_table_bo, int n_src_surf)
+i965_emit_video_setup(ScrnInfoPtr scrn, drm_intel_bo * surface_state_binding_table_bo, int n_src_surf, PixmapPtr pixmap)
 {
 	intel_screen_private *intel = intel_get_screen_private(scrn);
 	int urb_vs_start, urb_vs_size;
@@ -821,20 +821,20 @@ i965_emit_video_setup(ScrnInfoPtr scrn, drm_intel_bo * surface_state_binding_tab
 		OUT_BATCH(0 | BASE_ADDRESS_MODIFY);	/* media base addr, don't care */
 		OUT_BATCH(0 | BASE_ADDRESS_MODIFY);	/* Instruction base address */
 		/* general state max addr, disabled */
-		OUT_BATCH(0x10000000 | BASE_ADDRESS_MODIFY);
+		OUT_BATCH(0 | BASE_ADDRESS_MODIFY);
 		/* media object state max addr, disabled */
-		OUT_BATCH(0x10000000 | BASE_ADDRESS_MODIFY);
+		OUT_BATCH(0 | BASE_ADDRESS_MODIFY);
 		/* Instruction max addr, disabled */
-		OUT_BATCH(0x10000000 | BASE_ADDRESS_MODIFY);
+		OUT_BATCH(0 | BASE_ADDRESS_MODIFY);
 	} else {
 		OUT_BATCH(BRW_STATE_BASE_ADDRESS | 4);
 		OUT_BATCH(0 | BASE_ADDRESS_MODIFY);	/* Generate state base address */
 		OUT_RELOC(surface_state_binding_table_bo, I915_GEM_DOMAIN_INSTRUCTION, 0, BASE_ADDRESS_MODIFY); /* Surface state base address */
 		OUT_BATCH(0 | BASE_ADDRESS_MODIFY);	/* media base addr, don't care */
 		/* general state max addr, disabled */
-		OUT_BATCH(0x10000000 | BASE_ADDRESS_MODIFY);
+		OUT_BATCH(0 | BASE_ADDRESS_MODIFY);
 		/* media object state max addr, disabled */
-		OUT_BATCH(0x10000000 | BASE_ADDRESS_MODIFY);
+		OUT_BATCH(0 | BASE_ADDRESS_MODIFY);
 	}
 
 	/* Set system instruction pointer */
@@ -877,7 +877,7 @@ i965_emit_video_setup(ScrnInfoPtr scrn, drm_intel_bo * surface_state_binding_tab
 	 */
 	OUT_BATCH(BRW_3DSTATE_DRAWING_RECTANGLE | 2);	/* XXX 3 for BLC or CTG */
 	OUT_BATCH(0x00000000);	/* ymin, xmin */
-	OUT_BATCH((scrn->virtualX - 1) | (scrn->virtualY - 1) << 16);	/* ymax, xmax */
+	OUT_BATCH((pixmap->drawable.width - 1) | (pixmap->drawable.height - 1) << 16);	/* ymax, xmax */
 	OUT_BATCH(0x00000000);	/* yorigin, xorigin */
 
 	/* skip the depth buffer */
@@ -1212,7 +1212,7 @@ I965DisplayVideoTextured(ScrnInfoPtr scrn,
 
 		intel_batch_start_atomic(scrn, 100);
 
-		i965_emit_video_setup(scrn, surface_state_binding_table_bo, n_src_surf);
+		i965_emit_video_setup(scrn, surface_state_binding_table_bo, n_src_surf, pixmap);
 
 		/* Set up the pointer to our vertex buffer */
 		OUT_BATCH(BRW_3DSTATE_VERTEX_BUFFERS | 3);
@@ -1517,13 +1517,13 @@ gen6_upload_depth_buffer_state(ScrnInfoPtr scrn)
 }
 
 static void
-gen6_upload_drawing_rectangle(ScrnInfoPtr scrn)
+gen6_upload_drawing_rectangle(ScrnInfoPtr scrn, PixmapPtr pixmap)
 {
 	intel_screen_private *intel = intel_get_screen_private(scrn);
 
 	OUT_BATCH(BRW_3DSTATE_DRAWING_RECTANGLE | 2);
 	OUT_BATCH(0x00000000);	/* ymin, xmin */
-	OUT_BATCH((scrn->virtualX - 1) | (scrn->virtualY - 1) << 16);	/* ymax, xmax */
+	OUT_BATCH((pixmap->drawable.width - 1) | (pixmap->drawable.height - 1) << 16);	/* ymax, xmax */
 	OUT_BATCH(0x00000000);	/* yorigin, xorigin */
 }
 
@@ -1673,7 +1673,7 @@ gen6_upload_vertex_element_state(ScrnInfoPtr scrn)
 }
 
 static void
-gen6_emit_video_setup(ScrnInfoPtr scrn, drm_intel_bo *surface_state_binding_table_bo, int n_src_surf)
+gen6_emit_video_setup(ScrnInfoPtr scrn, drm_intel_bo *surface_state_binding_table_bo, int n_src_surf, PixmapPtr pixmap)
 {
 	intel_screen_private *intel = intel_get_screen_private(scrn);
 
@@ -1694,7 +1694,7 @@ gen6_emit_video_setup(ScrnInfoPtr scrn, drm_intel_bo *surface_state_binding_tabl
 	gen6_upload_wm_state(scrn, n_src_surf == 1 ? TRUE : FALSE);
 	gen6_upload_binding_table(scrn, (n_src_surf + 1) * ALIGN(sizeof(struct brw_surface_state), 32));;
 	gen6_upload_depth_buffer_state(scrn);
-	gen6_upload_drawing_rectangle(scrn);
+	gen6_upload_drawing_rectangle(scrn, pixmap);
 	gen6_upload_vertex_element_state(scrn);
 }
 
@@ -1853,7 +1853,7 @@ void Gen6DisplayVideoTextured(ScrnInfoPtr scrn,
 			intel_batch_submit(scrn, FALSE);
 
 		intel_batch_start_atomic(scrn, 200);
-		gen6_emit_video_setup(scrn, surface_state_binding_table_bo, n_src_surf);
+		gen6_emit_video_setup(scrn, surface_state_binding_table_bo, n_src_surf, pixmap);
 
 		/* Set up the pointer to our vertex buffer */
 		OUT_BATCH(BRW_3DSTATE_VERTEX_BUFFERS | (5 - 2));
diff --git a/src/intel.h b/src/intel.h
index 9063328..4c755fc 100644
--- a/src/intel.h
+++ b/src/intel.h
@@ -227,8 +227,6 @@ static inline Bool intel_pixmap_tiled(PixmapPtr pixmap)
 dri_bo *intel_get_pixmap_bo(PixmapPtr pixmap);
 void intel_set_pixmap_bo(PixmapPtr pixmap, dri_bo * bo);
 
-typedef struct _I830OutputRec I830OutputRec, *I830OutputPtr;
-
 #include "common.h"
 
 #ifdef XvMCExtension
@@ -239,39 +237,6 @@ typedef struct _I830OutputRec I830OutputRec, *I830OutputPtr;
 
 #define PITCH_NONE 0
 
-/** Record of a linear allocation in the aperture. */
-typedef struct _intel_memory intel_memory;
-struct _intel_memory {
-	/** Description of the allocation, for logging */
-	char *name;
-
-	/** @{
-	 * Memory allocator linked list pointers
-	 */
-	intel_memory *next;
-	intel_memory *prev;
-	/** @} */
-
-	drm_intel_bo *bo;
-	uint32_t gem_name;
-};
-
-typedef struct _I830CrtcPrivateRec {
-	int pipe;
-	int plane;
-
-	Bool enabled;
-
-	int dpms_mode;
-
-	int x, y;
-
-	/* Lookup table values to be set when the CRTC is enabled */
-	uint8_t lut_r[256], lut_g[256], lut_b[256];
-} I830CrtcPrivateRec, *I830CrtcPrivatePtr;
-
-#define I830CrtcPrivate(c) ((I830CrtcPrivatePtr) (c)->driver_private)
-
 /** enumeration of 3d consumers so some can maintain invariant state. */
 enum last_3d {
 	LAST_3D_OTHER,
@@ -288,19 +253,12 @@ enum dri_type {
 
 typedef struct intel_screen_private {
 	ScrnInfoPtr scrn;
-	unsigned char *MMIOBase;
 	int cpp;
 
 #define RENDER_BATCH			I915_EXEC_RENDER
 #define BLT_BATCH			I915_EXEC_BLT
 	unsigned int current_batch;
 
-	unsigned int bufferOffset;	/* for I830SelectBuffer */
-
-	/* These are set in PreInit and never changed. */
-	long FbMapSize;
-	long GTTMapSize;
-
 	void *modes;
 	drm_intel_bo *front_buffer;
 	long front_pitch, front_tiling;
@@ -344,7 +302,6 @@ typedef struct intel_screen_private {
 	Bool has_relaxed_fencing;
 
 	int Chipset;
-	unsigned long LinearAddr;
 	EntityInfoPtr pEnt;
 	struct pci_device *PciInfo;
 	struct intel_chipset chipset;
@@ -535,8 +492,6 @@ extern void I830InitVideo(ScreenPtr pScreen);
 extern xf86CrtcPtr intel_covering_crtc(ScrnInfoPtr scrn, BoxPtr box,
 				      xf86CrtcPtr desired, BoxPtr crtc_box_ret);
 
-extern xf86CrtcPtr intel_pipe_to_crtc(ScrnInfoPtr scrn, int pipe);
-
 Bool I830DRI2ScreenInit(ScreenPtr pScreen);
 void I830DRI2CloseScreen(ScreenPtr pScreen);
 void I830DRI2FrameEventHandler(unsigned int frame, unsigned int tv_sec,
@@ -545,11 +500,7 @@ void I830DRI2FlipEventHandler(unsigned int frame, unsigned int tv_sec,
 			      unsigned int tv_usec, void *user_data);
 
 extern Bool intel_crtc_on(xf86CrtcPtr crtc);
-static inline int intel_crtc_to_pipe(xf86CrtcPtr crtc)
-{
-	intel_screen_private *intel = intel_get_screen_private(crtc->scrn);
-	return intel_get_pipe_from_crtc_id(intel->bufmgr, crtc);
-}
+int intel_crtc_to_pipe(xf86CrtcPtr crtc);
 
 /* intel_memory.c */
 unsigned long intel_get_fence_size(intel_screen_private *intel, unsigned long size);
@@ -688,11 +639,6 @@ static inline drm_intel_bo *intel_bo_alloc_for_data(ScrnInfoPtr scrn,
 	return bo;
 }
 
-/* Flags for memory allocation function */
-#define NEED_PHYSICAL_ADDR		0x00000001
-#define ALLOW_SHARING			0x00000010
-#define DISABLE_REUSE			0x00000020
-
 void intel_debug_flush(ScrnInfoPtr scrn);
 
 static inline PixmapPtr get_drawable_pixmap(DrawablePtr drawable)
@@ -715,7 +661,7 @@ static inline Bool pixmap_is_scanout(PixmapPtr pixmap)
 const OptionInfoRec *intel_uxa_available_options(int chipid, int busid);
 
 Bool intel_uxa_init(ScreenPtr pScreen);
-void intel_uxa_create_screen_resources(ScreenPtr pScreen);
+Bool intel_uxa_create_screen_resources(ScreenPtr pScreen);
 void intel_uxa_block_handler(intel_screen_private *intel);
 Bool intel_get_aperture_space(ScrnInfoPtr scrn, drm_intel_bo ** bo_table,
 			      int num_bos);
diff --git a/src/intel_display.c b/src/intel_display.c
index 1198013..f487a6e 100644
--- a/src/intel_display.c
+++ b/src/intel_display.c
@@ -70,6 +70,7 @@ struct intel_crtc {
 	struct intel_mode *mode;
 	drmModeModeInfo kmode;
 	drmModeCrtcPtr mode_crtc;
+	int pipe;
 	dri_bo *cursor;
 	dri_bo *rotate_bo;
 	uint32_t rotate_pitch;
@@ -118,7 +119,6 @@ intel_output_dpms_backlight(xf86OutputPtr output, int oldmode, int mode);
  * List of available kernel interfaces in priority order
  */
 static const char *backlight_interfaces[] = {
-	"intel", /* prefer our own native backlight driver */
 	"asus-laptop",
 	"eeepc",
 	"thinkpad_screen",
@@ -128,6 +128,7 @@ static const char *backlight_interfaces[] = {
 	"samsung",
 	"acpi_video1", /* finally fallback to the generic acpi drivers */
 	"acpi_video0",
+	"intel_backlight",
 	NULL,
 };
 /*
@@ -678,6 +679,9 @@ intel_crtc_init(ScrnInfoPtr scrn, struct intel_mode *mode, int num)
 	intel_crtc->mode = mode;
 	crtc->driver_private = intel_crtc;
 
+	intel_crtc->pipe = drm_intel_get_pipe_from_crtc_id(intel->bufmgr,
+							   crtc_id(intel_crtc));
+
 	intel_crtc->cursor = drm_intel_bo_alloc(intel->bufmgr, "ARGB cursor",
 						HWCURSOR_SIZE_ARGB,
 						GTT_PAGE_SIZE);
@@ -1671,16 +1675,15 @@ intel_mode_fini(intel_screen_private *intel)
 	intel->modes = NULL;
 }
 
-int
-intel_get_pipe_from_crtc_id(drm_intel_bufmgr *bufmgr, xf86CrtcPtr crtc)
-{
-	return drm_intel_get_pipe_from_crtc_id(bufmgr,
-					      	crtc_id(crtc->driver_private));
-}
-
 /* for the mode overlay */
 int
 intel_crtc_id(xf86CrtcPtr crtc)
 {
 	return crtc_id(crtc->driver_private);
 }
+
+int intel_crtc_to_pipe(xf86CrtcPtr crtc)
+{
+	struct intel_crtc *intel_crtc = crtc->driver_private;
+	return intel_crtc->pipe;
+}
diff --git a/src/intel_driver.c b/src/intel_driver.c
index 1275e4b..ebed258 100644
--- a/src/intel_driver.c
+++ b/src/intel_driver.c
@@ -37,10 +37,6 @@ USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "config.h"
 #endif
 
-#ifndef PRINT_MODE_INFO
-#define PRINT_MODE_INFO 0
-#endif
-
 #include <assert.h>
 #include <string.h>
 #include <stdio.h>
@@ -80,10 +76,6 @@ USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "i915_drm.h"
 #include <xf86drmMode.h>
 
-#define BIT(x) (1 << (x))
-#define MAX(a,b) ((a) > (b) ? (a) : (b))
-#define NB_OF(x) (sizeof (x) / sizeof (*x))
-
 /* *INDENT-OFF* */
 /*
  * Note: "ColorKey" is provided for compatibility with the i810 driver.
@@ -174,14 +166,6 @@ I830LoadPalette(ScrnInfoPtr scrn, int numColors, int *indices,
 
 	for (p = 0; p < xf86_config->num_crtc; p++) {
 		xf86CrtcPtr crtc = xf86_config->crtc[p];
-		I830CrtcPrivatePtr intel_crtc = crtc->driver_private;
-
-		/* Initialize to the old lookup table values. */
-		for (i = 0; i < 256; i++) {
-			lut_r[i] = intel_crtc->lut_r[i] << 8;
-			lut_g[i] = intel_crtc->lut_g[i] << 8;
-			lut_b[i] = intel_crtc->lut_b[i] << 8;
-		}
 
 		switch (scrn->depth) {
 		case 15:
@@ -250,9 +234,7 @@ static Bool i830CreateScreenResources(ScreenPtr screen)
 	if (!(*screen->CreateScreenResources) (screen))
 		return FALSE;
 
-	intel_uxa_create_screen_resources(screen);
-
-	return TRUE;
+	return intel_uxa_create_screen_resources(screen);
 }
 
 static void PreInitCleanup(ScrnInfoPtr scrn)
@@ -607,12 +589,9 @@ static Bool I830PreInit(ScrnInfoPtr scrn, int flags)
 	intel->tiling = TRUE;
 
 	/* Allow user override if they set a value */
-	if (!ALWAYS_TILING(intel) && xf86IsOptionSet(intel->Options, OPTION_TILING)) {
-		if (xf86ReturnOptValBool(intel->Options, OPTION_TILING, FALSE))
-			intel->tiling = TRUE;
-		else
-			intel->tiling = FALSE;
-	}
+	if (!ALWAYS_TILING(intel))
+		intel->tiling = xf86ReturnOptValBool(intel->Options,
+						     OPTION_TILING, TRUE);
 
 	intel->can_blt = can_accelerate_blt(intel);
 	intel->use_shadow = !intel->can_blt;
@@ -631,19 +610,11 @@ static Bool I830PreInit(ScrnInfoPtr scrn, int flags)
 	}
 
 	/* SwapBuffers delays to avoid tearing */
-	intel->swapbuffers_wait = TRUE;
-
-	/* Allow user override if they set a value */
-	if (xf86IsOptionSet(intel->Options, OPTION_SWAPBUFFERS_WAIT)) {
-		if (xf86ReturnOptValBool
-		    (intel->Options, OPTION_SWAPBUFFERS_WAIT, FALSE))
-			intel->swapbuffers_wait = TRUE;
-		else
-			intel->swapbuffers_wait = FALSE;
-	}
-
+	intel->swapbuffers_wait = xf86ReturnOptValBool(intel->Options,
+						       OPTION_SWAPBUFFERS_WAIT,
+						       TRUE);
 	if (IS_GEN6(intel))
-	    intel->swapbuffers_wait = FALSE;
+		intel->swapbuffers_wait = FALSE;
 
 	xf86DrvMsg(scrn->scrnIndex, X_CONFIG, "Tiling %sabled\n",
 		   intel->tiling ? "en" : "dis");
@@ -679,19 +650,12 @@ static Bool I830PreInit(ScrnInfoPtr scrn, int flags)
 	}
 
 	/* Load the dri2 module if requested. */
-	if (xf86ReturnOptValBool(intel->Options, OPTION_DRI, FALSE) &&
-	    intel->directRenderingType != DRI_DISABLED) {
+	if (intel->directRenderingType != DRI_DISABLED)
 		xf86LoadSubModule(scrn, "dri2");
-	}
 
 	return TRUE;
 }
 
-enum pipe {
-	PIPE_A = 0,
-	PIPE_B,
-};
-
 /**
  * Intialiazes the hardware for the 3D pipeline use in the 2D driver.
  *
@@ -733,50 +697,6 @@ I830BlockHandler(int i, pointer blockData, pointer pTimeout, pointer pReadmask)
 	intel_video_block_handler(intel);
 }
 
-static void intel_fixup_mtrrs(ScrnInfoPtr scrn)
-{
-#ifdef HAS_MTRR_SUPPORT
-	intel_screen_private *intel = intel_get_screen_private(scrn);
-	int fd;
-	struct mtrr_gentry gentry;
-	struct mtrr_sentry sentry;
-
-	if ((fd = open("/proc/mtrr", O_RDONLY, 0)) != -1) {
-		for (gentry.regnum = 0;
-		     ioctl(fd, MTRRIOC_GET_ENTRY, &gentry) == 0;
-		     ++gentry.regnum) {
-
-			if (gentry.size < 1) {
-				/* DISABLED */
-				continue;
-			}
-
-			/* Check the MTRR range is one we like and if not - remove it.
-			 * The Xserver common layer will then setup the right range
-			 * for us.
-			 */
-			if (gentry.base == intel->LinearAddr &&
-			    gentry.size < intel->FbMapSize) {
-
-				xf86DrvMsg(scrn->scrnIndex, X_INFO,
-					   "Removing bad MTRR range (base 0x%lx, size 0x%x)\n",
-					   gentry.base, gentry.size);
-
-				sentry.base = gentry.base;
-				sentry.size = gentry.size;
-				sentry.type = gentry.type;
-
-				if (ioctl(fd, MTRRIOC_DEL_ENTRY, &sentry) == -1) {
-					xf86DrvMsg(scrn->scrnIndex, X_ERROR,
-						   "Failed to remove bad MTRR range\n");
-				}
-			}
-		}
-		close(fd);
-	}
-#endif
-}
-
 static Bool
 intel_init_initial_framebuffer(ScrnInfoPtr scrn)
 {
@@ -809,7 +729,7 @@ Bool intel_crtc_on(xf86CrtcPtr crtc)
 {
 	ScrnInfoPtr scrn = crtc->scrn;
 	xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
-	int i, active_outputs = 0;
+	int i;
 
 	if (!crtc->enabled)
 		return FALSE;
@@ -819,11 +739,9 @@ Bool intel_crtc_on(xf86CrtcPtr crtc)
 		xf86OutputPtr output = xf86_config->output[i];
 		if (output->crtc == crtc &&
 		    intel_output_dpms_status(output) == DPMSModeOn)
-			active_outputs++;
+			return TRUE;
 	}
 
-	if (active_outputs)
-		return TRUE;
 	return FALSE;
 }
 
@@ -849,103 +767,102 @@ intel_flush_callback(CallbackListPtr *list,
 static void
 I830HandleUEvents(int fd, void *closure)
 {
-    ScrnInfoPtr scrn = closure;
+	ScrnInfoPtr scrn = closure;
 	intel_screen_private *intel = intel_get_screen_private(scrn);
-    struct udev_device *dev;
-    const char *hotplug;
-    struct stat s;
-    dev_t udev_devnum;
-
-    dev = udev_monitor_receive_device(intel->uevent_monitor);
-    if (!dev)
-	return;
-
-    udev_devnum = udev_device_get_devnum(dev);
-    fstat(intel->drmSubFD, &s);
-    /*
-     * Check to make sure this event is directed at our
-     * device (by comparing dev_t values), then make
-     * sure it's a hotplug event (HOTPLUG=1)
-     */
-
-    hotplug = udev_device_get_property_value(dev, "HOTPLUG");
-
-    if (memcmp(&s.st_rdev, &udev_devnum, sizeof (dev_t)) == 0 &&
-	hotplug && atoi(hotplug) == 1)
-	RRGetInfo(screenInfo.screens[scrn->scrnIndex], TRUE);
-
-    udev_device_unref(dev);
+	struct udev_device *dev;
+	const char *hotplug;
+	struct stat s;
+	dev_t udev_devnum;
+
+	dev = udev_monitor_receive_device(intel->uevent_monitor);
+	if (!dev)
+		return;
+
+	udev_devnum = udev_device_get_devnum(dev);
+	fstat(intel->drmSubFD, &s);
+	/*
+	 * Check to make sure this event is directed at our
+	 * device (by comparing dev_t values), then make
+	 * sure it's a hotplug event (HOTPLUG=1)
+	 */
+
+	hotplug = udev_device_get_property_value(dev, "HOTPLUG");
+
+	if (memcmp(&s.st_rdev, &udev_devnum, sizeof (dev_t)) == 0 &&
+			hotplug && atoi(hotplug) == 1)
+		RRGetInfo(screenInfo.screens[scrn->scrnIndex], TRUE);
+
+	udev_device_unref(dev);
 }
 
 static void
 I830UeventInit(ScrnInfoPtr scrn)
 {
-    intel_screen_private *intel = intel_get_screen_private(scrn);
-    struct udev *u;
-    struct udev_monitor *mon;
-    Bool hotplug;
-    MessageType from = X_CONFIG;
-
-    if (!xf86GetOptValBool(intel->Options, OPTION_HOTPLUG, &hotplug)) {
-	from = X_DEFAULT;
-	hotplug = TRUE;
-    }
-
-    xf86DrvMsg(scrn->scrnIndex, from, "hotplug detection: \"%s\"\n",
-	       hotplug ? "enabled" : "disabled");
-    if (!hotplug)
-	return;
-
-    u = udev_new();
-    if (!u)
-	return;
-
-    mon = udev_monitor_new_from_netlink(u, "udev");
-
-    if (!mon) {
-	udev_unref(u);
-	return;
-    }
-
-    if (udev_monitor_filter_add_match_subsystem_devtype(mon,
-							"drm",
-							"drm_minor") < 0 ||
-	udev_monitor_enable_receiving(mon) < 0)
-    {
-	udev_monitor_unref(mon);
-	udev_unref(u);
-	return;
-    }
-
-    intel->uevent_handler =
-	xf86AddGeneralHandler(udev_monitor_get_fd(mon),
-			      I830HandleUEvents,
-			      scrn);
-    if (!intel->uevent_handler) {
-	udev_monitor_unref(mon);
-	udev_unref(u);
-	return;
-    }
-
-    intel->uevent_monitor = mon;
+	intel_screen_private *intel = intel_get_screen_private(scrn);
+	struct udev *u;
+	struct udev_monitor *mon;
+	Bool hotplug;
+	MessageType from = X_CONFIG;
+
+	if (!xf86GetOptValBool(intel->Options, OPTION_HOTPLUG, &hotplug)) {
+		from = X_DEFAULT;
+		hotplug = TRUE;
+	}
+
+	xf86DrvMsg(scrn->scrnIndex, from, "hotplug detection: \"%s\"\n",
+			hotplug ? "enabled" : "disabled");
+	if (!hotplug)
+		return;
+
+	u = udev_new();
+	if (!u)
+		return;
+
+	mon = udev_monitor_new_from_netlink(u, "udev");
+
+	if (!mon) {
+		udev_unref(u);
+		return;
+	}
+
+	if (udev_monitor_filter_add_match_subsystem_devtype(mon,
+				"drm",
+				"drm_minor") < 0 ||
+			udev_monitor_enable_receiving(mon) < 0)
+	{
+		udev_monitor_unref(mon);
+		udev_unref(u);
+		return;
+	}
+
+	intel->uevent_handler =
+		xf86AddGeneralHandler(udev_monitor_get_fd(mon),
+				I830HandleUEvents,
+				scrn);
+	if (!intel->uevent_handler) {
+		udev_monitor_unref(mon);
+		udev_unref(u);
+		return;
+	}
+
+	intel->uevent_monitor = mon;
 }
 
 static void
 I830UeventFini(ScrnInfoPtr scrn)
 {
-    intel_screen_private *intel = intel_get_screen_private(scrn);
+	intel_screen_private *intel = intel_get_screen_private(scrn);
 
-    if (intel->uevent_handler)
-    {
-	struct udev *u = udev_monitor_get_udev(intel->uevent_monitor);
+	if (intel->uevent_handler) {
+		struct udev *u = udev_monitor_get_udev(intel->uevent_monitor);
 
-	xf86RemoveGeneralHandler(intel->uevent_handler);
+		xf86RemoveGeneralHandler(intel->uevent_handler);
 
-	udev_monitor_unref(intel->uevent_monitor);
-	udev_unref(u);
-	intel->uevent_handler = NULL;
-	intel->uevent_monitor = NULL;
-    }
+		udev_monitor_unref(intel->uevent_monitor);
+		udev_unref(u);
+		intel->uevent_handler = NULL;
+		intel->uevent_monitor = NULL;
+	}
 }
 #endif /* HAVE_UDEV */
 
@@ -961,32 +878,6 @@ I830ScreenInit(int scrnIndex, ScreenPtr screen, int argc, char **argv)
 	struct pci_device *const device = intel->PciInfo;
 	int fb_bar = IS_GEN2(intel) ? 0 : 2;
 
-	/*
-	 * The "VideoRam" config file parameter specifies the maximum amount of
-	 * memory that will be used/allocated.  When not present, we allow the
-	 * driver to allocate as much memory as it wishes to satisfy its
-	 * allocations, but if agpgart support isn't available, it gets limited
-	 * to the amount of pre-allocated ("stolen") memory.
-	 *
-	 * Note that in using this value for allocator initialization, we're
-	 * limiting aperture allocation to the VideoRam option, rather than limiting
-	 * actual memory allocation, so alignment and things will cause less than
-	 * VideoRam to be actually used.
-	 */
-	scrn->videoRam = intel->FbMapSize / KB(1);
-	if (intel->pEnt->device->videoRam != 0) {
-		if (scrn->videoRam != intel->pEnt->device->videoRam) {
-			xf86DrvMsg(scrn->scrnIndex, X_WARNING,
-				   "VideoRam configuration found, which is no "
-				   "longer used.\n");
-			xf86DrvMsg(scrn->scrnIndex, X_INFO,
-				   "Continuing with (ignored) %dkB VideoRam "
-				   "instead of %d kB.\n",
-				   scrn->videoRam,
-				   intel->pEnt->device->videoRam);
-		}
-	}
-
 	scrn->videoRam = device->regions[fb_bar].size / 1024;
 
 	intel->last_3d = LAST_3D_OTHER;
@@ -998,10 +889,6 @@ I830ScreenInit(int scrnIndex, ScreenPtr screen, int argc, char **argv)
 	 */
 	intel->XvEnabled = TRUE;
 
-	xf86DrvMsg(scrn->scrnIndex,
-		   intel->pEnt->device->videoRam ? X_CONFIG : X_DEFAULT,
-		   "VideoRam: %d KB\n", scrn->videoRam);
-
 #ifdef DRI2
 	if (intel->directRenderingType == DRI_NONE
 	    && I830DRI2ScreenInit(screen))
@@ -1011,8 +898,6 @@ I830ScreenInit(int scrnIndex, ScreenPtr screen, int argc, char **argv)
 	if (!intel_init_initial_framebuffer(scrn))
 		return FALSE;
 
-	intel_fixup_mtrrs(scrn);
-
 	intel_batch_init(scrn);
 
 	if (INTEL_INFO(intel)->gen >= 40)
@@ -1159,7 +1044,7 @@ I830ScreenInit(int scrnIndex, ScreenPtr screen, int argc, char **argv)
 	I830UeventInit(scrn);
 #endif
 
-	return uxa_resources_init(screen);
+	return TRUE;
 }
 
 static void i830AdjustFrame(int scrnIndex, int x, int y, int flags)
@@ -1382,22 +1267,6 @@ static Bool I830PMEvent(int scrnIndex, pmEvent event, Bool undo)
 	return TRUE;
 }
 
-xf86CrtcPtr intel_pipe_to_crtc(ScrnInfoPtr scrn, int pipe)
-{
-	xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR(scrn);
-	int c;
-
-	for (c = 0; c < config->num_crtc; c++) {
-		xf86CrtcPtr crtc = config->crtc[c];
-		I830CrtcPrivatePtr intel_crtc = crtc->driver_private;
-
-		if (intel_crtc->pipe == pipe)
-			return crtc;
-	}
-
-	return NULL;
-}
-
 void intel_init_scrn(ScrnInfoPtr scrn)
 {
 	scrn->PreInit = I830PreInit;
diff --git a/src/intel_uxa.c b/src/intel_uxa.c
index 1a591f1..9341b91 100644
--- a/src/intel_uxa.c
+++ b/src/intel_uxa.c
@@ -1089,12 +1089,15 @@ static Bool intel_uxa_destroy_pixmap(PixmapPtr pixmap)
 	return TRUE;
 }
 
-void intel_uxa_create_screen_resources(ScreenPtr screen)
+Bool intel_uxa_create_screen_resources(ScreenPtr screen)
 {
 	ScrnInfoPtr scrn = xf86Screens[screen->myNum];
 	intel_screen_private *intel = intel_get_screen_private(scrn);
 	dri_bo *bo = intel->front_buffer;
 
+	if (!uxa_resources_init(screen))
+		return FALSE;
+
 	drm_intel_gem_bo_map_gtt(bo);
 
 	if (intel->use_shadow) {
@@ -1111,6 +1114,8 @@ void intel_uxa_create_screen_resources(ScreenPtr screen)
 					   NULL);
 		scrn->displayWidth = intel->front_pitch / intel->cpp;
 	}
+
+	return TRUE;
 }
 
 static void
@@ -1185,7 +1190,6 @@ Bool intel_uxa_init(ScreenPtr screen)
 
 	memset(intel->uxa_driver, 0, sizeof(*intel->uxa_driver));
 
-	intel->bufferOffset = 0;
 	intel->uxa_driver->uxa_major = 1;
 	intel->uxa_driver->uxa_minor = 0;
 
diff --git a/src/intel_video.c b/src/intel_video.c
index 2786201..5294f73 100644
--- a/src/intel_video.c
+++ b/src/intel_video.c
@@ -996,7 +996,7 @@ I830CopyPlanarData(intel_adaptor_private *adaptor_priv,
 	/* Copy V data for YV12, or U data for I420 */
 	src2 = buf +		/* start of YUV data */
 	    (srcH * srcPitch) +	/* move over Luma plane */
-	    ((top * srcPitch) >> 2) +	/* move down from by top lines */
+	    ((top >> 1) * srcPitch2) +	/* move down from by top lines */
 	    (left >> 1);	/* move left by left pixels */
 
 #if 0
@@ -1015,7 +1015,7 @@ I830CopyPlanarData(intel_adaptor_private *adaptor_priv,
 	src3 = buf +		/* start of YUV data */
 	    (srcH * srcPitch) +	/* move over Luma plane */
 	    ((srcH >> 1) * srcPitch2) +	/* move over Chroma plane */
-	    ((top * srcPitch) >> 2) +	/* move down from by top lines */
+	    ((top >> 1) * srcPitch2) +	/* move down from by top lines */
 	    (left >> 1);	/* move left by left pixels */
 #if 0
 	ErrorF("src3 is %p, offset is %ld\n", src3,
diff --git a/src/xvmc/i915_xvmc.c b/src/xvmc/i915_xvmc.c
index 21a1149..fbd4555 100644
--- a/src/xvmc/i915_xvmc.c
+++ b/src/xvmc/i915_xvmc.c
@@ -391,7 +391,6 @@ static void i915_mc_static_indirect_state_set(XvMCContext * context,
 	i915XvMCContext *pI915XvMC = (i915XvMCContext *) context->privData;
 	struct intel_xvmc_surface *intel_surf = dest->privData;
 	struct i915_mc_static_indirect_state_buffer *buffer_info;
-	unsigned int w = dest->width;
 
 	drm_intel_gem_bo_map_gtt(pI915XvMC->sis_bo);
 	buffer_info = pI915XvMC->sis_bo->virtual;
@@ -688,7 +687,7 @@ static void i915_mc_load_indirect_render_emit(XvMCContext * context)
 {
 	i915XvMCContext *pI915XvMC = (i915XvMCContext *) context->privData;
 	int mem_select;
-	uint32_t load_indirect, buffer_address;
+	uint32_t load_indirect;
 	BATCH_LOCALS;
 
 	BEGIN_BATCH(5);
diff --git a/src/xvmc/intel_batchbuffer.c b/src/xvmc/intel_batchbuffer.c
index 337b2ce..2b5526c 100644
--- a/src/xvmc/intel_batchbuffer.c
+++ b/src/xvmc/intel_batchbuffer.c
@@ -64,8 +64,6 @@ static void i965_end_batch(void)
 
 Bool intelInitBatchBuffer(void)
 {
-	int i;
-
 	if ((xvmc_driver->batch.buf =
 	     drm_intel_bo_alloc(xvmc_driver->bufmgr,
 				"batch buffer", BATCH_SIZE, 0x1000)) == NULL) {
diff --git a/src/xvmc/intel_batchbuffer.h b/src/xvmc/intel_batchbuffer.h
index 6fa1c05..888abeb 100644
--- a/src/xvmc/intel_batchbuffer.h
+++ b/src/xvmc/intel_batchbuffer.h
@@ -24,7 +24,7 @@ extern int VERBOSE;
 
 #define OUT_RELOC(bo,read_domains,write_domains,delta)  \
     do { \
-        *(unsigned int *)batch_ptr = delta + bo->offset; \
+        *(unsigned int *)batch_ptr = (delta) + bo->offset; \
         intel_batch_emit_reloc(bo, read_domains, write_domains, delta, batch_ptr); \
         batch_ptr += 4;                                                 \
     } while (0)
diff --git a/src/xvmc/intel_xvmc.c b/src/xvmc/intel_xvmc.c
index 6cbec80..1b96945 100644
--- a/src/xvmc/intel_xvmc.c
+++ b/src/xvmc/intel_xvmc.c
@@ -105,8 +105,6 @@ unsigned int mb_bytes_420[] = {
 
 void LOCK_HARDWARE(drm_context_t ctx)
 {
-	char __ret = 0;
-
 	PPTHREAD_MUTEX_LOCK();
 	assert(!xvmc_driver->locked);
 
@@ -218,11 +216,6 @@ _X_EXPORT Status XvMCCreateContext(Display * display, XvPortID port,
 	int error_base;
 	int event_base;
 	int priv_count;
-	int isCapable;
-	int screen = DefaultScreen(display);
-	intel_xvmc_context_ptr intel_ctx;
-	int fd;
-	char *driverName = NULL, *deviceName = NULL;
 
 	/* Verify Obvious things first */
 	if (!display || !context)
@@ -482,7 +475,6 @@ _X_EXPORT Status XvMCCreateBlocks(Display * display, XvMCContext * context,
 				  unsigned int num_blocks,
 				  XvMCBlockArray * block)
 {
-	Status ret;
 	if (!display || !context || !num_blocks || !block)
 		return BadValue;
 
@@ -505,7 +497,6 @@ _X_EXPORT Status XvMCCreateBlocks(Display * display, XvMCContext * context,
  */
 _X_EXPORT Status XvMCDestroyBlocks(Display * display, XvMCBlockArray * block)
 {
-	Status ret;
 	if (!display || !block)
 		return BadValue;
 
@@ -678,13 +669,10 @@ _X_EXPORT Status XvMCPutSurface(Display * display, XvMCSurface * surface,
  */
 _X_EXPORT Status XvMCSyncSurface(Display * display, XvMCSurface * surface)
 {
-	Status ret;
-	int stat = 0;
-
 	if (!display || !surface)
 		return XvMCBadSurface;
 
-	return ret;
+	return Success;
 }
 
 /*
@@ -739,9 +727,6 @@ _X_EXPORT Status XvMCGetSurfaceStatus(Display * display, XvMCSurface * surface,
  */
 _X_EXPORT Status XvMCHideSurface(Display * display, XvMCSurface * surface)
 {
-	int stat = 0;
-	Status ret;
-
 	if (!display || !surface)
 		return XvMCBadSurface;
 
@@ -1071,7 +1056,7 @@ _X_EXPORT Status XvMCLoadQMatrix(Display * display, XvMCContext * context,
 _X_EXPORT Status XvMCPutSlice(Display * display, XvMCContext * context,
 			      char *slice, int nbytes)
 {
-	if (xvmc_driver->put_slice(display, context, slice, nbytes)) {
+	if (xvmc_driver->put_slice(display, context, (unsigned char *) slice, nbytes)) {
 		XVMC_ERR("PutSlice fail\n");
 		return BadValue;
 	}
@@ -1082,7 +1067,7 @@ _X_EXPORT Status XvMCPutSlice2(Display * display, XvMCContext * context,
 			       char *slice, int nbytes, int slice_code)
 {
 	if (xvmc_driver->put_slice2
-	    (display, context, slice, nbytes, slice_code)) {
+	    (display, context, (unsigned char *) slice, nbytes, slice_code)) {
 		XVMC_ERR("PutSlice2 fail\n");
 		return BadValue;
 	}
diff --git a/src/xvmc/intel_xvmc_dump.c b/src/xvmc/intel_xvmc_dump.c
index 974bcbb..d22d311 100644
--- a/src/xvmc/intel_xvmc_dump.c
+++ b/src/xvmc/intel_xvmc_dump.c
@@ -38,7 +38,7 @@ void intel_xvmc_dump_open(void)
 	if (xvmc_dump)
 		return;
 
-	if (d = getenv("INTEL_XVMC_DUMP"))
+	if ((d = getenv("INTEL_XVMC_DUMP")))
 		xvmc_dump = 1;
 
 	if (xvmc_dump) {
diff --git a/src/xvmc/xvmc_vld.c b/src/xvmc/xvmc_vld.c
index addc7c9..d72e105 100644
--- a/src/xvmc/xvmc_vld.c
+++ b/src/xvmc/xvmc_vld.c
@@ -785,7 +785,6 @@ static Status begin_surface(Display * display, XvMCContext * context,
 			    XvMCSurface * future,
 			    const XvMCMpegControl * control)
 {
-	struct i965_xvmc_contex *i965_ctx;
 	struct intel_xvmc_surface *priv_target, *priv_past, *priv_future;
 	intel_xvmc_context_ptr intel_ctx = context->privData;
 	Status ret;
diff --git a/uxa/uxa-accel.c b/uxa/uxa-accel.c
index a5066c8..0650ac2 100644
--- a/uxa/uxa-accel.c
+++ b/uxa/uxa-accel.c
@@ -120,6 +120,10 @@ uxa_fill_spans(DrawablePtr pDrawable, GCPtr pGC, int n,
 
 		solid = uxa_acquire_solid(screen, src->pSourcePict);
 		FreePicture(src, 0);
+		if (!solid) {
+			FreePicture(dst, 0);
+			goto solid;
+		}
 
 		src = solid;
 		src_pixmap = uxa_get_offscreen_pixmap(src->pDrawable,
@@ -1110,6 +1114,10 @@ try_solid:
 
 			solid = uxa_acquire_solid(screen, src->pSourcePict);
 			FreePicture(src, 0);
+			if (!solid) {
+				FreePicture(dst, 0);
+				goto err;
+			}
 
 			src = solid;
 			src_pixmap = uxa_get_offscreen_pixmap(src->pDrawable,
diff --git a/uxa/uxa-glyphs.c b/uxa/uxa-glyphs.c
index 420e891..0f5ddda 100644
--- a/uxa/uxa-glyphs.c
+++ b/uxa/uxa-glyphs.c
@@ -111,6 +111,9 @@ static void uxa_unrealize_glyph_caches(ScreenPtr pScreen)
 	uxa_screen_t *uxa_screen = uxa_get_screen(pScreen);
 	int i;
 
+	if (!uxa_screen->glyph_cache_initialized)
+		return;
+
 	for (i = 0; i < UXA_NUM_GLYPH_CACHE_FORMATS; i++) {
 		uxa_glyph_cache_t *cache = &uxa_screen->glyphCaches[i];
 
@@ -120,6 +123,7 @@ static void uxa_unrealize_glyph_caches(ScreenPtr pScreen)
 		if (cache->glyphs)
 			free(cache->glyphs);
 	}
+	uxa_screen->glyph_cache_initialized = FALSE;
 }
 
 void uxa_glyphs_fini(ScreenPtr pScreen)
@@ -145,6 +149,10 @@ static Bool uxa_realize_glyph_caches(ScreenPtr pScreen)
 	};
 	int i;
 
+	if (uxa_screen->glyph_cache_initialized)
+		return TRUE;
+
+	uxa_screen->glyph_cache_initialized = TRUE;
 	memset(uxa_screen->glyphCaches, 0, sizeof(uxa_screen->glyphCaches));
 
 	for (i = 0; i < sizeof(formats)/sizeof(formats[0]); i++) {
@@ -214,17 +222,7 @@ Bool uxa_glyphs_init(ScreenPtr pScreen)
 	if (uxa_get_screen(pScreen)->force_fallback)
 		return TRUE;
 
-	/* We are trying to initialise per screen resources prior to the
-	 * complete initialisation of the screen. So ensure the components
-	 * that we depend upon are initialsed prior to our use.
-	 */
-	if (!CreateScratchPixmapsForScreen(pScreen->myNum))
-		return FALSE;
-
-	if (!uxa_realize_glyph_caches(pScreen))
-		return FALSE;
-
-	return TRUE;
+	return uxa_realize_glyph_caches(pScreen);
 }
 
 /* The most efficient thing to way to upload the glyph to the screen
diff --git a/uxa/uxa-priv.h b/uxa/uxa-priv.h
index 92536cc..ac206af 100644
--- a/uxa/uxa-priv.h
+++ b/uxa/uxa-priv.h
@@ -139,6 +139,7 @@ typedef struct {
 	unsigned offScreenCounter;
 
 	uxa_glyph_cache_t glyphCaches[UXA_NUM_GLYPH_CACHE_FORMATS];
+	Bool glyph_cache_initialized;
 
 	PicturePtr solid_clear, solid_black, solid_white;
 	uxa_solid_cache_t solid_cache[UXA_NUM_SOLID_CACHE];
diff --git a/uxa/uxa-render.c b/uxa/uxa-render.c
index cf8b8ea..0f06e82 100644
--- a/uxa/uxa-render.c
+++ b/uxa/uxa-render.c
@@ -1061,6 +1061,8 @@ try_solid:
 			int src_off_x, src_off_y;
 
 			solid = uxa_acquire_solid(screen, src->pSourcePict);
+			if (!solid)
+				goto err_src;
 			FreePicture(src, 0);
 
 			src = solid;
@@ -1090,6 +1092,7 @@ try_solid:
 	/* XXX xserver-1.8: CompositeRects is not tracked by Damage, so we must
 	 * manually append the damaged regions ourselves.
 	 */
+	pixman_region_translate(&region, -dst_x, -dst_y);
 	DamageRegionAppend(dst->pDrawable, &region);
 
 	pixman_region_fini(&region);
