From 296a986e5258e2fd13ec494071b7063bd639cd68 Mon Sep 17 00:00:00 2001
From: Zhenyu Wang <zhenyu.z.wang@intel.com>
Date: Mon, 23 Mar 2009 11:19:58 +0000
Subject: KMS: hook up output properties for randr

This gets output properties from kernel, then hook them up
for randr. So we can control output properties through randr
like in UMS.

Signed-off-by: Zhenyu Wang <zhenyu.z.wang@intel.com>
---
diff --git a/src/drmmode_display.c b/src/drmmode_display.c
index a276ff7..7b97a64 100644
--- a/src/drmmode_display.c
+++ b/src/drmmode_display.c
@@ -35,6 +35,7 @@
 #include "i830.h"
 #include "intel_bufmgr.h"
 #include "xf86drmMode.h"
+#include "X11/Xatom.h"
 
 typedef struct {
     int fd;
@@ -52,11 +53,20 @@ typedef struct {
 } drmmode_crtc_private_rec, *drmmode_crtc_private_ptr;
 
 typedef struct {
+    drmModePropertyPtr mode_prop;
+    uint64_t value;
+    int num_atoms; /* if range prop, num_atoms == 1; if enum prop, num_atoms == num_enums + 1 */
+    Atom *atoms;
+} drmmode_prop_rec, *drmmode_prop_ptr;
+
+typedef struct {
     drmmode_ptr drmmode;
     int output_id;
     drmModeConnectorPtr mode_output;
     drmModeEncoderPtr mode_encoder;
     drmModePropertyBlobPtr edid_blob;
+    int num_props;
+    drmmode_prop_ptr props;
 } drmmode_output_private_rec, *drmmode_output_private_ptr;
 
 static void
@@ -508,9 +518,15 @@ static void
 drmmode_output_destroy(xf86OutputPtr output)
 {
 	drmmode_output_private_ptr drmmode_output = output->driver_private;
+	int i;
 
 	if (drmmode_output->edid_blob)
 		drmModeFreePropertyBlob(drmmode_output->edid_blob);
+	for (i = 0; i < drmmode_output->num_props; i++) {
+	    drmModeFreeProperty(drmmode_output->props[i].mode_prop);
+	    xfree(drmmode_output->props[i].atoms);
+	}
+	xfree(drmmode_output->props);
 	drmModeFreeConnector(drmmode_output->mode_output);
 	xfree(drmmode_output);
 	output->driver_private = NULL;
@@ -542,7 +558,162 @@ drmmode_output_dpms(xf86OutputPtr output, int mode)
 	}
 }
 
+static Bool
+drmmode_property_ignore(drmModePropertyPtr prop)
+{
+    if (!prop)
+	return TRUE;
+    /* ignore blob prop */
+    if (prop->flags & DRM_MODE_PROP_BLOB)
+	return TRUE;
+    /* ignore standard property */
+    if (!strcmp(prop->name, "EDID") ||
+	    !strcmp(prop->name, "DPMS"))
+	return TRUE;
+
+    return FALSE;
+}
+
+static void
+drmmode_output_create_resources(xf86OutputPtr output)
+{
+    drmmode_output_private_ptr drmmode_output = output->driver_private;
+    drmModeConnectorPtr mode_output = drmmode_output->mode_output;
+    drmmode_ptr drmmode = drmmode_output->drmmode;
+    drmModePropertyPtr drmmode_prop;
+    int i, j, err;
+
+    drmmode_output->props = xcalloc(mode_output->count_props, sizeof(drmmode_prop_rec));
+    if (!drmmode_output->props)
+	return;
+
+    drmmode_output->num_props = 0;
+    for (i = 0, j = 0; i < mode_output->count_props; i++) {
+	drmmode_prop = drmModeGetProperty(drmmode->fd, mode_output->props[i]);
+	if (drmmode_property_ignore(drmmode_prop)) {
+	    drmModeFreeProperty(drmmode_prop);
+	    continue;
+	}
+	drmmode_output->props[j].mode_prop = drmmode_prop;
+	drmmode_output->props[j].value = mode_output->prop_values[i];
+	drmmode_output->num_props++;
+	j++;
+    }
+
+    for (i = 0; i < drmmode_output->num_props; i++) {
+	drmmode_prop_ptr p = &drmmode_output->props[i];
+	drmmode_prop = p->mode_prop;
+
+	if (drmmode_prop->flags & DRM_MODE_PROP_RANGE) {
+	    INT32 range[2];
+
+	    p->num_atoms = 1;
+	    p->atoms = xcalloc(p->num_atoms, sizeof(Atom));
+	    if (!p->atoms)
+		continue;
+	    p->atoms[0] = MakeAtom(drmmode_prop->name, strlen(drmmode_prop->name), TRUE);
+	    range[0] = drmmode_prop->values[0];
+	    range[1] = drmmode_prop->values[1];
+	    err = RRConfigureOutputProperty(output->randr_output, p->atoms[0],
+		    FALSE, TRUE,
+		    drmmode_prop->flags & DRM_MODE_PROP_IMMUTABLE ? TRUE : FALSE,
+		    2, range);
+	    if (err != 0) {
+		xf86DrvMsg(output->scrn->scrnIndex, X_ERROR,
+			"RRConfigureOutputProperty error, %d\n", err);
+	    }
+	    err = RRChangeOutputProperty(output->randr_output, p->atoms[0],
+		    XA_INTEGER, 32, PropModeReplace, 1, &p->value, FALSE, TRUE);
+	    if (err != 0) {
+		xf86DrvMsg(output->scrn->scrnIndex, X_ERROR,
+			"RRChangeOutputProperty error, %d\n", err);
+	    }
+	} else if (drmmode_prop->flags & DRM_MODE_PROP_ENUM) {
+	    p->num_atoms = drmmode_prop->count_enums + 1;
+	    p->atoms = xcalloc(p->num_atoms, sizeof(Atom));
+	    if (!p->atoms)
+		continue;
+	    p->atoms[0] = MakeAtom(drmmode_prop->name, strlen(drmmode_prop->name), TRUE);
+	    for (j = 1; j <= drmmode_prop->count_enums; j++) {
+		struct drm_mode_property_enum *e = &drmmode_prop->enums[j-1];
+		p->atoms[j] = MakeAtom(e->name, strlen(e->name), TRUE);
+	    }
+	    err = RRConfigureOutputProperty(output->randr_output, p->atoms[0],
+		    FALSE, FALSE,
+		    drmmode_prop->flags & DRM_MODE_PROP_IMMUTABLE ? TRUE : FALSE,
+		    p->num_atoms - 1, (INT32 *)&p->atoms[1]);
+	    if (err != 0) {
+		xf86DrvMsg(output->scrn->scrnIndex, X_ERROR,
+			"RRConfigureOutputProperty error, %d\n", err);
+	    }
+	    for (j = 0; j < drmmode_prop->count_enums; j++)
+		if (drmmode_prop->enums[j].value == p->value)
+		    break;
+	    /* there's always a matching value */
+	    err = RRChangeOutputProperty(output->randr_output, p->atoms[0],
+		    XA_ATOM, 32, PropModeReplace, 1, &p->atoms[j+1], FALSE, TRUE);
+	    if (err != 0) {
+		xf86DrvMsg(output->scrn->scrnIndex, X_ERROR,
+			"RRChangeOutputProperty error, %d\n", err);
+	    }
+	}
+    }
+}
+
+static Bool
+drmmode_output_set_property(xf86OutputPtr output, Atom property,
+		RRPropertyValuePtr value)
+{
+    drmmode_output_private_ptr drmmode_output = output->driver_private;
+    drmmode_ptr drmmode = drmmode_output->drmmode;
+    int i;
+
+    for (i = 0; i < drmmode_output->num_props; i++) {
+	drmmode_prop_ptr p = &drmmode_output->props[i];
+
+	if (p->atoms[0] != property)
+	    continue;
+
+	if (p->mode_prop->flags & DRM_MODE_PROP_RANGE) {
+	    uint32_t val;
+
+	    if (value->type != XA_INTEGER || value->format != 32 ||
+		    value->size != 1)
+		return FALSE;
+	    val = *(uint32_t *)value->data;
+
+	    drmModeConnectorSetProperty(drmmode->fd, drmmode_output->output_id,
+		    p->mode_prop->prop_id, (uint64_t)val);
+	    return TRUE;
+	} else if (p->mode_prop->flags & DRM_MODE_PROP_ENUM) {
+	    Atom	atom;
+	    const char	*name;
+	    int		j;
+
+	    if (value->type != XA_ATOM || value->format != 32 || value->size != 1)
+		return FALSE;
+	    memcpy(&atom, value->data, 4);
+	    name = NameForAtom(atom);
+
+	    /* search for matching name string, then set its value down */
+	    for (j = 0; j < p->mode_prop->count_enums; j++) {
+		if (!strcmp(p->mode_prop->enums[j].name, name)) {
+		    drmModeConnectorSetProperty(drmmode->fd, drmmode_output->output_id,
+			    p->mode_prop->prop_id, p->mode_prop->enums[j].value);
+		    return TRUE;
+		}
+	    }
+	}
+    }
+    /* no property found? */
+    return FALSE;
+}
+
 static const xf86OutputFuncsRec drmmode_output_funcs = {
+	.create_resources = drmmode_output_create_resources,
+#ifdef RANDR_12_INTERFACE
+	.set_property = drmmode_output_set_property,
+#endif
 	.dpms = drmmode_output_dpms,
 #if 0
 
--
cgit v0.8.2
From 115fc9a7d79da07301b96d9fc5c513d33734d273 Mon Sep 17 00:00:00 2001
From: Keith Packard <keithp@keithp.com>
Date: Fri, 01 May 2009 18:44:13 +0000
Subject: intel_batch_start_atomic: fix size passed to intel_batch_require_space (*4)

intel_batch_start_atomic takes an argument in 32-bit units, and so it must
multiply that by 4 before passing it to intel_batch_require_space, which
takes an argument in bytes.

We should figure out what units we want to use and use the same everywhere...

Signed-off-by: Keith Packard <keithp@keithp.com>
(cherry picked from commit 1142353b487c155a31011923fbd08ec67e60f505)
---
diff --git a/src/i830_batchbuffer.h b/src/i830_batchbuffer.h
index a72786e..ec87084 100644
--- a/src/i830_batchbuffer.h
+++ b/src/i830_batchbuffer.h
@@ -56,7 +56,7 @@ intel_batch_start_atomic(ScrnInfoPtr pScrn, unsigned int sz)
     I830Ptr pI830 = I830PTR(pScrn);
 
     assert(!pI830->in_batch_atomic);
-    intel_batch_require_space(pScrn, pI830, sz);
+    intel_batch_require_space(pScrn, pI830, sz * 4);
 
     pI830->in_batch_atomic = TRUE;
     pI830->batch_atomic_limit = pI830->batch_used + sz * 4;
--
cgit v0.8.2
From a066cfb0be6e6b20a27eb4ba17f503f13e65e082 Mon Sep 17 00:00:00 2001
From: Carl Worth <cworth@cworth.org>
Date: Wed, 06 May 2009 16:17:46 +0000
Subject: Hold reference to video binding table until all rects are painted.

The optimization of unreferencing the binding table when the relocation is
posted causes the object to be dereferenced for each box in the clip list,
causing general chaos in the buffer manager. It's easier to just hold a
reference to the object until all of the boxes are painted and then drop it.

Signed-off-by: Keith Packard <keithp@keithp.com>
(cherry picked from commit 11a853bd8e5d907fe7f5bd907453bcdac9032861)

Conflicts:

	src/i965_video.c
---
diff --git a/src/i965_video.c b/src/i965_video.c
index f6020d4..c0a69fd 100644
--- a/src/i965_video.c
+++ b/src/i965_video.c
@@ -795,7 +795,6 @@ i965_emit_video_setup(ScrnInfoPtr pScrn, drm_intel_bo *bind_bo, int n_src_surf)
     OUT_BATCH(0); /* sf */
     /* Only the PS uses the binding table */
     OUT_RELOC(bind_bo, I915_GEM_DOMAIN_INSTRUCTION, 0, 0);
-    drm_intel_bo_unreference(bind_bo);
 
     /* Blend constant color (magenta is fun) */
     OUT_BATCH(BRW_3DSTATE_CONSTANT_COLOR | 3);
@@ -1161,6 +1160,10 @@ I965DisplayVideoTextured(ScrnInfoPtr pScrn, I830PortPrivPtr pPriv, int id,
     }
 
     i830MarkSync(pScrn);
+
+    /* release reference once we're finished */
+    drm_intel_bo_unreference(bind_bo);
+
 #if WATCH_STATS
     i830_dump_error_state(pScrn);
 #endif
--
cgit v0.8.2
From efda7c776b95f8634cd6a2fed88d526de80176bc Mon Sep 17 00:00:00 2001
From: Carl Worth <cworth@cworth.org>
Date: Wed, 06 May 2009 16:37:34 +0000
Subject: Split i915 textured video commands to fit into batch buffers.

i915 textured video commands are quite long, but must be contained in the
same batch buffer as the 3D setup commands. When the number of clip rects
for the video becomes too large for the associated commands to fit in the
same batch buffer, this change breaks the sequence into pieces, ensuring
that each batch contains the necessary setup sequence.

Signed-off-by: Keith Packard <keithp@keithp.com>
(cherry picked from commit 8255cca2c9092f7ecb798944aa8f03fa3efcfa6c)

Conflicts:

	src/i915_video.c
---
diff --git a/src/i915_video.c b/src/i915_video.c
index 93e0c86..afa1055 100644
--- a/src/i915_video.c
+++ b/src/i915_video.c
@@ -50,7 +50,8 @@ I915DisplayVideoTextured(ScrnInfoPtr pScrn, I830PortPrivPtr pPriv, int id,
    I830Ptr pI830 = I830PTR(pScrn);
    uint32_t format, ms3, s5;
    BoxPtr pbox = REGION_RECTS(dstRegion);
-   int nbox = REGION_NUM_RECTS(dstRegion);
+   int nbox_total = REGION_NUM_RECTS(dstRegion);
+   int nbox_this_time;
    int dxo, dyo, pix_xoff, pix_yoff;
    Bool planar;
 
@@ -73,7 +74,17 @@ I915DisplayVideoTextured(ScrnInfoPtr pScrn, I830PortPrivPtr pPriv, int id,
       return;
    }
 
-   intel_batch_start_atomic(pScrn, 200 + 20 * nbox);
+#define BYTES_FOR_BOXES(n)	((200 + (n) * 20) * 4)
+#define BOXES_IN_BYTES(s)	((((s)/4) - 200) / 20)
+#define BATCH_BYTES(p)		((p)->batch_bo->size - 16)
+
+   while (nbox_total) {
+	nbox_this_time = nbox_total;
+	if (BYTES_FOR_BOXES(nbox_this_time) > BATCH_BYTES(pI830))
+		nbox_this_time = BOXES_IN_BYTES(BATCH_BYTES(pI830));
+	nbox_total -= nbox_this_time;
+
+   intel_batch_start_atomic(pScrn, 200 + 20 * nbox_this_time);
 
    IntelEmitInvarientState(pScrn);
    pI830->last_3d = LAST_3D_VIDEO;
@@ -366,7 +377,7 @@ I915DisplayVideoTextured(ScrnInfoPtr pScrn, I830PortPrivPtr pPriv, int id,
    dxo = dstRegion->extents.x1;
    dyo = dstRegion->extents.y1;
 
-   while (nbox--)
+   while (nbox_this_time--)
    {
       int box_x1 = pbox->x1;
       int box_y1 = pbox->y1;
@@ -415,6 +426,7 @@ I915DisplayVideoTextured(ScrnInfoPtr pScrn, I830PortPrivPtr pPriv, int id,
    }
 
    intel_batch_end_atomic(pScrn);
+   }
 
    i830MarkSync(pScrn);
 }
--
cgit v0.8.2
From 77153d690a3673fdee7bef8e567816b754c43081 Mon Sep 17 00:00:00 2001
From: Albert Damen <albrt@gmx.net>
Date: Sun, 05 Apr 2009 14:36:35 +0000
Subject: Fix crash with XV with large virtual display

If a virtual display with width > 2048 is used, the first time
an XV buffer is needed will result in a BadAlloc error message,
but the next time X would crash.

Signed-off-by: Eric Anholt <eric@anholt.net>
(cherry picked from commit d7ca870e1ce251d42e3689a8e1e7d080ab1325fb)
---
diff --git a/src/i830_video.c b/src/i830_video.c
index 4ed3047..a62d7a1 100644
--- a/src/i830_video.c
+++ b/src/i830_video.c
@@ -2392,6 +2392,7 @@ I830PutImage(ScrnInfoPtr pScrn,
                 return BadAlloc;
             if (!pPriv->textured && drm_intel_bo_pin(pPriv->buf, 4096) != 0) {
                 drm_intel_bo_unreference(pPriv->buf);
+                pPriv->buf = NULL;
                 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
                            "Failed to pin xv buffer\n");
                 return BadAlloc;
--
cgit v0.8.2
From ca63a5d4afd8482d280d8d64c58021e568931e27 Mon Sep 17 00:00:00 2001
From: Keith Packard <keithp@keithp.com>
Date: Fri, 01 May 2009 18:50:17 +0000
Subject: 3D_STATE_VERTEX_BUFFERS takes four 32-bit values, not three.

The spec says this command takes an extra (mbz) 32-bit value, so let's
provide it with one.

Signed-off-by: Keith Packard <keithp@keithp.com>
(cherry picked from commit ed492131c13715b73c14d328d0668120acb58b40)
---
diff --git a/src/i965_video.c b/src/i965_video.c
index c0a69fd..7b52de7 100644
--- a/src/i965_video.c
+++ b/src/i965_video.c
@@ -1130,15 +1130,16 @@ I965DisplayVideoTextured(ScrnInfoPtr pScrn, I830PortPrivPtr pPriv, int id,
 
 	i965_emit_video_setup(pScrn, bind_bo, n_src_surf);
 
-	BEGIN_BATCH(10);
+	BEGIN_BATCH(12);
 	/* Set up the pointer to our vertex buffer */
-	OUT_BATCH(BRW_3DSTATE_VERTEX_BUFFERS | 2);
+	OUT_BATCH(BRW_3DSTATE_VERTEX_BUFFERS | 3);
 	/* four 32-bit floats per vertex */
 	OUT_BATCH((0 << VB0_BUFFER_INDEX_SHIFT) |
 		  VB0_VERTEXDATA |
 		  ((4 * 4) << VB0_BUFFER_PITCH_SHIFT));
 	OUT_RELOC(vb_bo, I915_GEM_DOMAIN_VERTEX, 0, 0);
 	OUT_BATCH(3); /* four corners to our rectangle */
+	OUT_BATCH(0); /* reserved */
 
 	OUT_BATCH(BRW_3DPRIMITIVE |
 		  BRW_3DPRIMITIVE_VERTEX_SEQUENTIAL |
@@ -1150,6 +1151,7 @@ I965DisplayVideoTextured(ScrnInfoPtr pScrn, I830PortPrivPtr pPriv, int id,
 	OUT_BATCH(1); /* single instance */
 	OUT_BATCH(0); /* start instance location */
 	OUT_BATCH(0); /* index buffer offset, ignored */
+	OUT_BATCH(MI_NOOP);
 	ADVANCE_BATCH();
 
 	intel_batch_end_atomic(pScrn);
--
cgit v0.8.2
