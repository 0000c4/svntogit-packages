diff -ruN xf86-video-intel-1d19b024dba970e4b24daccb898101f77d5529ff/man/intel.man xf86-video-intel-e2465249a90b9aefe6d7a96eb56a51fde54698a0/man/intel.man
--- xf86-video-intel-1d19b024dba970e4b24daccb898101f77d5529ff/man/intel.man	2009-03-11 00:15:54.000000000 +0000
+++ xf86-video-intel-e2465249a90b9aefe6d7a96eb56a51fde54698a0/man/intel.man	2009-03-19 23:33:44.000000000 +0000
@@ -146,15 +146,6 @@
 .IP
 Default: Textured video adaptor is preferred.
 .TP
-.BI "Option \*qLegacy3D\*q \*q" boolean \*q
-Enable support for the non-GEM mode of the 3D driver on i830 and newer.
-This will allocate a large static area for older Mesa to use for its texture
-pool.  On systems with a working GEM environment, this can be disabled to
-increase the memory pool available to other graphics tasks.
-.IP
-Default for i830 and newer: Enabled.
-.IP
-Default for i810: this option is not used.
 .BI "Option \*qAccelMethod\*q \*q" string \*q
 Choose acceleration architecture, either "XAA", "EXA", or "UXA".  XAA is the old
 XFree86 based acceleration architecture.  EXA is a simpler
@@ -322,7 +313,7 @@
 .B TV_Connector
 - connector type
 .TP 2
-This config option should be added to xorg.conf TV monitor's section, it allows you to control the TV output connector type, which bypass load detect. You can select between S-Video, Composite and Component.
+This config option should be added to xorg.conf TV monitor's section, it allows you to force the TV output connector type, which bypass load detect and TV will always be taken as connected. You can select between S-Video, Composite and Component.
 
 .SS "TMDS-1"
 First DVI SDVO output
diff -ruN xf86-video-intel-1d19b024dba970e4b24daccb898101f77d5529ff/src/drmmode_display.c xf86-video-intel-e2465249a90b9aefe6d7a96eb56a51fde54698a0/src/drmmode_display.c
--- xf86-video-intel-1d19b024dba970e4b24daccb898101f77d5529ff/src/drmmode_display.c	2009-03-11 00:15:54.000000000 +0000
+++ xf86-video-intel-e2465249a90b9aefe6d7a96eb56a51fde54698a0/src/drmmode_display.c	2009-03-19 23:33:44.000000000 +0000
@@ -60,6 +60,9 @@
 } drmmode_output_private_rec, *drmmode_output_private_ptr;
 
 static void
+drmmode_output_dpms(xf86OutputPtr output, int mode);
+
+static void
 drmmode_ConvertFromKMode(ScrnInfoPtr scrn,
 			 drmModeModeInfoPtr kmode,
 			 DisplayModePtr	mode)
@@ -210,6 +213,16 @@
 	else
 		ret = TRUE;
 
+	/* Turn on any outputs on this crtc that may have been disabled */
+	for (i = 0; i < xf86_config->num_output; i++) {
+		xf86OutputPtr output = xf86_config->output[i];
+
+		if (output->crtc != crtc)
+			continue;
+
+		drmmode_output_dpms(output, DPMSModeOn);
+	}
+
 done:
 	if (!ret) {
 		crtc->x = saved_x;
diff -ruN xf86-video-intel-1d19b024dba970e4b24daccb898101f77d5529ff/src/i830_bios.c xf86-video-intel-e2465249a90b9aefe6d7a96eb56a51fde54698a0/src/i830_bios.c
--- xf86-video-intel-1d19b024dba970e4b24daccb898101f77d5529ff/src/i830_bios.c	2009-03-11 00:15:54.000000000 +0000
+++ xf86-video-intel-e2465249a90b9aefe6d7a96eb56a51fde54698a0/src/i830_bios.c	2009-03-19 23:33:44.000000000 +0000
@@ -161,7 +161,7 @@
     pI830->tv_present = general->int_tv_support;
     pI830->lvds_use_ssc = general->enable_ssc;
     if (pI830->lvds_use_ssc) {
-	if (IS_I855(pI830))
+	if (IS_I85X(pI830))
 	    pI830->lvds_ssc_freq = general->ssc_freq ? 66 : 48;
 	else
 	    pI830->lvds_ssc_freq = general->ssc_freq ? 100 : 96;
diff -ruN xf86-video-intel-1d19b024dba970e4b24daccb898101f77d5529ff/src/i830_display.c xf86-video-intel-e2465249a90b9aefe6d7a96eb56a51fde54698a0/src/i830_display.c
--- xf86-video-intel-1d19b024dba970e4b24daccb898101f77d5529ff/src/i830_display.c	2009-03-11 00:15:54.000000000 +0000
+++ xf86-video-intel-e2465249a90b9aefe6d7a96eb56a51fde54698a0/src/i830_display.c	2009-03-19 23:33:44.000000000 +0000
@@ -873,14 +873,8 @@
 
 }
 
-/**
- * Sets the power management mode of the pipe and plane.
- *
- * This code should probably grow support for turning the cursor off and back
- * on appropriately at the same time as we're turning the pipe off/on.
- */
-static void
-i830_crtc_dpms(xf86CrtcPtr crtc, int mode)
+void
+i830_crtc_enable(xf86CrtcPtr crtc)
 {
     ScrnInfoPtr pScrn = crtc->scrn;
     I830Ptr pI830 = I830PTR(pScrn);
@@ -893,112 +887,148 @@
     int dspbase_reg = (plane == 0) ? DSPABASE : DSPBBASE;
     uint32_t temp;
 
-    /* XXX: When our outputs are all unaware of DPMS modes other than off and
-     * on, we should map those modes to DPMSModeOff in the CRTC.
-     */
-    switch (mode) {
-    case DPMSModeOn:
-    case DPMSModeStandby:
-    case DPMSModeSuspend:
-	/* Enable the DPLL */
-	temp = INREG(dpll_reg);
-	if ((temp & DPLL_VCO_ENABLE) == 0)
-	{
-	    OUTREG(dpll_reg, temp);
-	    POSTING_READ(dpll_reg);
-	    /* Wait for the clocks to stabilize. */
-	    usleep(150);
-	    OUTREG(dpll_reg, temp | DPLL_VCO_ENABLE);
-	    POSTING_READ(dpll_reg);
-	    /* Wait for the clocks to stabilize. */
-	    usleep(150);
-	    OUTREG(dpll_reg, temp | DPLL_VCO_ENABLE);
-	    POSTING_READ(dpll_reg);
-	    /* Wait for the clocks to stabilize. */
-	    usleep(150);
-	}
+    /* Enable the DPLL */
+    temp = INREG(dpll_reg);
+    if ((temp & DPLL_VCO_ENABLE) == 0)
+    {
+	OUTREG(dpll_reg, temp);
+	POSTING_READ(dpll_reg);
+	/* Wait for the clocks to stabilize. */
+	usleep(150);
+	OUTREG(dpll_reg, temp | DPLL_VCO_ENABLE);
+	POSTING_READ(dpll_reg);
+	/* Wait for the clocks to stabilize. */
+	usleep(150);
+	OUTREG(dpll_reg, temp | DPLL_VCO_ENABLE);
+	POSTING_READ(dpll_reg);
+	/* Wait for the clocks to stabilize. */
+	usleep(150);
+    }
 
-	/* Enable the pipe */
-	temp = INREG(pipeconf_reg);
-	if ((temp & PIPEACONF_ENABLE) == 0)
-	    OUTREG(pipeconf_reg, temp | PIPEACONF_ENABLE);
+    /* Enable the pipe */
+    temp = INREG(pipeconf_reg);
+    if ((temp & PIPEACONF_ENABLE) == 0)
+	OUTREG(pipeconf_reg, temp | PIPEACONF_ENABLE);
+
+    /* Enable the plane */
+    temp = INREG(dspcntr_reg);
+    if ((temp & DISPLAY_PLANE_ENABLE) == 0)
+    {
+	OUTREG(dspcntr_reg, temp | DISPLAY_PLANE_ENABLE);
+	/* Flush the plane changes */
+	OUTREG(dspbase_reg, INREG(dspbase_reg));
+    }
 
-	/* Enable the plane */
-	temp = INREG(dspcntr_reg);
-	if ((temp & DISPLAY_PLANE_ENABLE) == 0)
-	{
-	    OUTREG(dspcntr_reg, temp | DISPLAY_PLANE_ENABLE);
-	    /* Flush the plane changes */
-	    OUTREG(dspbase_reg, INREG(dspbase_reg));
-	}
+    i830_crtc_load_lut(crtc);
 
-	i830_crtc_load_lut(crtc);
+    /* Give the overlay scaler a chance to enable if it's on this pipe */
+    i830_crtc_dpms_video(crtc, TRUE);
 
-	/* Give the overlay scaler a chance to enable if it's on this pipe */
-	i830_crtc_dpms_video(crtc, TRUE);
+    /* Reenable compression if needed */
+    if (i830_use_fb_compression(crtc))
+	i830_enable_fb_compression(crtc);
+    i830_modeset_ctl(crtc, 0);
+}
 
-	/* Reenable compression if needed */
-	if (i830_use_fb_compression(crtc))
-	    i830_enable_fb_compression(crtc);
-	i830_modeset_ctl(crtc, 0);
-	break;
-    case DPMSModeOff:
-	i830_modeset_ctl(crtc, 1);
-	/* Shut off compression if in use */
-	if (i830_use_fb_compression(crtc))
-	    i830_disable_fb_compression(crtc);
-
-	/* Give the overlay scaler a chance to disable if it's on this pipe */
-	i830_crtc_dpms_video(crtc, FALSE);
-
-	/* 
-	 * The documentation says :
-	 * - Disable planes (VGA or hires)
-	 * - Disable pipe
-	 * - Disable VGA display
-	 */
+void
+i830_crtc_disable(xf86CrtcPtr crtc, Bool disable_pipe)
+{
+    ScrnInfoPtr pScrn = crtc->scrn;
+    I830Ptr pI830 = I830PTR(pScrn);
+    I830CrtcPrivatePtr intel_crtc = crtc->driver_private;
+    int pipe = intel_crtc->pipe;
+    int plane = intel_crtc->plane;
+    int dpll_reg = (pipe == 0) ? DPLL_A : DPLL_B;
+    int pipeconf_reg = (pipe == 0) ? PIPEACONF : PIPEBCONF;
+    int dspcntr_reg = (plane == 0) ? DSPACNTR : DSPBCNTR;
+    int dspbase_reg = (plane == 0) ? DSPABASE : DSPBBASE;
+    uint32_t temp;
 
-	/* Disable display plane */
-	temp = INREG(dspcntr_reg);
-	if ((temp & DISPLAY_PLANE_ENABLE) != 0)
-	{
-	    OUTREG(dspcntr_reg, temp & ~DISPLAY_PLANE_ENABLE);
-	    /* Flush the plane changes */
-	    OUTREG(dspbase_reg, INREG(dspbase_reg));
-	    POSTING_READ(dspbase_reg);
-	}
+    i830_modeset_ctl(crtc, 1);
+    /* Shut off compression if in use */
+    if (i830_use_fb_compression(crtc))
+	i830_disable_fb_compression(crtc);
+
+    /* Give the overlay scaler a chance to disable if it's on this pipe */
+    i830_crtc_dpms_video(crtc, FALSE);
+
+    /* 
+     * The documentation says :
+     * - Disable planes (VGA or hires)
+     * - Disable pipe
+     * - Disable VGA display
+     */
+
+    /* Disable display plane */
+    temp = INREG(dspcntr_reg);
+    if ((temp & DISPLAY_PLANE_ENABLE) != 0)
+    {
+	OUTREG(dspcntr_reg, temp & ~DISPLAY_PLANE_ENABLE);
+	/* Flush the plane changes */
+	OUTREG(dspbase_reg, INREG(dspbase_reg));
+	POSTING_READ(dspbase_reg);
+    }
+
+    if (!IS_I9XX(pI830)) {
+	/* Wait for vblank for the disable to take effect */
+	i830WaitForVblank(pScrn);
+    }
 
-	if (!IS_I9XX(pI830)) {
-	    /* Wait for vblank for the disable to take effect */
-	    i830WaitForVblank(pScrn);
+    /* May need to leave pipe A on */
+    if (disable_pipe)
+    {
+	/* Next, disable display pipes */
+	temp = INREG(pipeconf_reg);
+	if ((temp & PIPEACONF_ENABLE) != 0) {
+	    OUTREG(pipeconf_reg, temp & ~PIPEACONF_ENABLE);
+	    POSTING_READ(pipeconf_reg);
 	}
 
-	/* May need to leave pipe A on */
-	if ((pipe != 0) || !(pI830->quirk_flag & QUIRK_PIPEA_FORCE))
-	{
-		/* Next, disable display pipes */
-		temp = INREG(pipeconf_reg);
-		if ((temp & PIPEACONF_ENABLE) != 0) {
-		    OUTREG(pipeconf_reg, temp & ~PIPEACONF_ENABLE);
-		    POSTING_READ(pipeconf_reg);
-		}
-
-		/* Wait for vblank for the disable to take effect. */
-		i830WaitForVblank(pScrn);
-
-		temp = INREG(dpll_reg);
-		if ((temp & DPLL_VCO_ENABLE) != 0) {
-		    OUTREG(dpll_reg, temp & ~DPLL_VCO_ENABLE);
-		    POSTING_READ(dpll_reg);
-		}
+	/* Wait for vblank for the disable to take effect. */
+	i830WaitForVblank(pScrn);
 
-		/* Wait for the clocks to turn off. */
-		usleep(150);
+	temp = INREG(dpll_reg);
+	if ((temp & DPLL_VCO_ENABLE) != 0) {
+	    OUTREG(dpll_reg, temp & ~DPLL_VCO_ENABLE);
+	    POSTING_READ(dpll_reg);
 	}
 
-	/* Disable the VGA plane that we never use. */
-	i830_disable_vga_plane (crtc);
+	/* Wait for the clocks to turn off. */
+	usleep(150);
+    }
+
+    /* Disable the VGA plane that we never use. */
+    i830_disable_vga_plane (crtc);
+}
+
+/**
+ * Sets the power management mode of the pipe and plane.
+ *
+ * This code should probably grow support for turning the cursor off and back
+ * on appropriately at the same time as we're turning the pipe off/on.
+ */
+static void
+i830_crtc_dpms(xf86CrtcPtr crtc, int mode)
+{
+    ScrnInfoPtr pScrn = crtc->scrn;
+    I830Ptr pI830 = I830PTR(pScrn);
+    I830CrtcPrivatePtr intel_crtc = crtc->driver_private;
+    int pipe = intel_crtc->pipe;
+    Bool disable_pipe = TRUE;
 
+    /* XXX: When our outputs are all unaware of DPMS modes other than off and
+     * on, we should map those modes to DPMSModeOff in the CRTC.
+     */
+    switch (mode) {
+    case DPMSModeOn:
+    case DPMSModeStandby:
+    case DPMSModeSuspend:
+	i830_crtc_enable(crtc);
+	break;
+    case DPMSModeOff:
+	if ((pipe == 0) && (pI830->quirk_flag & QUIRK_PIPEA_FORCE))
+	    disable_pipe = FALSE;
+	i830_crtc_disable(crtc, disable_pipe);
 	break;
     }
 
diff -ruN xf86-video-intel-1d19b024dba970e4b24daccb898101f77d5529ff/src/i830_display.h xf86-video-intel-e2465249a90b9aefe6d7a96eb56a51fde54698a0/src/i830_display.h
--- xf86-video-intel-1d19b024dba970e4b24daccb898101f77d5529ff/src/i830_display.h	2009-03-11 00:15:54.000000000 +0000
+++ xf86-video-intel-e2465249a90b9aefe6d7a96eb56a51fde54698a0/src/i830_display.h	2009-03-19 23:33:44.000000000 +0000
@@ -32,6 +32,8 @@
 void i830WaitForVblank(ScrnInfoPtr pScrn);
 void i830DescribeOutputConfiguration(ScrnInfoPtr pScrn);
 void i830_set_new_crtc_bo(ScrnInfoPtr pScrn);
+void i830_crtc_disable(xf86CrtcPtr crtc, Bool disable_pipe);
+void i830_crtc_enable(xf86CrtcPtr crtc);
 
 xf86CrtcPtr i830GetLoadDetectPipe(xf86OutputPtr output, DisplayModePtr mode, int *dpms_mode);
 void i830ReleaseLoadDetectPipe(xf86OutputPtr output, int dpms_mode);
diff -ruN xf86-video-intel-1d19b024dba970e4b24daccb898101f77d5529ff/src/i830_driver.c xf86-video-intel-e2465249a90b9aefe6d7a96eb56a51fde54698a0/src/i830_driver.c
--- xf86-video-intel-1d19b024dba970e4b24daccb898101f77d5529ff/src/i830_driver.c	2009-03-11 00:15:54.000000000 +0000
+++ xf86-video-intel-e2465249a90b9aefe6d7a96eb56a51fde54698a0/src/i830_driver.c	2009-03-19 23:33:44.000000000 +0000
@@ -311,7 +311,6 @@
    OPTION_LVDS24BITMODE,
    OPTION_FBC,
    OPTION_TILING,
-   OPTION_LEGACY3D,
    OPTION_LVDSFIXEDMODE,
    OPTION_FORCEENABLEPIPEA,
 #ifdef INTEL_XVMC
@@ -332,9 +331,6 @@
    {OPTION_LVDS24BITMODE, "LVDS24Bit",	OPTV_BOOLEAN,	{0},	FALSE},
    {OPTION_FBC,		"FramebufferCompression", OPTV_BOOLEAN, {0}, TRUE},
    {OPTION_TILING,	"Tiling",	OPTV_BOOLEAN,	{0},	TRUE},
-#ifdef XF86DRI
-   {OPTION_LEGACY3D,	"Legacy3D",     OPTV_BOOLEAN,	{0},	FALSE},
-#endif
    {OPTION_LVDSFIXEDMODE, "LVDSFixedMode", OPTV_BOOLEAN,	{0},	FALSE},
    {OPTION_FORCEENABLEPIPEA, "ForceEnablePipeA", OPTV_BOOLEAN,	{0},	FALSE},
 #ifdef INTEL_XVMC
@@ -1707,12 +1703,8 @@
     pI830->accel = ACCEL_UXA;
 
     if ((s = (char *)xf86GetOptValString(pI830->Options, OPTION_ACCELMETHOD))) {
-	if (!xf86NameCmp(s, "EXA"))
-	    pI830->accel = ACCEL_EXA;
-	else if (!xf86NameCmp(s, "UXA"))
-	    pI830->accel = ACCEL_UXA;
-	else
-	    pI830->accel = ACCEL_UXA;
+	if (xf86NameCmp(s, "UXA"))
+	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "kernel mode setting active,overridding accelmethod and using UXA\n");
     }
 
     pI830->can_resize = FALSE;
@@ -2283,7 +2275,7 @@
    /* Disable pipes */
    for (i = 0; i < xf86_config->num_crtc; i++) {
       xf86CrtcPtr crtc = xf86_config->crtc[i];
-      crtc->funcs->dpms(crtc, DPMSModeOff);
+      i830_crtc_disable(crtc, TRUE);
    }
    i830WaitForVblank(pScrn);
 
@@ -3019,11 +3011,6 @@
     */
    if (!pI830->can_resize && pI830->directRenderingType == DRI_NONE && I830DRIScreenInit(pScreen))
        pI830->directRenderingType = DRI_XF86DRI;
-
-   if (pI830->directRenderingType == DRI_XF86DRI) {
-       pI830->allocate_classic_textures =
-	   xf86ReturnOptValBool(pI830->Options, OPTION_LEGACY3D, TRUE);
-   }
 #endif
 
    /* Enable tiling by default */
@@ -3473,8 +3460,9 @@
 I830EnterVT(int scrnIndex, int flags)
 {
    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
+   xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
    I830Ptr  pI830 = I830PTR(pScrn);
-   int ret;
+   int i, ret;
 
    DPRINTF(PFX, "Enter VT\n");
 
@@ -3495,6 +3483,23 @@
 	  SaveHWState(pScrn);
    }
 
+   /* Get the hardware into a known state if needed */
+   if (!pI830->use_drm_mode) {
+       /* Disable outputs */
+       for (i = 0; i < xf86_config->num_output; i++) {
+	   xf86OutputPtr   output = xf86_config->output[i];
+	   output->funcs->dpms(output, DPMSModeOff);
+       }
+       i830WaitForVblank(pScrn);
+
+       /* Disable pipes */
+       for (i = 0; i < xf86_config->num_crtc; i++) {
+	   xf86CrtcPtr crtc = xf86_config->crtc[i];
+	   i830_crtc_disable(crtc, TRUE);
+       }
+       i830WaitForVblank(pScrn);
+   }
+
    pI830->leaving = FALSE;
 
    if (!pI830->use_drm_mode)
diff -ruN xf86-video-intel-1d19b024dba970e4b24daccb898101f77d5529ff/src/i830_memory.c xf86-video-intel-e2465249a90b9aefe6d7a96eb56a51fde54698a0/src/i830_memory.c
--- xf86-video-intel-1d19b024dba970e4b24daccb898101f77d5529ff/src/i830_memory.c	2009-03-11 00:15:54.000000000 +0000
+++ xf86-video-intel-e2465249a90b9aefe6d7a96eb56a51fde54698a0/src/i830_memory.c	2009-03-19 23:33:44.000000000 +0000
@@ -253,7 +253,8 @@
 	mem->bound = TRUE;
     }
 
-    if (mem->tiling != TILE_NONE && !pI830->use_drm_mode) {
+    if (mem->tiling != TILE_NONE && !pI830->use_drm_mode &&
+	!pI830->kernel_exec_fencing) {
 	mem->fence_nr = i830_set_tiling(pScrn, mem->offset, mem->pitch,
 					mem->allocated_size, mem->tiling);
     }
@@ -504,9 +505,6 @@
 	    mmsize -= ROUND_TO_PAGE(3 * pScrn->displayWidth * pI830->cpp *
 				    pScrn->virtualY);
 	}
-	/* Classic textures are fixed. */
-	if (pI830->allocate_classic_textures)
-	    mmsize -= MB(32);
 	/* Overlay and cursors, if physical, need to be allocated outside
 	 * of the kernel memory manager.
 	 */
@@ -535,12 +533,8 @@
 		int ret;
 
 		sp.param = I915_SETPARAM_NUM_USED_FENCES;
-		if (pI830->use_drm_mode)
-		    sp.value = 0; /* kernel gets them all */
-		else if (pI830->directRenderingType == DRI_XF86DRI)
-		    sp.value = 3; /* front/back/depth */
-		else
-		    sp.value = 2; /* just front for DRI2 (both old & new though) */
+		sp.value = 0; /* kernel gets them all */
+
 		ret = drmCommandWrite(pI830->drmSubFD, DRM_I915_SETPARAM, &sp,
 				      sizeof(sp));
 		if (ret == 0)
@@ -566,6 +560,8 @@
 	    i830_free_memory(pScrn, pI830->memory_manager);
 	    pI830->memory_manager = NULL;
 	}
+    } else {
+	pI830->allocate_classic_textures = TRUE;
     }
 #endif /* XF86DRI */
 
@@ -1445,7 +1441,7 @@
 
     if (pI830->memory_manager == NULL) {
 	pI830->fake_bufmgr_mem = i830_allocate_memory(pScrn, "fake bufmgr",
-						      MB(1), PITCH_NONE, GTT_PAGE_SIZE, 0,
+						      MB(8), PITCH_NONE, GTT_PAGE_SIZE, 0,
 						      TILE_NONE);
 	if (pI830->fake_bufmgr_mem == NULL) {
 	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
diff -ruN xf86-video-intel-1d19b024dba970e4b24daccb898101f77d5529ff/src/i830_sdvo.c xf86-video-intel-e2465249a90b9aefe6d7a96eb56a51fde54698a0/src/i830_sdvo.c
--- xf86-video-intel-1d19b024dba970e4b24daccb898101f77d5529ff/src/i830_sdvo.c	2009-03-11 00:15:54.000000000 +0000
+++ xf86-video-intel-e2465249a90b9aefe6d7a96eb56a51fde54698a0/src/i830_sdvo.c	2009-03-19 23:33:44.000000000 +0000
@@ -1039,8 +1039,13 @@
 
 	    ErrorF("input modeline:\n");
 	    xf86PrintModeline(0, adjusted_mode);
+
+	    /* adjust origin mode's clock for current input,
+	       for correct pixel mulitiplier setting. */
+	    mode->Clock = adjusted_mode->Clock;
+
 	    /* Clock range is required to be in 100-200Mhz */
-	    adjusted_mode->Clock *= i830_sdvo_get_pixel_multiplier(adjusted_mode);
+	    adjusted_mode->Clock *= i830_sdvo_get_pixel_multiplier(mode);
 	} else {
 	    return FALSE;
 	}
@@ -1385,7 +1390,9 @@
     xf86OutputPtr	    output = b->DriverPrivate.ptr;
     I830OutputPrivatePtr    intel_output = output->driver_private;
     I2CBusPtr		    i2cbus = intel_output->pI2CBus;
+    struct i830_sdvo_priv   *dev_priv = intel_output->dev_priv;
 
+    i830_sdvo_set_control_bus_switch(output, dev_priv->ddc_bus);
     return i2cbus->I2CStart(i2cbus, timeout);
 }
 
@@ -1539,6 +1546,10 @@
     else
 	name_suffix = "-2";
 
+    /* clear up privates */
+    dev_priv->is_tv = FALSE;
+    intel_output->needs_tv_clock = FALSE;
+
     if (flag & (SDVO_OUTPUT_TMDS0 | SDVO_OUTPUT_TMDS1))
     {
 	if (flag & SDVO_OUTPUT_TMDS0)
@@ -1709,11 +1720,9 @@
     xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
     DisplayModePtr modes = NULL;
     xf86OutputPtr crt;
-    I830OutputPrivatePtr intel_output = output->driver_private;
+    I830OutputPrivatePtr intel_output;
     xf86MonPtr edid_mon = NULL;
-    struct i830_sdvo_priv *dev_priv = intel_output->dev_priv;
-
-    i830_sdvo_set_control_bus_switch(output, dev_priv->ddc_bus);
+    struct i830_sdvo_priv *dev_priv;
 
     modes = i830_ddc_get_modes(output);
     if (modes != NULL)
diff -ruN xf86-video-intel-1d19b024dba970e4b24daccb898101f77d5529ff/src/i830_tv.c xf86-video-intel-e2465249a90b9aefe6d7a96eb56a51fde54698a0/src/i830_tv.c
--- xf86-video-intel-1d19b024dba970e4b24daccb898101f77d5529ff/src/i830_tv.c	2009-03-11 00:15:54.000000000 +0000
+++ xf86-video-intel-e2465249a90b9aefe6d7a96eb56a51fde54698a0/src/i830_tv.c	2009-03-19 23:33:44.000000000 +0000
@@ -1079,7 +1079,7 @@
 	c = float_to_fix_2_6(con);
     } else {
 	/* 2.6 floating point */
-	con = 8.875 * ((float) contrast / 255);
+	con = 2.65625 * ((float) contrast / 255);
 	c = float_to_float_2_6(con);
     }
     val |= (c << TV_CONTRAST_SHIFT) & TV_CONTRAST_MASK;
@@ -1098,7 +1098,7 @@
 	sat = 3.0 * ((float) saturation / 255);
 	s = float_to_fix_2_6(sat);
     } else {
-	sat = 8.875 * ((float) saturation / 255);
+	sat = 2.65625 * ((float) saturation / 255);
 	s = float_to_float_2_6(sat);
     }
     val |= (s << TV_SATURATION_SHIFT) & TV_SATURATION_MASK;
@@ -1458,6 +1458,10 @@
     int			    dpms_mode;
     int			    type = dev_priv->type;
 
+    /* If TV connector type set by user, always return connected */
+    if (dev_priv->force_type)
+	return XF86OutputStatusConnected;
+
     mode = reported_modes[0];
     xf86SetModeCrtc (&mode, INTERLACE_HALVE_V);
     crtc = i830GetLoadDetectPipe (output, &mode, &dpms_mode);
@@ -1467,13 +1471,6 @@
         i830ReleaseLoadDetectPipe (output, dpms_mode);
     }
 
-    if (dev_priv->force_type) {
-	if (type == TV_TYPE_NONE)
-	    return XF86OutputStatusDisconnected;
-	else
-	    return XF86OutputStatusConnected;
-    }
-
     if (type != dev_priv->type)
     {
 	dev_priv->type = type;
diff -ruN xf86-video-intel-1d19b024dba970e4b24daccb898101f77d5529ff/src/i830_video.c xf86-video-intel-e2465249a90b9aefe6d7a96eb56a51fde54698a0/src/i830_video.c
--- xf86-video-intel-1d19b024dba970e4b24daccb898101f77d5529ff/src/i830_video.c	2009-03-11 00:15:54.000000000 +0000
+++ xf86-video-intel-e2465249a90b9aefe6d7a96eb56a51fde54698a0/src/i830_video.c	2009-03-19 23:33:44.000000000 +0000
@@ -1382,7 +1382,7 @@
 	dst_base = pPriv->buf->virtual;
     } else {
 	drm_intel_gem_bo_start_gtt_access(pPriv->buf, TRUE);
-	dst_base = pI830->FbBase + pPriv->buf->offset;
+	dst_base = pI830->FbBase;
     }
 
     if (pPriv->currentBuf == 0)
diff -ruN xf86-video-intel-1d19b024dba970e4b24daccb898101f77d5529ff/src/xvmc/Makefile.am xf86-video-intel-e2465249a90b9aefe6d7a96eb56a51fde54698a0/src/xvmc/Makefile.am
--- xf86-video-intel-1d19b024dba970e4b24daccb898101f77d5529ff/src/xvmc/Makefile.am	2009-03-11 00:15:54.000000000 +0000
+++ xf86-video-intel-e2465249a90b9aefe6d7a96eb56a51fde54698a0/src/xvmc/Makefile.am	2009-03-19 23:33:44.000000000 +0000
@@ -1,5 +1,6 @@
 if XVMC
 lib_LTLIBRARIES=libI810XvMC.la libIntelXvMC.la
+endif
 
 libI810XvMC_la_SOURCES = I810XvMC.c \
 			 I810XvMC.h
@@ -123,4 +124,3 @@
 clean-local:
 	-rm -f $(INTEL_G4B)
 endif
-endif
diff -ruN xf86-video-intel-1d19b024dba970e4b24daccb898101f77d5529ff/uxa/uxa-glyphs.c xf86-video-intel-e2465249a90b9aefe6d7a96eb56a51fde54698a0/uxa/uxa-glyphs.c
--- xf86-video-intel-1d19b024dba970e4b24daccb898101f77d5529ff/uxa/uxa-glyphs.c	2009-03-11 00:15:54.000000000 +0000
+++ xf86-video-intel-e2465249a90b9aefe6d7a96eb56a51fde54698a0/uxa/uxa-glyphs.c	2009-03-19 23:33:44.000000000 +0000
@@ -353,9 +353,7 @@
 #define CACHE_Y(pos) (cache->yOffset + ((pos) / cache->columns) * cache->glyphHeight)
 
 /* The most efficient thing to way to upload the glyph to the screen
- * is to use the UploadToScreen() driver hook; this allows us to
- * pipeline glyph uploads and to avoid creating offscreen pixmaps for
- * glyphs that we'll never use again.
+ * is to use CopyArea; uxa pixmaps are always offscreen.
  */
 static Bool
 uxa_glyph_cache_upload_glyph(ScreenPtr		    pScreen,
@@ -363,37 +361,23 @@
 			     int		    pos,
 			     GlyphPtr		    pGlyph)
 {
-    uxa_screen_t    *uxa_screen = uxa_get_screen(pScreen);
     PicturePtr	    pGlyphPicture = GlyphPicture(pGlyph)[pScreen->myNum];
     PixmapPtr	    pGlyphPixmap = (PixmapPtr)pGlyphPicture->pDrawable;
     PixmapPtr	    pCachePixmap = (PixmapPtr)cache->picture->pDrawable;
-    int		    cacheXoff, cacheYoff;
-
-    if (!uxa_screen->info->put_image || uxa_screen->swappedOut)
-	return FALSE;
-
-    /* If the glyph pixmap is already uploaded, no point in doing
-     * things this way */
-    if (uxa_pixmap_is_offscreen(pGlyphPixmap))
-	return FALSE;
+    GCPtr	    pGC;
 
     /* UploadToScreen only works if bpp match */
     if (pGlyphPixmap->drawable.bitsPerPixel != pCachePixmap->drawable.bitsPerPixel)
 	return FALSE;
 
-    pCachePixmap = uxa_get_offscreen_pixmap ((DrawablePtr)pCachePixmap, &cacheXoff, &cacheYoff);
-    if (!pCachePixmap)
-	return FALSE;
-
-    if (!uxa_screen->info->put_image(pCachePixmap,
-				     CACHE_X(pos) + cacheXoff,
-				     CACHE_Y(pos) + cacheYoff,
-				     pGlyph->info.width,
-				     pGlyph->info.height,
-				     (char *)pGlyphPixmap->devPrivate.ptr,
-				     pGlyphPixmap->devKind))
-	return FALSE;
-
+    pGC = GetScratchGC(pCachePixmap->drawable.depth, pScreen);
+    ValidateGC(&pCachePixmap->drawable, pGC);
+    (void) uxa_copy_area (&pGlyphPixmap->drawable,
+			  &pCachePixmap->drawable,
+			  pGC,
+			  0, 0, pGlyph->info.width, pGlyph->info.height,
+			  CACHE_X(pos), CACHE_Y(pos));
+    FreeScratchGC (pGC);
     return TRUE;
 }
 
