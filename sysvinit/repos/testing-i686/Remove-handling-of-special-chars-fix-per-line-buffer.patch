From 4d2b17f47073e0491f9dfa62797cc727d4530f22 Mon Sep 17 00:00:00 2001
From: Florian Pritz <bluewind@xinu.at>
Date: Tue, 22 May 2012 22:14:52 +0200
Subject: [PATCH] Remove handling of special chars; fix per line buffer
 problem

The linebuffer was only 256 chars so longer lines were truncated.

By removing the handling of special chars (for example: /n/r/t) and
simply writing everything we read as is to the logfile we fix this bug,
make the code much smaller and allow users to write userspace tools that
correctly handle rendering.

Signed-off-by: Florian Pritz <bluewind@xinu.at>
---
 bootlogd.c |  139 +++++++++---------------------------------------------------
 1 file changed, 19 insertions(+), 120 deletions(-)

diff --git a/bootlogd.c b/bootlogd.c
index 570d382..5df8fb9 100644
--- a/bootlogd.c
+++ b/bootlogd.c
@@ -58,21 +58,10 @@ char *Version = "@(#) bootlogd 2.86 03-Jun-2004 miquels@cistron.nl";
 
 #define LOGFILE	"/var/log/boot"
 
-char ringbuf[32768];
-char *endptr = ringbuf + sizeof(ringbuf);
-char *inptr  = ringbuf;
-char *outptr = ringbuf;
-
 int got_signal = 0;
-int didnl = 1;
 int createlogfile = 0;
 int syncalot = 0;
 
-struct line {
-	char buf[256];
-	int pos;
-} line;
-
 /*
  *	Console devices as listed on the kernel command line and
  *	the mapping to actual devices in /dev
@@ -345,83 +334,6 @@ int consolename(char *res, int rlen)
 	return -1;
 }
 
-
-/*
- *	Write data and make sure it's on disk.
- */
-void writelog(FILE *fp, unsigned char *ptr, int len)
-{
-	time_t		t;
-	char		*s;
-	char		tmp[8];
-	int		olen = len;
-	int		dosync = 0;
-	int		tlen;
-
-	while (len > 0) {
-		tmp[0] = 0;
-		if (didnl) {
-			time(&t);
-			s = ctime(&t);
-			fprintf(fp, "%.24s: ", s);
-			didnl = 0;
-		}
-		switch (*ptr) {
-			case 27: /* ESC */
-				strcpy(tmp, "^[");
-				break;
-			case '\r':
-				line.pos = 0;
-				break;
-			case 8: /* ^H */
-				if (line.pos > 0) line.pos--;
-				break;
-			case '\n':
-				didnl = 1;
-				dosync = 1;
-				break;
-			case '\t':
-				line.pos += (line.pos / 8 + 1) * 8;
-				if (line.pos >= (int)sizeof(line.buf))
-					line.pos = sizeof(line.buf) - 1;
-				break;
-			case  32 ... 127:
-			case 161 ... 255:
-				tmp[0] = *ptr;
-				tmp[1] = 0;
-				break;
-			default:
-				sprintf(tmp, "\\%03o", *ptr);
-				break;
-		}
-		ptr++;
-		len--;
-
-		tlen = strlen(tmp);
-		if (tlen && (line.pos + tlen < (int)sizeof(line.buf))) {
-			memcpy(line.buf + line.pos, tmp, tlen);
-			line.pos += tlen;
-		}
-		if (didnl) {
-			fprintf(fp, "%s\n", line.buf);
-			memset(&line, 0, sizeof(line));
-		}
-	}
-
-	if (dosync) {
-		fflush(fp);
-		if (syncalot) {
-			fdatasync(fileno(fp));
-		}
-	}
-
-	outptr += olen;
-	if (outptr >= endptr)
-		outptr = ringbuf;
-
-}
-
-
 /*
  *	Print usage message and exit.
  */
@@ -481,7 +393,6 @@ int main(int argc, char **argv)
 	int		ptm, pts;
 	int		realfd;
 	int		n, m, i;
-	int		todo;
 
 	fp = NULL;
 	logfile = LOGFILE;
@@ -615,13 +526,13 @@ int main(int argc, char **argv)
 			/*
 			 *	See how much space there is left, read.
 			 */
-			if ((n = read(ptm, inptr, endptr - inptr)) >= 0) {
+			if ((n = read(ptm, buf, sizeof(buf))) >= 0) {
 				/*
 				 *	Write data (in chunks if needed)
 				 *	to the real output device.
 				 */
 				m = n;
-				p = inptr;
+				p = buf;
 				while (m > 0) {
 					i = write(realfd, p, m);
 					if (i >= 0) {
@@ -641,43 +552,31 @@ int main(int argc, char **argv)
 				}
 
 				/*
-				 *	Increment buffer position. Handle
-				 *	wraps, and also drag output pointer
-				 *	along if we cross it.
+				 *	Perhaps we need to open the logfile.
 				 */
-				inptr += n;
-				if (inptr - n < outptr && inptr > outptr)
-					outptr = inptr;
-				if (inptr >= endptr)
-					inptr = ringbuf;
-				if (outptr >= endptr)
-					outptr = ringbuf;
-			}
-		}
+				if (fp == NULL && access(logfile, F_OK) == 0) {
+					if (rotate) {
+						snprintf(buf, sizeof(buf), "%s~", logfile);
+						rename(logfile, buf);
+					}
+					fp = fopen(logfile, "a");
+				}
+				if (fp == NULL && createlogfile)
+					fp = fopen(logfile, "a");
 
-		/*
-		 *	Perhaps we need to open the logfile.
-		 */
-		if (fp == NULL && access(logfile, F_OK) == 0) {
-			if (rotate) {
-				snprintf(buf, sizeof(buf), "%s~", logfile);
-				rename(logfile, buf);
+				if (fp) {
+					write(fileno(fp), buf, n);
+				}
+
+				if (syncalot) {
+					fdatasync(fileno(fp));
+				}
 			}
-			fp = fopen(logfile, "a");
 		}
-		if (fp == NULL && createlogfile)
-			fp = fopen(logfile, "a");
 
-		if (inptr >= outptr)
-			todo = inptr - outptr;
-		else
-			todo = endptr - outptr;
-		if (fp && todo)
-			writelog(fp, (unsigned char *)outptr, todo);
 	}
 
 	if (fp) {
-		if (!didnl) fputc('\n', fp);
 		fclose(fp);
 	}
 
-- 
1.7.10.2

