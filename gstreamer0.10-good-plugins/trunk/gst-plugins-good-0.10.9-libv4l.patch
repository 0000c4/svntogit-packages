Index: configure.ac
===================================================================
RCS file: /cvs/gstreamer/gst-plugins-good/configure.ac,v
retrieving revision 1.759
diff -u -p -u -p -r1.759 configure.ac
--- configure.ac	28 Jul 2008 20:17:46 -0000	1.759
+++ configure.ac	30 Jul 2008 10:23:39 -0000
@@ -550,6 +550,12 @@ return 0;
   fi
 ])
 
+if test x$HAVE_GST_V4L2 = xyes; then
+  PKG_CHECK_MODULES(LIBV4L2, libv4l2, [have_libv4l2=yes], [have_libv4l2=no])
+  AC_DEFINE([HAVE_LIBV4L2], test x$have_libv4l2 = xyes,
+	    [Whether libv4l2 is available for video buffer conversion])
+fi
+
 dnl Check for X11
 translit(dnm, m, l) AM_CONDITIONAL(USE_X, true)
 AG_GST_CHECK_FEATURE(X, [X libraries and plugins],
Index: sys/v4l2/Makefile.am
===================================================================
RCS file: /cvs/gstreamer/gst-plugins-good/sys/v4l2/Makefile.am,v
retrieving revision 1.18
diff -u -p -u -p -r1.18 Makefile.am
--- sys/v4l2/Makefile.am	1 Nov 2006 19:48:26 -0000	1.18
+++ sys/v4l2/Makefile.am	30 Jul 2008 10:23:40 -0000
@@ -22,15 +22,17 @@ libgstvideo4linux2_la_SOURCES = gstv4l2.
 libgstvideo4linux2_la_CFLAGS =   $(GST_PLUGINS_BASE_CFLAGS) \
 				 $(GST_BASE_CFLAGS) \
 				 $(GST_CFLAGS) \
-				 $(X_CFLAGS)
-			        
+				 $(X_CFLAGS) \
+				 $(LIBV4L2_CFLAGS)
+
 libgstvideo4linux2_la_LDFLAGS = $(GST_PLUGIN_LDFLAGS)
 
 libgstvideo4linux2_la_LIBADD =   $(GST_PLUGINS_BASE_LIBS) \
 				 $(GST_BASE_LIBS) \
 				 -lgstinterfaces-$(GST_MAJORMINOR) \
 				 $(GST_LIBS) \
-				 $(xv_libs)
+				 $(xv_libs) \
+				 $(LIBV4L2_LIBS)
 
 noinst_HEADERS = gstv4l2object.h v4l2_calls.h \
 		 gstv4l2src.h v4l2src_calls.h \
Index: sys/v4l2/gstv4l2src.c
===================================================================
RCS file: /cvs/gstreamer/gst-plugins-good/sys/v4l2/gstv4l2src.c,v
retrieving revision 1.96
diff -u -p -u -p -r1.96 gstv4l2src.c
--- sys/v4l2/gstv4l2src.c	17 Jul 2008 13:54:38 -0000	1.96
+++ sys/v4l2/gstv4l2src.c	30 Jul 2008 10:23:40 -0000
@@ -1162,7 +1162,7 @@ gst_v4l2src_get_read (GstV4l2Src * v4l2s
 
   do {
     amount =
-        read (v4l2src->v4l2object->video_fd, GST_BUFFER_DATA (*buf),
+        v4l2_read (v4l2src->v4l2object->video_fd, GST_BUFFER_DATA (*buf),
         buffersize);
     if (amount == buffersize) {
       break;
Index: sys/v4l2/v4l2_calls.c
===================================================================
RCS file: /cvs/gstreamer/gst-plugins-good/sys/v4l2/v4l2_calls.c,v
retrieving revision 1.46
diff -u -p -u -p -r1.46 v4l2_calls.c
--- sys/v4l2/v4l2_calls.c	26 Jun 2008 16:36:47 -0000	1.46
+++ sys/v4l2/v4l2_calls.c	30 Jul 2008 10:23:40 -0000
@@ -75,7 +75,7 @@ gst_v4l2_get_capabilities (GstV4l2Object
   if (!GST_V4L2_IS_OPEN (v4l2object))
     return FALSE;
 
-  if (ioctl (v4l2object->video_fd, VIDIOC_QUERYCAP, &v4l2object->vcap) < 0)
+  if (v4l2_ioctl (v4l2object->video_fd, VIDIOC_QUERYCAP, &v4l2object->vcap) < 0)
     goto cap_failed;
 
   GST_LOG_OBJECT (e, "driver:      '%s'", v4l2object->vcap.driver);
@@ -124,7 +124,7 @@ gst_v4l2_fill_lists (GstV4l2Object * v4l
     GstTunerChannel *channel;
 
     input.index = n;
-    if (ioctl (v4l2object->video_fd, VIDIOC_ENUMINPUT, &input) < 0) {
+    if (v4l2_ioctl (v4l2object->video_fd, VIDIOC_ENUMINPUT, &input) < 0) {
       if (errno == EINVAL)
         break;                  /* end of enumeration */
       else {
@@ -157,7 +157,7 @@ gst_v4l2_fill_lists (GstV4l2Object * v4l
       channel->flags |= GST_TUNER_CHANNEL_FREQUENCY;
 
       vtun.index = input.tuner;
-      if (ioctl (v4l2object->video_fd, VIDIOC_G_TUNER, &vtun) < 0) {
+      if (v4l2_ioctl (v4l2object->video_fd, VIDIOC_G_TUNER, &vtun) < 0) {
         GST_ELEMENT_ERROR (e, RESOURCE, SETTINGS,
             (_("Failed to get setting of tuner %d on device '%s'."),
                 input.tuner, v4l2object->videodev), GST_ERROR_SYSTEM);
@@ -197,7 +197,7 @@ gst_v4l2_fill_lists (GstV4l2Object * v4l
     standard.frameperiod.denominator = 0;
     standard.index = n;
 
-    if (ioctl (v4l2object->video_fd, VIDIOC_ENUMSTD, &standard) < 0) {
+    if (v4l2_ioctl (v4l2object->video_fd, VIDIOC_ENUMSTD, &standard) < 0) {
       if (errno == EINVAL || errno == ENOTTY)
         break;                  /* end of enumeration */
       else {
@@ -242,7 +242,7 @@ gst_v4l2_fill_lists (GstV4l2Object * v4l
     }
 
     control.id = n;
-    if (ioctl (v4l2object->video_fd, VIDIOC_QUERYCTRL, &control) < 0) {
+    if (v4l2_ioctl (v4l2object->video_fd, VIDIOC_QUERYCTRL, &control) < 0) {
       if (errno == EINVAL) {
         if (n < V4L2_CID_PRIVATE_BASE)
           /* continue so that we also check private controls */
@@ -323,7 +323,7 @@ gst_v4l2_fill_lists (GstV4l2Object * v4l
       menu.id = n;
       for (i = 0;; i++) {
         menu.index = i;
-        if (ioctl (v4l2object->video_fd, VIDIOC_QUERYMENU, &menu) < 0) {
+        if (v4l2_ioctl (v4l2object->video_fd, VIDIOC_QUERYMENU, &menu) < 0) {
           if (errno == EINVAL)
             break;              /* end of enumeration */
           else {
@@ -398,6 +398,7 @@ gboolean
 gst_v4l2_open (GstV4l2Object * v4l2object)
 {
   struct stat st;
+  int libv4l2_fd;
 
   GST_DEBUG_OBJECT (v4l2object->element, "Trying to open device %s",
       v4l2object->videodev);
@@ -423,6 +424,17 @@ gst_v4l2_open (GstV4l2Object * v4l2objec
   if (!GST_V4L2_IS_OPEN (v4l2object))
     goto not_open;
 
+  libv4l2_fd = v4l2_fd_open(v4l2object->video_fd,
+      V4L2_ENABLE_ENUM_FMT_EMULATION);
+  /* Note the v4l2_xxx functions are designed so that if they get passed an
+     unknown fd, the will behave exactly as their regular xxx counterparts, so
+     if v4l2_fd_open fails, we continue as normal (missing the libv4l2 custom
+     cam format to normal formats conversion). Chances are big we will still
+     fail then though, as normally v4l2_fd_open only fails if the device is not
+     a v4l2 device. */
+  if (libv4l2_fd != -1)
+    v4l2object->video_fd = libv4l2_fd;
+
   /* get capabilities, error will be posted */
   if (!gst_v4l2_get_capabilities (v4l2object))
     goto error;
@@ -476,7 +488,7 @@ error:
   {
     if (GST_V4L2_IS_OPEN (v4l2object)) {
       /* close device */
-      close (v4l2object->video_fd);
+      v4l2_close (v4l2object->video_fd);
       v4l2object->video_fd = -1;
     }
     /* empty lists */
@@ -502,7 +514,7 @@ gst_v4l2_close (GstV4l2Object * v4l2obje
   GST_V4L2_CHECK_NOT_ACTIVE (v4l2object);
 
   /* close device */
-  close (v4l2object->video_fd);
+  v4l2_close (v4l2object->video_fd);
   v4l2object->video_fd = -1;
 
   /* empty lists */
@@ -525,7 +537,7 @@ gst_v4l2_get_norm (GstV4l2Object * v4l2o
   if (!GST_V4L2_IS_OPEN (v4l2object))
     return FALSE;
 
-  if (ioctl (v4l2object->video_fd, VIDIOC_G_STD, norm) < 0)
+  if (v4l2_ioctl (v4l2object->video_fd, VIDIOC_G_STD, norm) < 0)
     goto std_failed;
 
   return TRUE;
@@ -553,7 +565,7 @@ gst_v4l2_set_norm (GstV4l2Object * v4l2o
   if (!GST_V4L2_IS_OPEN (v4l2object))
     return FALSE;
 
-  if (ioctl (v4l2object->video_fd, VIDIOC_S_STD, &norm) < 0)
+  if (v4l2_ioctl (v4l2object->video_fd, VIDIOC_S_STD, &norm) < 0)
     goto std_failed;
 
   return TRUE;
@@ -589,7 +601,7 @@ gst_v4l2_get_frequency (GstV4l2Object * 
   channel = gst_tuner_get_channel (GST_TUNER (v4l2object->element));
 
   freq.tuner = tunernum;
-  if (ioctl (v4l2object->video_fd, VIDIOC_G_FREQUENCY, &freq) < 0)
+  if (v4l2_ioctl (v4l2object->video_fd, VIDIOC_G_FREQUENCY, &freq) < 0)
     goto freq_failed;
 
   *frequency = freq.frequency * channel->freq_multiplicator;
@@ -630,10 +642,10 @@ gst_v4l2_set_frequency (GstV4l2Object * 
 
   freq.tuner = tunernum;
   /* fill in type - ignore error */
-  ioctl (v4l2object->video_fd, VIDIOC_G_FREQUENCY, &freq);
+  v4l2_ioctl (v4l2object->video_fd, VIDIOC_G_FREQUENCY, &freq);
   freq.frequency = frequency / channel->freq_multiplicator;
 
-  if (ioctl (v4l2object->video_fd, VIDIOC_S_FREQUENCY, &freq) < 0)
+  if (v4l2_ioctl (v4l2object->video_fd, VIDIOC_S_FREQUENCY, &freq) < 0)
     goto freq_failed;
 
   return TRUE;
@@ -665,7 +677,7 @@ gst_v4l2_signal_strength (GstV4l2Object 
     return FALSE;
 
   tuner.index = tunernum;
-  if (ioctl (v4l2object->video_fd, VIDIOC_G_TUNER, &tuner) < 0)
+  if (v4l2_ioctl (v4l2object->video_fd, VIDIOC_G_TUNER, &tuner) < 0)
     goto tuner_failed;
 
   *signal_strength = tuner.signal;
@@ -701,7 +713,7 @@ gst_v4l2_get_attribute (GstV4l2Object * 
 
   control.id = attribute_num;
 
-  if (ioctl (v4l2object->video_fd, VIDIOC_G_CTRL, &control) < 0)
+  if (v4l2_ioctl (v4l2object->video_fd, VIDIOC_G_CTRL, &control) < 0)
     goto ctrl_failed;
 
   *value = control.value;
@@ -738,7 +750,7 @@ gst_v4l2_set_attribute (GstV4l2Object * 
 
   control.id = attribute_num;
   control.value = value;
-  if (ioctl (v4l2object->video_fd, VIDIOC_S_CTRL, &control) < 0)
+  if (v4l2_ioctl (v4l2object->video_fd, VIDIOC_S_CTRL, &control) < 0)
     goto ctrl_failed;
 
   return TRUE;
@@ -763,7 +775,7 @@ gst_v4l2_get_input (GstV4l2Object * v4l2
   if (!GST_V4L2_IS_OPEN (v4l2object))
     return FALSE;
 
-  if (ioctl (v4l2object->video_fd, VIDIOC_G_INPUT, &n) < 0)
+  if (v4l2_ioctl (v4l2object->video_fd, VIDIOC_G_INPUT, &n) < 0)
     goto input_failed;
 
   *input = n;
@@ -789,7 +801,7 @@ gst_v4l2_set_input (GstV4l2Object * v4l2
   if (!GST_V4L2_IS_OPEN (v4l2object))
     return FALSE;
 
-  if (ioctl (v4l2object->video_fd, VIDIOC_S_INPUT, &input) < 0)
+  if (v4l2_ioctl (v4l2object->video_fd, VIDIOC_S_INPUT, &input) < 0)
     goto input_failed;
 
   return TRUE;
Index: sys/v4l2/v4l2_calls.h
===================================================================
RCS file: /cvs/gstreamer/gst-plugins-good/sys/v4l2/v4l2_calls.h,v
retrieving revision 1.18
diff -u -p -u -p -r1.18 v4l2_calls.h
--- sys/v4l2/v4l2_calls.h	26 Sep 2006 13:18:06 -0000	1.18
+++ sys/v4l2/v4l2_calls.h	30 Jul 2008 10:23:40 -0000
@@ -27,6 +27,17 @@
 #include "gstv4l2object.h"
 #include "gst/gst-i18n-plugin.h"
 
+#ifdef HAVE_LIBV4L2
+#include <libv4l2.h>
+#else
+#define v4l2_fd_open(fd, flags) (fd)
+#define v4l2_close close
+#define v4l2_dup dup
+#define v4l2_ioctl ioctl
+#define v4l2_read read
+#define v4l2_mmap mmap
+#define v4l2_munmap munmap
+#endif
 
 /* simple check whether the device is open */
 #define GST_V4L2_IS_OPEN(v4l2object) \
--- configure	2008-08-31 22:54:24.000000000 +0200
+++ configure	2008-08-31 22:57:45.000000000 +0200
@@ -1131,6 +1131,8 @@ USE_OSX_VIDEO_FALSE
 XVIDEO_LIBS
 USE_GST_V4L2_TRUE
 USE_GST_V4L2_FALSE
+LIBV4L2_CFLAGS
+LIBV4L2_LIBS
 XMKMF
 X_CFLAGS
 X_PRE_LIBS
@@ -1286,6 +1288,8 @@ GST_PLUGINS_BASE_CFLAGS
 GST_PLUGINS_BASE_LIBS
 GTK2_CFLAGS
 GTK2_LIBS
+LIBV4L2_CFLAGS
+LIBV4L2_LIBS
 XMKMF
 XFIXES_CFLAGS
 XFIXES_LIBS
@@ -2093,6 +2097,10 @@ Some influential environment variables:
               linker flags for GST_PLUGINS_BASE, overriding pkg-config
   GTK2_CFLAGS C compiler flags for GTK2, overriding pkg-config
   GTK2_LIBS   linker flags for GTK2, overriding pkg-config
+  LIBV4L2_CFLAGS
+              C compiler flags for LIBV4L2, overriding pkg-config
+  LIBV4L2_LIBS
+              linker flags for LIBV4L2, overriding pkg-config
   XMKMF       Path to xmkmf, Makefile generator for X Window System
   XFIXES_CFLAGS
               C compiler flags for XFIXES, overriding pkg-config
@@ -37088,6 +37096,71 @@ else
 fi
 
 
+if test x$HAVE_GST_V4L2 = xyes; then
+
+pkg_failed=no
+{ echo "$as_me:$LINENO: checking for LIBV4L2" >&5
+echo $ECHO_N "checking for LIBV4L2... " >&6; }
+
+if test -n "$PKG_CONFIG"; then
+    if test -n "$LIBV4L2_CFLAGS"; then
+        pkg_cv_LIBV4L2_CFLAGS="$LIBV4L2_CFLAGS"
+    else
+        if test -n "$PKG_CONFIG" && \
+    { (echo "$as_me:$LINENO: \$PKG_CONFIG --exists --print-errors \"libv4l2\"") >&5
+  ($PKG_CONFIG --exists --print-errors "libv4l2") 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; then
+  pkg_cv_LIBV4L2_CFLAGS=`$PKG_CONFIG --cflags "libv4l2" 2>/dev/null`
+else
+  pkg_failed=yes
+fi
+    fi
+else
+	pkg_failed=untried
+fi
+if test -n "$PKG_CONFIG"; then
+    if test -n "$LIBV4L2_LIBS"; then
+        pkg_cv_LIBV4L2_LIBS="$LIBV4L2_LIBS"
+    else
+        if test -n "$PKG_CONFIG" && \
+    { (echo "$as_me:$LINENO: \$PKG_CONFIG --exists --print-errors \"libv4l2\"") >&5
+  ($PKG_CONFIG --exists --print-errors "libv4l2") 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; then
+  pkg_cv_LIBV4L2_LIBS=`$PKG_CONFIG --libs "libv4l2" 2>/dev/null`
+else
+  pkg_failed=yes
+fi
+    fi
+else
+	pkg_failed=untried
+fi
+
+if test $pkg_failed = yes; then
+	LIBV4L2_PKG_ERRORS=`$PKG_CONFIG --errors-to-stdout --print-errors "libv4l2"`
+	# Put the nasty error message in config.log where it belongs
+	echo "$LIBV4L2_PKG_ERRORS" 1>&5
+
+	have_libv4l2=no
+elif test $pkg_failed = untried; then
+	have_libv4l2=no
+else
+	LIBV4L2_CFLAGS=$pkg_cv_LIBV4L2_CFLAGS
+	LIBV4L2_LIBS=$pkg_cv_LIBV4L2_LIBS
+        { echo "$as_me:$LINENO: result: yes" >&5
+echo "yes" >&6; }
+	have_libv4l2=yes
+fi
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_LIBV4L2 test x$have_libv4l2 = xyes
+_ACEOF
+
+fi
+
 
 { echo "$as_me:$LINENO: checking for X" >&5
 echo $ECHO_N "checking for X... $ECHO_C" >&6; }
diff -up gst-plugins-good-0.10.10/sys/v4l2/Makefile.in~ gst-plugins-good-0.10.10/sys/v4l2/Makefile.in
--- sys/v4l2/Makefile.in~	2008-10-05 12:02:41.000000000 +0200
+++ sys/v4l2/Makefile.in	2008-10-05 12:03:13.000000000 +0200
@@ -319,6 +319,8 @@ LIBOIL_CFLAGS = @LIBOIL_CFLAGS@
 LIBOIL_LIBS = @LIBOIL_LIBS@
 LIBPNG_CFLAGS = @LIBPNG_CFLAGS@
 LIBPNG_LIBS = @LIBPNG_LIBS@
+LIBV4L2_CFLAGS =
+LIBV4L2_LIBS = -lv4l2 -lv4lconvert
 LIBS = @LIBS@
 LIBTOOL = @LIBTOOL@
 LN_S = @LN_S@
@@ -615,14 +615,16 @@ libgstvideo4linux2_la_SOURCES = gstv4l2.
 libgstvideo4linux2_la_CFLAGS = $(GST_PLUGINS_BASE_CFLAGS) \
 				 $(GST_BASE_CFLAGS) \
 				 $(GST_CFLAGS) \
-				 $(X_CFLAGS)
+				 $(X_CFLAGS) \
+				 $(LIBV4L2_CFLAGS)
 
 libgstvideo4linux2_la_LDFLAGS = $(GST_PLUGIN_LDFLAGS)
 libgstvideo4linux2_la_LIBADD = $(GST_PLUGINS_BASE_LIBS) \
 				 $(GST_BASE_LIBS) \
 				 -lgstinterfaces-$(GST_MAJORMINOR) \
 				 $(GST_LIBS) \
-				 $(xv_libs)
+				 $(xv_libs) \
+				 $(LIBV4L2_LIBS)
 
 noinst_HEADERS = gstv4l2object.h v4l2_calls.h \
 		 gstv4l2src.h v4l2src_calls.h \
diff -up gst-plugins-good-0.10.10/config.h.in~ gst-plugins-good-0.10.10/config.h.in
--- config.h.in~	2008-10-05 12:29:29.000000000 +0200
+++ config.h.in	2008-10-05 12:29:29.000000000 +0200
@@ -173,6 +173,9 @@
 /* Define to enable Portable Network Graphics library (used by png). */
 #undef HAVE_LIBPNG
 
+/* Whether libv4l2 is available for video buffer conversion */
+#undef HAVE_LIBV4L2
+
 /* Define to 1 if you have the <memory.h> header file. */
 #undef HAVE_MEMORY_H
 
--- sys/v4l2/v4l2src_calls.c.libv4l	2008-10-11 00:13:37.000000000 +0100
+++ sys/v4l2/v4l2src_calls.c	2008-10-25 01:10:47.000000000 +0100
@@ -88,7 +88,7 @@ gst_v4l2_buffer_finalize (GstV4l2Buffer 
     pool->num_live_buffers--;
 
   if (pool->running) {
-    if (ioctl (pool->video_fd, VIDIOC_QBUF, &buffer->vbuffer) < 0) {
+    if (v4l2_ioctl (pool->video_fd, VIDIOC_QBUF, &buffer->vbuffer) < 0) {
       GST_WARNING ("could not requeue buffer %p %d", buffer, index);
     } else {
       /* FIXME: check that the caps didn't change */
@@ -106,7 +106,7 @@ gst_v4l2_buffer_finalize (GstV4l2Buffer 
   if (!resuscitated) {
     GST_LOG ("buffer %p not recovered, unmapping", buffer);
     gst_mini_object_unref (GST_MINI_OBJECT (pool));
-    munmap ((void *) GST_BUFFER_DATA (buffer), buffer->vbuffer.length);
+    v4l2_munmap ((void *) GST_BUFFER_DATA (buffer), buffer->vbuffer.length);
 
     GST_MINI_OBJECT_CLASS (v4l2buffer_parent_class)->finalize (GST_MINI_OBJECT
         (buffer));
@@ -165,7 +165,7 @@ gst_v4l2_buffer_new (GstV4l2BufferPool *
   ret->vbuffer.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
   ret->vbuffer.memory = V4L2_MEMORY_MMAP;
 
-  if (ioctl (pool->video_fd, VIDIOC_QUERYBUF, &ret->vbuffer) < 0)
+  if (v4l2_ioctl (pool->video_fd, VIDIOC_QUERYBUF, &ret->vbuffer) < 0)
     goto querybuf_failed;
 
   GST_LOG ("  index:     %u", ret->vbuffer.index);
@@ -179,7 +179,7 @@ gst_v4l2_buffer_new (GstV4l2BufferPool *
   GST_LOG ("  length:    %u", ret->vbuffer.length);
   GST_LOG ("  input:     %u", ret->vbuffer.input);
 
-  data = (guint8 *) mmap (0, ret->vbuffer.length,
+  data = (guint8 *) v4l2_mmap (0, ret->vbuffer.length,
       PROT_READ | PROT_WRITE, MAP_SHARED, pool->video_fd,
       ret->vbuffer.m.offset);
 
@@ -229,7 +229,7 @@ gst_v4l2_buffer_pool_finalize (GstV4l2Bu
   pool->lock = NULL;
 
   if (pool->video_fd >= 0)
-    close (pool->video_fd);
+    v4l2_close (pool->video_fd);
 
   if (pool->buffers) {
     g_free (pool->buffers);
@@ -292,7 +292,7 @@ gst_v4l2_buffer_pool_new (GstV4l2Src * v
 
   pool = (GstV4l2BufferPool *) gst_mini_object_new (GST_TYPE_V4L2_BUFFER_POOL);
 
-  pool->video_fd = dup (fd);
+  pool->video_fd = v4l2_dup (fd);
   if (pool->video_fd < 0)
     goto dup_failed;
 
@@ -344,7 +344,7 @@ gst_v4l2_buffer_pool_activate (GstV4l2Bu
 
     GST_LOG ("enqueue pool buffer %d", n);
 
-    if (ioctl (pool->video_fd, VIDIOC_QBUF, buf) < 0)
+    if (v4l2_ioctl (pool->video_fd, VIDIOC_QBUF, buf) < 0)
       goto queue_failed;
   }
   pool->running = TRUE;
@@ -519,7 +519,7 @@ gst_v4l2src_fill_format_list (GstV4l2Src
     format->index = n;
     format->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
 
-    if (ioctl (v4l2src->v4l2object->video_fd, VIDIOC_ENUM_FMT, format) < 0) {
+    if (v4l2_ioctl (v4l2src->v4l2object->video_fd, VIDIOC_ENUM_FMT, format) < 0) {
       if (errno == EINVAL) {
         g_free (format);
         break;                  /* end of enumeration */
@@ -595,7 +595,7 @@ gst_v4l2src_probe_caps_for_format_and_si
 
   /* keep in mind that v4l2 gives us frame intervals (durations); we invert the
    * fraction to get framerate */
-  if (ioctl (fd, VIDIOC_ENUM_FRAMEINTERVALS, &ival) < 0)
+  if (v4l2_ioctl (fd, VIDIOC_ENUM_FRAMEINTERVALS, &ival) < 0)
     goto enum_frameintervals_failed;
 
   if (ival.type == V4L2_FRMIVAL_TYPE_DISCRETE) {
@@ -621,7 +621,7 @@ gst_v4l2src_probe_caps_for_format_and_si
       gst_value_list_append_value (&rates, &rate);
 
       ival.index++;
-    } while (ioctl (fd, VIDIOC_ENUM_FRAMEINTERVALS, &ival) >= 0);
+    } while (v4l2_ioctl (fd, VIDIOC_ENUM_FRAMEINTERVALS, &ival) >= 0);
   } else if (ival.type == V4L2_FRMIVAL_TYPE_STEPWISE) {
     GValue min = { 0, };
     GValue step = { 0, };
@@ -782,7 +782,7 @@ gst_v4l2src_probe_caps_for_format (GstV4
 
   GST_DEBUG_OBJECT (v4l2src, "Enumerating frame sizes");
 
-  if (ioctl (fd, VIDIOC_ENUM_FRAMESIZES, &size) < 0)
+  if (v4l2_ioctl (fd, VIDIOC_ENUM_FRAMESIZES, &size) < 0)
     goto enum_framesizes_failed;
 
   if (size.type == V4L2_FRMSIZE_TYPE_DISCRETE) {
@@ -802,7 +802,7 @@ gst_v4l2src_probe_caps_for_format (GstV4
         results = g_list_prepend (results, tmp);
 
       size.index++;
-    } while (ioctl (fd, VIDIOC_ENUM_FRAMESIZES, &size) >= 0);
+    } while (v4l2_ioctl (fd, VIDIOC_ENUM_FRAMESIZES, &size) >= 0);
     GST_DEBUG_OBJECT (v4l2src, "done iterating discrete frame sizes");
   } else if (size.type == V4L2_FRMSIZE_TYPE_STEPWISE) {
     GST_DEBUG_OBJECT (v4l2src, "we have stepwise frame sizes:");
@@ -972,7 +972,7 @@ gst_v4l2src_grab_frame (GstV4l2Src * v4l
   buffer.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
   buffer.memory = V4L2_MEMORY_MMAP;
 
-  while (ioctl (v4l2src->v4l2object->video_fd, VIDIOC_DQBUF, &buffer) < 0) {
+  while (v4l2_ioctl (v4l2src->v4l2object->video_fd, VIDIOC_DQBUF, &buffer) < 0) {
 
     GST_WARNING_OBJECT (v4l2src,
         "problem grabbing frame %d (ix=%d), trials=%d, pool-ct=%d, buf.flags=%d",
@@ -1190,7 +1190,7 @@ gst_v4l2src_set_capture (GstV4l2Src * v4
   memset (&format, 0x00, sizeof (struct v4l2_format));
   format.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
 
-  if (ioctl (fd, VIDIOC_G_FMT, &format) < 0)
+  if (v4l2_ioctl (fd, VIDIOC_G_FMT, &format) < 0)
     goto get_fmt_failed;
 
   format.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
@@ -1202,7 +1202,7 @@ gst_v4l2src_set_capture (GstV4l2Src * v4
    *  combined, there are other modes for requesting fields individually) */
   format.fmt.pix.field = V4L2_FIELD_INTERLACED;
 
-  if (ioctl (fd, VIDIOC_S_FMT, &format) < 0) {
+  if (v4l2_ioctl (fd, VIDIOC_S_FMT, &format) < 0) {
     if (errno != EINVAL)
       goto set_fmt_failed;
 
@@ -1211,7 +1211,7 @@ gst_v4l2src_set_capture (GstV4l2Src * v4
     format.fmt.pix.height = height;
     format.fmt.pix.pixelformat = pixelformat;
     format.fmt.pix.field = V4L2_FIELD_NONE;
-    if (ioctl (fd, VIDIOC_S_FMT, &format) < 0)
+    if (v4l2_ioctl (fd, VIDIOC_S_FMT, &format) < 0)
       goto set_fmt_failed;
   }
 
@@ -1226,7 +1226,7 @@ gst_v4l2src_set_capture (GstV4l2Src * v4
 
   memset (&stream, 0x00, sizeof (struct v4l2_streamparm));
   stream.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-  if (ioctl (fd, VIDIOC_G_PARM, &stream) < 0) {
+  if (v4l2_ioctl (fd, VIDIOC_G_PARM, &stream) < 0) {
     GST_ELEMENT_WARNING (v4l2src, RESOURCE, SETTINGS,
         (_("Could not get parameters on device '%s'"),
             v4l2src->v4l2object->videodev), GST_ERROR_SYSTEM);
@@ -1256,7 +1256,7 @@ gst_v4l2src_set_capture (GstV4l2Src * v4
   stream.parm.capture.timeperframe.denominator = fps_n;
 
   /* some cheap USB cam's won't accept any change */
-  if (ioctl (fd, VIDIOC_S_PARM, &stream) < 0) {
+  if (v4l2_ioctl (fd, VIDIOC_S_PARM, &stream) < 0) {
     GST_ELEMENT_WARNING (v4l2src, RESOURCE, SETTINGS,
         (_("Video input device did not accept new frame rate setting.")),
         GST_ERROR_SYSTEM);
@@ -1338,7 +1338,7 @@ gst_v4l2src_capture_init (GstV4l2Src * v
     breq.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
     breq.memory = V4L2_MEMORY_MMAP;
 
-    if (ioctl (fd, VIDIOC_REQBUFS, &breq) < 0)
+    if (v4l2_ioctl (fd, VIDIOC_REQBUFS, &breq) < 0)
       goto reqbufs_failed;
 
     GST_LOG_OBJECT (v4l2src, " count:  %u", breq.count);
@@ -1433,7 +1433,7 @@ gst_v4l2src_capture_start (GstV4l2Src * 
     if (!gst_v4l2_buffer_pool_activate (v4l2src->pool, v4l2src))
       goto pool_activate_failed;
 
-    if (ioctl (fd, VIDIOC_STREAMON, &type) < 0)
+    if (v4l2_ioctl (fd, VIDIOC_STREAMON, &type) < 0)
       goto streamon_failed;
   }
 
@@ -1478,7 +1478,7 @@ gst_v4l2src_capture_stop (GstV4l2Src * v
   if (v4l2src->use_mmap) {
     /* we actually need to sync on all queued buffers but not
      * on the non-queued ones */
-    if (ioctl (v4l2src->v4l2object->video_fd, VIDIOC_STREAMOFF, &type) < 0)
+    if (v4l2_ioctl (v4l2src->v4l2object->video_fd, VIDIOC_STREAMOFF, &type) < 0)
       goto streamoff_failed;
   }
 
@@ -1554,14 +1554,14 @@ gst_v4l2src_get_nearest_size (GstV4l2Src
   fmt.fmt.pix.pixelformat = pixelformat;
   fmt.fmt.pix.field = V4L2_FIELD_INTERLACED;
 
-  r = ioctl (fd, VIDIOC_TRY_FMT, &fmt);
+  r = v4l2_ioctl (fd, VIDIOC_TRY_FMT, &fmt);
   if (r < 0 && errno == EINVAL) {
     /* try again with progressive video */
     fmt.fmt.pix.width = *width;
     fmt.fmt.pix.height = *height;
     fmt.fmt.pix.pixelformat = pixelformat;
     fmt.fmt.pix.field = V4L2_FIELD_NONE;
-    r = ioctl (fd, VIDIOC_TRY_FMT, &fmt);
+    r = v4l2_ioctl (fd, VIDIOC_TRY_FMT, &fmt);
   }
 
   if (r < 0) {
@@ -1581,14 +1581,14 @@ gst_v4l2src_get_nearest_size (GstV4l2Src
     fmt.fmt.pix.width = *width;
     fmt.fmt.pix.height = *height;
 
-    r = ioctl (fd, VIDIOC_S_FMT, &fmt);
+    r = v4l2_ioctl (fd, VIDIOC_S_FMT, &fmt);
     if (r < 0 && errno == EINVAL) {
       /* try again with progressive video */
       fmt.fmt.pix.width = *width;
       fmt.fmt.pix.height = *height;
       fmt.fmt.pix.pixelformat = pixelformat;
       fmt.fmt.pix.field = V4L2_FIELD_NONE;
-      r = ioctl (fd, VIDIOC_S_FMT, &fmt);
+      r = v4l2_ioctl (fd, VIDIOC_S_FMT, &fmt);
     }
 
     if (r < 0)
