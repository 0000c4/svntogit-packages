--- hylafax-6.0.5/configure	2010-09-15 10:42:36.000000000 -0400
+++ hylafax-5.5.1/configure	2012-01-02 17:44:20.000000000 -0500
@@ -2531,6 +2566,7 @@
     Note "... checking TIFF library version"
     tiff_runlen_t=""
     cat>t.c<<EOF
+#include <stdlib.h>
 #include <stdio.h>
 #include "tiffio.h"
 main()
@@ -2550,8 +2586,18 @@
 	Note "  Found libtiff version ${lib_ver}"
 	if [ ${header_ver} -ge 19960307 ]; then
 	    case ${lib_ver} in
-		3.4)		tiff_runlen_t="uint16" ;;
-		3.[56789])	tiff_runlen_t="uint32" ;;
+		3.4)		tiff_runlen_t="uint16"
+				echo '#define TIFFSTRIPBYTECOUNTS uint32'
+				echo '#define TIFFVERSION TIFF_VERSION'
+				echo '#define TIFFHEADER TIFFHeader';;
+		3.[56789])	tiff_runlen_t="uint32"
+				echo '#define TIFFSTRIPBYTECOUNTS uint32'
+				echo '#define TIFFVERSION TIFF_VERSION'
+				echo '#define TIFFHEADER TIFFHeader';;
+		4.0)		tiff_runlen_t="uint32"
+				echo '#define TIFFSTRIPBYTECOUNTS uint64'
+				echo '#define TIFFVERSION TIFF_VERSION_CLASSIC'
+				echo '#define TIFFHEADER TIFFHeaderClassic';;
 	    esac
 	fi
     else
@@ -2588,7 +2634,7 @@
 Incompatible TIFF Library.
 
 HylaFAX ${VERSION} requires TIFF software distribution versions 3.4 through
-3.9.  If you do not have up to date TIFF software on your system
+4.0.  If you do not have up to date TIFF software on your system
 then you can retrieve it from the location where you obtained this software.
 The Home Page for version 3.5 and later is http://www.remotesensing.org/libtiff/
 EOF
--- hylafax-6.0.5/hfaxd/FileTransfer.c++	2010-09-15 10:42:36.000000000 -0400
+++ hylafax-5.5.1/hfaxd/FileTransfer.c++	2012-01-02 17:44:19.000000000 -0500
@@ -164,26 +142,26 @@
  * a single IFD/image from a TIFF file.
  */
 typedef struct {
-    TIFFDirEntry	SubFileType;
-    TIFFDirEntry	ImageWidth;
-    TIFFDirEntry	ImageLength;
-    TIFFDirEntry	BitsPerSample;
-    TIFFDirEntry	Compression;
-    TIFFDirEntry	Photometric;
-    TIFFDirEntry	FillOrder;
-    TIFFDirEntry	StripOffsets;
-    TIFFDirEntry	Orientation;
-    TIFFDirEntry	SamplesPerPixel;
-    TIFFDirEntry	RowsPerStrip;
-    TIFFDirEntry	StripByteCounts;
-    TIFFDirEntry	XResolution;
-    TIFFDirEntry	YResolution;
-    TIFFDirEntry	Options;		// T4 or T6
-    TIFFDirEntry	ResolutionUnit;
-    TIFFDirEntry	PageNumber;
-    TIFFDirEntry	BadFaxLines;
-    TIFFDirEntry	CleanFaxData;
-    TIFFDirEntry	ConsecutiveBadFaxLines;
+    HFClassicTIFFDirEntry	SubFileType;
+    HFClassicTIFFDirEntry	ImageWidth;
+    HFClassicTIFFDirEntry	ImageLength;
+    HFClassicTIFFDirEntry	BitsPerSample;
+    HFClassicTIFFDirEntry	Compression;
+    HFClassicTIFFDirEntry	Photometric;
+    HFClassicTIFFDirEntry	FillOrder;
+    HFClassicTIFFDirEntry	StripOffsets;
+    HFClassicTIFFDirEntry	Orientation;
+    HFClassicTIFFDirEntry	SamplesPerPixel;
+    HFClassicTIFFDirEntry	RowsPerStrip;
+    HFClassicTIFFDirEntry	StripByteCounts;
+    HFClassicTIFFDirEntry	XResolution;
+    HFClassicTIFFDirEntry	YResolution;
+    HFClassicTIFFDirEntry	Options;		// T4 or T6
+    HFClassicTIFFDirEntry	ResolutionUnit;
+    HFClassicTIFFDirEntry	PageNumber;
+    HFClassicTIFFDirEntry	BadFaxLines;
+    HFClassicTIFFDirEntry	CleanFaxData;
+    HFClassicTIFFDirEntry	ConsecutiveBadFaxLines;
     uint32		link;			// offset to next directory
     uint32		xres[2];		// X resolution indirect value
     uint32		yres[2];		// Y resolution indirect value
@@ -226,10 +204,10 @@
 		 * amount of image data and then adding in
 		 * the expected data for the TIFF headers.
 		 */
-		uint32* sb;
+		TIFFSTRIPBYTECOUNTS* sb;
 		TIFFGetField(tif, TIFFTAG_STRIPBYTECOUNTS, &sb);
 		file_size = sizeof (DirTemplate) +
-		    sizeof (TIFFHeader) + sizeof (uint16);
+		    sizeof (TIFFHEADER) + sizeof (uint16);
 		for (tstrip_t s = 0, ns = TIFFNumberOfStrips(tif); s < ns; s++)
 		    file_size += sb[s];
 		reply(code, "%s for %s (%lu bytes).",
@@ -261,10 +239,10 @@
 	if (fd >= 0) {
 	    union {
 		char buf[512];
-		TIFFHeader h;
+		TIFFHEADER h;
 	    } b;
 	    ssize_t cc = Sys::read(fd, (char*) &b, sizeof (b));
-	    if (cc > (ssize_t)sizeof (b.h) && b.h.tiff_version == TIFF_VERSION &&
+	    if (cc > (ssize_t)sizeof (b.h) && b.h.tiff_version == TIFFVERSION &&
 	      (b.h.tiff_magic == TIFF_BIGENDIAN ||
 	       b.h.tiff_magic == TIFF_LITTLEENDIAN)) {
 		(void) lseek(fd, 0L, SEEK_SET);		// rewind
@@ -318,12 +296,12 @@
 }
 
 static void
-getLong(TIFF* tif, TIFFDirEntry& de)
+getLong(TIFF* tif, HFClassicTIFFDirEntry& de)
 {
     TIFFGetField(tif, de.tdir_tag, &de.tdir_offset);
 }
 static void
-getShort(TIFF* tif, TIFFDirEntry& de)
+getShort(TIFF* tif, HFClassicTIFFDirEntry& de)
 {
     uint16 v;
     TIFFGetField(tif, de.tdir_tag, &v);
@@ -343,7 +321,7 @@
 {
     static DirTemplate templ = {
 #define	TIFFdiroff(v) \
-    (uint32) (sizeof (TIFFHeader) + sizeof (uint16) + \
+    (uint32) (sizeof (TIFFHEADER) + sizeof (uint16) + \
       (intptr_t) &(((DirTemplate*) 0)->v))
 	{ TIFFTAG_SUBFILETYPE,		TIFF_LONG,	1 },
 	{ TIFFTAG_IMAGEWIDTH,		TIFF_LONG,	1 },
@@ -368,7 +346,7 @@
 	0,					// next directory
 	{ 0, 1 }, { 0, 1 },			// x+y resolutions
     };
-#define	NTAGS	((TIFFdiroff(link)-TIFFdiroff(SubFileType)) / sizeof (TIFFDirEntry))
+#define	NTAGS	((TIFFdiroff(link)-TIFFdiroff(SubFileType)) / sizeof (HFClassicTIFFDirEntry))
     /*
      * Construct the TIFF header for this IFD using
      * the preconstructed template above.  We extract
@@ -377,14 +355,14 @@
      * of things about the contents of the TIFF file.
      */
     struct {
-	TIFFHeader h;
+	TIFFHEADER h;
 	uint16	dircount;
 	u_char	dirstuff[sizeof (templ)];
     } buf;
     union { int32 i; char c[4]; } u; u.i = 1;
     buf.h.tiff_magic = (u.c[0] == 0 ? TIFF_BIGENDIAN : TIFF_LITTLEENDIAN);
-    buf.h.tiff_version = TIFF_VERSION;
-    buf.h.tiff_diroff = sizeof (TIFFHeader);
+    buf.h.tiff_version = TIFFVERSION;
+    buf.h.tiff_diroff = sizeof (TIFFHEADER);
     buf.dircount = (uint16) NTAGS;
     getLong(tif, templ.SubFileType);
     getLong(tif, templ.ImageWidth);
@@ -412,7 +390,7 @@
     getShort(tif, templ.CleanFaxData);
     getLong(tif, templ.ConsecutiveBadFaxLines);
     if (buf.h.tiff_magic == TIFF_BIGENDIAN) {
-	TIFFDirEntry* dp = &templ.SubFileType;
+	HFClassicTIFFDirEntry* dp = &templ.SubFileType;
 	for (u_int i = 0; i < NTAGS; i++) {
 	    if (dp->tdir_type == TIFF_SHORT)
 		dp->tdir_offset <<= 16;
@@ -441,7 +419,7 @@
 bool
 HylaFAXServer::sendITIFFData(TIFF* tif, int fdout)
 {
-    uint32* sb;
+    TIFFSTRIPBYTECOUNTS* sb;
     (void) TIFFGetField(tif, TIFFTAG_STRIPBYTECOUNTS, &sb);
     tdata_t buf = _TIFFmalloc(sb[0]);
     tsize_t bsize = sb[0];
--- hylafax-6.0.5/hfaxd/FileTransfer.c++	2012-01-28 15:27:47.000000000 -0500
+++ hylafax-5.5.1/hfaxd/FileTransfer.c++	2012-01-28 15:30:12.000000000 -0500
@@ -69,7 +69,7 @@
 
 
 static bool
-isTIFF(const TIFFHeader& h)
+isTIFF(const TIFFHEADER& h)
 {
     if (h.tiff_magic != TIFF_BIGENDIAN && h.tiff_magic != TIFF_LITTLEENDIAN)
 	return (false);
@@ -82,11 +82,23 @@
     // byte swap version stamp if opposite byte order
     if ((u.c[0] == 0) ^ (h.tiff_magic == TIFF_BIGENDIAN))
 	TIFFSwabShort(&version);
-    return (version == TIFF_VERSION);
+    return (version == TIFFVERSION);
 }
 
 
 /*
+ * This is copied right from tiff.h in version 3.8.2.  This was necessary
+ * to localize here because it was removed from tiff.h in version 4.0.
+ * In tiff.h 3.8.2 it was known as "TIFFDirEntry".
+ */
+typedef struct {
+	uint16		tdir_tag;
+	uint16		tdir_type;	/* data type */
+	uint32		tdir_count;	/* number of items; length in spec */
+	uint32		tdir_offset;	/* byte offset to field data */
+} HFClassicTIFFDirEntry;
+ 
+/*
  * Record a file transfer in the log file.
  */
 void
@@ -957,7 +957,7 @@
 	if (FileCache::lookup(docname, sb) && S_ISREG(sb.st_mode)) {
 	    union {
 		char buf[512];
-		TIFFHeader h;
+		TIFFHEADER h;
 	    } b;
 	    ssize_t cc = Sys::read(fd, (char*) &b, sizeof (b));
 	    if (cc > 2 && b.buf[0] == '%' && b.buf[1] == '!')
