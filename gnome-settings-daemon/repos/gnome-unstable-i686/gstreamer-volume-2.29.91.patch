diff -Nur gnome-settings-daemon-2.29.91.1.orig/configure.ac gnome-settings-daemon-2.29.91.1/configure.ac
--- gnome-settings-daemon-2.29.91.1.orig/configure.ac	2010-02-24 16:39:10.000000000 +0200
+++ gnome-settings-daemon-2.29.91.1/configure.ac	2010-02-25 17:40:02.000000000 +0200
@@ -248,6 +248,48 @@
 AC_SUBST(PULSE_CFLAGS)
 AC_SUBST(PULSE_LIBS)
 
+dnl ==============================================
+dnl GStreamer section
+dnl ==============================================
+GST_MAJORMINOR=auto
+
+AC_ARG_ENABLE(gstreamer,
+AC_HELP_STRING([--enable-gstreamer],[use gstreamer if available (and optionally specify a version)]),
+[case "${enableval}" in
+ yes) ENABLE_GSTREAMER=yes ;;
+ 0.10) ENABLE_GSTREAMER=yes && GST_MAJORMINOR=0.10 ;;
+ no)  ENABLE_GSTREAMER=no ;;
+ *) AC_MSG_ERROR([
+                  *** Bad value ${enableval} for --enable-gstreamer
+                  *** Please use one of the following:
+                  ***    --enable-gstreamer=0.10
+               ]) ;;
+esac],
+[ENABLE_GSTREAMER=yes]) dnl Default value
+
+have_gstreamer=no
+if test "x$ENABLE_GSTREAMER" = "xyes"; then
+   GST_REQS=0.10.1.2
+   PKGS="gstreamer-0.10 >= $GST_REQS gstreamer-plugins-base-0.10 >= $GST_REQS"
+
+   PKG_CHECK_MODULES(GST, $PKGS, have_gstreamer=yes,
+                     AC_MSG_RESULT([no]))
+
+   if test "x$have_pulse" = "xtrue"; then
+      AC_MSG_ERROR([*** GStreamer & Pulseaudio both are selected ***])
+   fi
+
+   if test "x$have_gstreamer" = "xyes"; then
+      GST_LIBS="$GST_LIBS -lgstinterfaces-0.10 -lgstaudio-0.10"
+      AC_DEFINE(HAVE_GSTREAMER,1,[enable gstreamer])
+   fi
+else
+   AC_MSG_NOTICE([*** GStreamer support disabled ***])
+fi
+AM_CONDITIONAL(HAVE_GSTREAMER, test "x$have_gstreamer" = "xyes")
+AC_SUBST(GST_LIBS)
+AC_SUBST(GST_CFLAGS)
+
 # ---------------------------------------------------------------------------
 # Enable Profiling
 # ---------------------------------------------------------------------------
@@ -386,6 +428,7 @@
         dbus-1 system.d dir:      ${DBUS_SYS_DIR}
 
         Libnotify support:        ${have_libnotify}
+        GStreamer support:        ${have_gstreamer}
         PulseAudio support:       ${have_pulse}
         Profiling support:        ${enable_profiling}
 "
diff -Nur gnome-settings-daemon-2.29.91.1.orig/configure.ac.orig gnome-settings-daemon-2.29.91.1/configure.ac.orig
--- gnome-settings-daemon-2.29.91.1.orig/configure.ac.orig	1970-01-01 02:00:00.000000000 +0200
+++ gnome-settings-daemon-2.29.91.1/configure.ac.orig	2010-02-24 16:39:10.000000000 +0200
@@ -0,0 +1,391 @@
+AC_PREREQ([2.60])
+
+m4_define([gsd_api_version_major],[2])
+m4_define([gsd_api_version_minor],[0])
+m4_define([gsd_api_version],[gsd_api_version_major.gsd_api_version_minor])
+
+AC_INIT([gnome-settings-daemon],
+        [2.29.91.1],
+        [http://bugzilla.gnome.org/enter_bug.cgi?product=gnome-settings-daemon])
+
+AC_CONFIG_SRCDIR([gnome-settings-daemon/gnome-settings-manager.c])
+
+AM_INIT_AUTOMAKE([1.9 no-dist-gzip dist-bzip2 tar-ustar])
+
+AC_STDC_HEADERS
+AC_PROG_CXX
+AM_PROG_CC_C_O
+AC_PROG_LIBTOOL
+
+AC_HEADER_STDC
+
+AC_SUBST(VERSION)
+
+AC_CONFIG_HEADERS([config.h])
+
+IT_PROG_INTLTOOL([0.37.1])
+
+GETTEXT_PACKAGE=gnome-settings-daemon
+AC_SUBST(GETTEXT_PACKAGE)
+AC_DEFINE_UNQUOTED(GETTEXT_PACKAGE, "$GETTEXT_PACKAGE", [Name of default gettext domain])
+
+AM_GLIB_GNU_GETTEXT
+
+AS_AC_EXPAND(LIBEXECDIR, "$libexecdir")
+
+GSD_INTLTOOL_PLUGIN_RULE='%.gnome-settings-plugin:   %.gnome-settings-plugin.in   $(INTLTOOL_MERGE) $(wildcard $(top_srcdir)/po/*.po) ; LC_ALL=C $(INTLTOOL_MERGE) -d -u -c $(top_builddir)/po/.intltool-merge-cache $(top_srcdir)/po $< [$]@'
+AC_SUBST([GSD_INTLTOOL_PLUGIN_RULE])
+
+ dnl Unconditionally use this dir to avoid a circular dep with gnomecc
+GNOME_KEYBINDINGS_KEYSDIR="${datadir}/gnome-control-center/keybindings"
+AC_SUBST(GNOME_KEYBINDINGS_KEYSDIR)
+
+dnl ---------------------------------------------------------------------------
+dnl - Dependencies
+dnl ---------------------------------------------------------------------------
+
+DBUS_GLIB_REQUIRED_VERSION=0.74
+GLIB_REQUIRED_VERSION=2.17.3
+GTK_REQUIRED_VERSION=2.16.0
+GCONF_REQUIRED_VERSION=2.6.1
+GIO_REQUIRED_VERSION=2.17.3
+GNOME_DESKTOP_REQUIRED_VERSION=2.26.3
+LIBNOTIFY_REQUIRED_VERSION=0.4.3
+
+EXTRA_COMPILE_WARNINGS(yes)
+
+PKG_CHECK_MODULES(SETTINGS_DAEMON,
+        glib-2.0 >= $GLIB_REQUIRED_VERSION
+        gtk+-2.0 >= $GTK_REQUIRED_VERSION
+        gconf-2.0 >= $GCONF_REQUIRED_VERSION
+        gmodule-2.0
+        gthread-2.0
+        dbus-glib-1 >= $DBUS_GLIB_REQUIRED_VERSION
+)
+
+PKG_CHECK_MODULES(SETTINGS_PLUGIN,
+        gtk+-2.0 >= $GTK_REQUIRED_VERSION
+        gconf-2.0 >= $GCONF_REQUIRED_VERSION
+        gnome-desktop-2.0 >= $GNOME_DESKTOP_REQUIRED_VERSION
+        gio-2.0 >= $GIO_REQUIRED_VERSION
+        dbus-glib-1 >= $DBUS_GLIB_REQUIRED_VERSION
+)
+
+GSD_PLUGIN_LDFLAGS="-export_dynamic -module -avoid-version -no-undefined"
+case $host_os in
+  darwin*)
+    GSD_PLUGIN_LDFLAGS="${GSD_PLUGIN_LDFLAGS} -Wl,-bundle_loader,\$(top_builddir)/gnome-settings-daemon/gnome-settings-daemon"
+    ;;
+esac
+AC_SUBST([GSD_PLUGIN_LDFLAGS])
+
+AC_PATH_PROG(GLIB_GENMARSHAL, glib-genmarshal)
+
+AC_PATH_PROG(GCONFTOOL, gconftool-2)
+
+AM_GCONF_SOURCE_2
+
+dnl ---------------------------------------------------------------------------
+dnl - Check for libnotify
+dnl ---------------------------------------------------------------------------
+
+have_libnotify=no
+AC_ARG_WITH(libnotify,
+	AC_HELP_STRING([--without-libnotify], [Disable notifications (default: auto)]),
+	with_libnotify=$withval, with_libnotify=auto)
+
+if test "x$with_libnotify" != "xno"; then
+	PKG_CHECK_MODULES(LIBNOTIFY, libnotify >= $LIBNOTIFY_REQUIRED_VERSION,
+			  [AC_DEFINE(HAVE_LIBNOTIFY, 1, [Define if libnotify is available])
+			  have_libnotify=yes], have_libnotify=no)
+	if test "x$have_libnotify" = xno -a "x$with_libnotify" = xyes; then
+		AC_MSG_ERROR([libnotify support requested but libraries not found])
+	fi
+fi
+AC_SUBST(LIBNOTIFY_CFLAGS)
+AC_SUBST(LIBNOTIFY_LIBS)
+
+dnl ---------------------------------------------------------------------------
+dnl - Check for D-Bus
+dnl ---------------------------------------------------------------------------
+
+dnl - Are we specifying a different dbus root ?
+AC_ARG_WITH(dbus-sys,
+        [AC_HELP_STRING([--with-dbus-sys=<dir>],
+        [where D-BUS system.d directory is])])
+AC_ARG_WITH(dbus-services,
+        [AC_HELP_STRING([--with-dbus-services=<dir>],
+        [where D-BUS services directory is])])
+if ! test -z "$with_dbus_sys" ; then
+        DBUS_SYS_DIR="$with_dbus_sys"
+else
+        DBUS_SYS_DIR='${sysconfdir}/dbus-1/system.d'
+fi
+AC_SUBST(DBUS_SYS_DIR)
+
+dnl ---------------------------------------------------------------------------
+dnl - X11 stuff
+dnl ---------------------------------------------------------------------------
+
+# Like AC_CHECK_HEADERS, but it uses the already-computed -I directories.
+#
+AC_DEFUN([AC_CHECK_X_HEADERS], [
+  ac_save_CPPFLAGS="$CPPFLAGS"
+  if test \! -z "$includedir" ; then
+    CPPFLAGS="$CPPFLAGS -I$includedir"
+  fi
+  CPPFLAGS="$CPPFLAGS $X_CFLAGS"
+  AC_CHECK_HEADERS([$1],[$2],[$3],[$4])
+  CPPFLAGS="$ac_save_CPPFLAGS"])
+
+# Like AC_CHECK_LIB, but it uses the already-computed -I and -L directories.
+# Use this sparingly; it probably doesn't work very well on X programs.
+#
+AC_DEFUN([AC_CHECK_X_LIB], [
+  ac_save_CPPFLAGS="$CPPFLAGS"
+  ac_save_LDFLAGS="$LDFLAGS"
+#  ac_save_LIBS="$LIBS"
+
+  if test \! -z "$includedir" ; then
+    CPPFLAGS="$CPPFLAGS -I$includedir"
+  fi
+  # note: $X_CFLAGS includes $x_includes
+  CPPFLAGS="$CPPFLAGS $X_CFLAGS"
+
+  if test \! -z "$libdir" ; then
+    LDFLAGS="$LDFLAGS -L$libdir"
+  fi
+  # note: $X_LIBS includes $x_libraries
+  LDFLAGS="$LDFLAGS $ALL_X_LIBS"
+
+  AC_CHECK_LIB([$1], [$2], [$3], [$4], [$5])
+  CPPFLAGS="$ac_save_CPPFLAGS"
+  LDFLAGS="$ac_save_LDFLAGS"
+#  LIBS="$ac_save_LIBS"
+  ])
+
+AC_PATH_XTRA
+
+ALL_X_LIBS="$X_LIBS $X_PRE_LIBS -lXext -lX11 $X_EXTRA_LIBS"
+
+dnl ---------------------------------------------------------------------------
+dnl - XInput
+dnl ---------------------------------------------------------------------------
+
+have_xinput=no
+AC_CHECK_X_LIB(Xi, XListInputDevices,
+  [AC_CHECK_X_HEADERS(X11/extensions/XInput.h,
+    [AC_CHECK_TYPES([XDevicePresenceNotifyEvent], [
+       have_xinput=yes
+       XINPUT_LIBS="-lXi"],
+       [], [#include <X11/extensions/XInput.h>])],
+     [], [[#include <X11/Xlib.h>>]])],
+  [], [-lXi $x_libs])
+
+AM_CONDITIONAL(HAVE_XINPUT, [test $have_xinput = yes])
+AC_SUBST(XINPUT_LIBS)
+
+dnl ---------------------------------------------------------------------------
+dnl - Fontconfig
+dnl ---------------------------------------------------------------------------
+
+have_fontconfig=no
+PKG_CHECK_MODULES(FONTCONFIG, fontconfig,
+		  [AC_DEFINE(HAVE_FONTCONFIG, 1, [Define if Fontconfig functionality is available])
+		   have_fontconfig=yes],
+		  [have_fontconfig=no])
+AM_CONDITIONAL(HAVE_FONTCONFIG, test x"$have_fontconfig" = "xyes")
+
+dnl ---------------------------------------------------------------------------
+dnl - Keyboard plugin stuff
+dnl ---------------------------------------------------------------------------
+
+AC_CHECK_X_LIB(Xxf86misc, XF86MiscQueryExtension, [
+  AC_CHECK_X_HEADERS([X11/extensions/xf86misc.h],
+      [XF86MISC_LIBS="-lXxf86misc"], :,
+      [#include <X11/Xlib.h>])], : ,
+      -lXxf86misc $x_libs)
+AC_SUBST(XF86MISC_LIBS)
+AC_CHECK_X_HEADERS([X11/extensions/XKB.h])
+
+PKG_CHECK_MODULES(LIBGNOMEKBDUI, [libgnomekbdui >= 2.29.5 libgnomekbd >= 2.29.5 libxklavier >= 5.0])
+AC_SUBST(LIBGNOMEKBDUI_CFLAGS)
+AC_SUBST(LIBGNOMEKBDUI_LIBS)
+
+dnl ---------------------------------------------------------------------------
+dnl - Housekeeping plugin stuff
+dnl ---------------------------------------------------------------------------
+
+PKG_CHECK_MODULES(GIOUNIX, [gio-unix-2.0])
+AC_SUBST(GIOUNIX_CFLAGS)
+AC_SUBST(GIOUNIX_LIBS)
+
+dnl ==============================================
+dnl PulseAudio section
+dnl ==============================================
+
+
+have_pulse=false
+AC_ARG_ENABLE(pulse,
+  AC_HELP_STRING([--disable-pulse],
+                 [turn off PulseAudio support]),
+       [case "${enableval}" in
+               yes) WANT_PULSE=yes ;;
+               no)  WANT_PULSE=no ;;
+               *) AC_MSG_ERROR(bad value ${enableval} for --disable-pulse) ;;
+       esac],
+       [WANT_PULSE=yes]) dnl Default value
+
+if test x$WANT_PULSE = xyes ; then
+       PA_REQUIRED_VERSION=0.9.15
+       PKG_CHECK_MODULES(PULSE, glib-2.0 libpulse >= $PA_REQUIRED_VERSION libpulse-mainloop-glib >= $PA_REQUIRED_VERSION libcanberra-gtk,
+             [have_pulse=true
+              AC_DEFINE(HAVE_PULSE, 1, [Define if PULSE sound server should be used])],
+             [have_pulse=false])
+fi
+AM_CONDITIONAL(HAVE_PULSE, test "x$have_pulse" = "xtrue")
+
+AC_SUBST(PULSE_CFLAGS)
+AC_SUBST(PULSE_LIBS)
+
+# ---------------------------------------------------------------------------
+# Enable Profiling
+# ---------------------------------------------------------------------------
+AC_ARG_ENABLE(profiling,
+	[AC_HELP_STRING([--enable-profiling],
+	[turn on profiling])],
+	, enable_profiling=no)
+if test "x$enable_profiling" = "xyes"; then
+    AC_DEFINE(ENABLE_PROFILING,1,[enable profiling])
+fi
+
+
+# ---------------------------------------------------------------------------
+# Plugins
+# ---------------------------------------------------------------------------
+
+plugindir='$(libdir)/gnome-settings-daemon-gsd_api_version'
+AC_SUBST([plugindir])
+
+dnl ---------------------------------------------------------------------------
+dnl - Finish
+dnl ---------------------------------------------------------------------------
+
+
+# Turn on the additional warnings last, so warnings don't affect other tests.
+
+AC_ARG_ENABLE(more-warnings,
+	[AC_HELP_STRING([--enable-more-warnings],
+	[Maximum compiler warnings])],
+	set_more_warnings="$enableval",[
+        	if test -d $srcdir/.git; then
+        		set_more_warnings=yes
+              	else
+                  	set_more_warnings=no
+              	fi
+        ])
+AC_MSG_CHECKING(for more warnings)
+if test "$GCC" = "yes" -a "$set_more_warnings" != "no"; then
+        AC_MSG_RESULT(yes)
+        CFLAGS="\
+        -Wall \
+        -Wchar-subscripts -Wmissing-declarations -Wmissing-prototypes \
+        -Wnested-externs -Wpointer-arith \
+        -Wcast-align -Wsign-compare \
+        $CFLAGS"
+
+        for option in -Wno-strict-aliasing -Wno-sign-compare; do
+                SAVE_CFLAGS="$CFLAGS"
+                CFLAGS="$CFLAGS $option"
+                AC_MSG_CHECKING([whether gcc understands $option])
+                AC_TRY_COMPILE([], [],
+                        has_option=yes,
+                        has_option=no,)
+                if test $has_option = no; then
+                        CFLAGS="$SAVE_CFLAGS"
+                fi
+                AC_MSG_RESULT($has_option)
+                unset has_option
+                unset SAVE_CFLAGS
+        done
+        unset option
+else
+        AC_MSG_RESULT(no)
+fi
+
+#
+# Enable Debug
+#
+AC_ARG_ENABLE(debug,
+	[AC_HELP_STRING([--enable-debug],
+	[turn on debugging])],
+	, enable_debug=yes)
+if test "$enable_debug" = "yes"; then
+	DEBUG_CFLAGS="-DG_ENABLE_DEBUG"
+else
+	if test "x$enable_debug" = "xno"; then
+		DEBUG_CFLAGS="-DG_DISABLE_ASSERT -DG_DISABLE_CHECKS"
+  	else
+    		DEBUG_CFLAGS=""
+  	fi
+fi
+AC_SUBST(DEBUG_CFLAGS)
+
+AC_OUTPUT([
+Makefile
+gnome-settings-daemon/Makefile
+plugins/Makefile
+plugins/a11y-keyboard/Makefile
+plugins/background/Makefile
+plugins/clipboard/Makefile
+plugins/common/Makefile
+plugins/dummy/Makefile
+plugins/font/Makefile
+plugins/housekeeping/Makefile
+plugins/keybindings/Makefile
+plugins/keyboard/Makefile
+plugins/media-keys/Makefile
+plugins/media-keys/cut-n-paste/Makefile
+plugins/mouse/Makefile
+plugins/sound/Makefile
+plugins/typing-break/Makefile
+plugins/xrandr/Makefile
+plugins/xrdb/Makefile
+plugins/xrdb/data/Makefile
+plugins/xsettings/Makefile
+data/Makefile
+data/gnome-settings-daemon.desktop.in
+data/gnome-settings-daemon.pc
+data/gnome-settings-daemon-uninstalled.pc
+po/Makefile.in
+])
+
+dnl ---------------------------------------------------------------------------
+dnl - Show summary
+dnl ---------------------------------------------------------------------------
+
+echo "
+                    gnome-settings-daemon $VERSION
+                    =============================
+
+	prefix:                   ${prefix}
+	exec_prefix:              ${exec_prefix}
+        libdir:                   ${libdir}
+        bindir:                   ${bindir}
+        sbindir:                  ${sbindir}
+        sysconfdir:               ${sysconfdir}
+        sysconfsubdir:            ${sysconfsubdir}
+        localstatedir:            ${localstatedir}
+        plugindir:                ${plugindir}
+        datadir:                  ${datadir}
+	source code location:	  ${srcdir}
+	compiler:		  ${CC}
+	cflags:		          ${CFLAGS}
+        Maintainer mode:          ${USE_MAINTAINER_MODE}
+
+        dbus-1 system.d dir:      ${DBUS_SYS_DIR}
+
+        Libnotify support:        ${have_libnotify}
+        PulseAudio support:       ${have_pulse}
+        Profiling support:        ${enable_profiling}
+"
diff -Nur gnome-settings-daemon-2.29.91.1.orig/plugins/media-keys/cut-n-paste/gvc-gstreamer-acme-vol.c gnome-settings-daemon-2.29.91.1/plugins/media-keys/cut-n-paste/gvc-gstreamer-acme-vol.c
--- gnome-settings-daemon-2.29.91.1.orig/plugins/media-keys/cut-n-paste/gvc-gstreamer-acme-vol.c	1970-01-01 02:00:00.000000000 +0200
+++ gnome-settings-daemon-2.29.91.1/plugins/media-keys/cut-n-paste/gvc-gstreamer-acme-vol.c	2010-02-25 17:40:02.000000000 +0200
@@ -0,0 +1,402 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+
+/* acme-volume.c
+
+   Copyright (C) 2002, 2003 Bastien Nocera
+   Copyright (C) 2004 Novell, Inc.
+   Copyright (C) 2009 PERIER Romain <mrpouet@tuxfamily.org>
+
+   The Gnome Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The Gnome Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the Gnome Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+
+   Author: Bastien Nocera <hadess@hadess.net>
+           Jon Trowbridge <trow@ximian.com>
+*/
+
+#include "config.h"
+#include "gvc-gstreamer-acme-vol.h"
+
+#include <gst/gst.h>
+#include <gst/audio/mixerutils.h>
+#include <gst/interfaces/mixer.h>
+#include <gst/interfaces/propertyprobe.h>
+
+#include <gconf/gconf-client.h>
+
+#include <string.h>
+
+#define TIMEOUT	4
+
+#define DEFAULT_MIXER_DEVICE_KEY   "/desktop/gnome/sound/default_mixer_device"
+#define DEFAULT_MIXER_TRACKS_KEY   "/desktop/gnome/sound/default_mixer_tracks"
+
+#define ACME_VOLUME_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), ACME_TYPE_VOLUME, AcmeVolumePrivate))
+
+struct AcmeVolumePrivate {
+	GstMixer     *mixer;
+	GList        *mixer_tracks;
+	guint         timer_id;
+	gdouble       volume;
+	gboolean      mute;
+	GConfClient  *gconf_client;
+};
+
+G_DEFINE_TYPE (AcmeVolume, acme_volume, G_TYPE_OBJECT)
+
+static gboolean acme_volume_open  (AcmeVolume *acme);
+static void     acme_volume_close (AcmeVolume *acme);
+static gboolean acme_volume_close_real (AcmeVolume *self);
+
+static gpointer acme_volume_object = NULL;
+
+static void
+acme_volume_finalize (GObject *object)
+{
+	AcmeVolume *self;
+
+	g_return_if_fail (object != NULL);
+	g_return_if_fail (ACME_IS_VOLUME (object));
+
+	self = ACME_VOLUME (object);
+
+	if (self->_priv->timer_id != 0)
+		g_source_remove (self->_priv->timer_id);
+	acme_volume_close_real (self);
+
+	if (self->_priv->gconf_client != NULL) {
+		g_object_unref (self->_priv->gconf_client);
+		self->_priv->gconf_client = NULL;
+	}
+
+	G_OBJECT_CLASS (acme_volume_parent_class)->finalize (object);
+}
+
+void
+acme_volume_set_mute (AcmeVolume *self, gboolean val)
+{
+	GList *t;
+
+	g_return_if_fail(ACME_IS_VOLUME(self));
+	g_return_if_fail(acme_volume_open(self));
+
+	for (t = self->_priv->mixer_tracks; t != NULL; t = t->next) {
+		GstMixerTrack *track = GST_MIXER_TRACK (t->data);
+		gst_mixer_set_mute (self->_priv->mixer, track, val);
+	}
+	self->_priv->mute = val;
+	acme_volume_close (self);
+}
+
+static void
+update_state (AcmeVolume * self)
+{
+	gint *volumes, n;
+	gdouble vol = 0;
+	GstMixerTrack *track = GST_MIXER_TRACK (self->_priv->mixer_tracks->data);
+
+	/* update mixer by getting volume */
+	volumes = g_new0 (gint, track->num_channels);
+	gst_mixer_get_volume (self->_priv->mixer, track, volumes);
+	for (n = 0; n < track->num_channels; n++)
+		vol += volumes[n];
+	g_free (volumes);
+	vol /= track->num_channels;
+	vol = 100 * vol / (track->max_volume - track->min_volume);
+
+	/* update mute flag, and volume if not muted */
+	if (GST_MIXER_TRACK_HAS_FLAG (track, GST_MIXER_TRACK_MUTE))
+		self->_priv->mute = TRUE;
+	self->_priv->volume = vol;
+}
+
+gboolean
+acme_volume_get_mute (AcmeVolume *self)
+{
+	g_return_val_if_fail(acme_volume_open(self), FALSE);
+
+	update_state (self);
+	acme_volume_close (self);
+
+	return self->_priv->mute;
+}
+
+gint
+acme_volume_get_volume (AcmeVolume *self)
+{
+
+	g_return_val_if_fail(acme_volume_open(self), 0);
+
+	update_state (self);
+
+	acme_volume_close (self);
+	
+	return (gint) (self->_priv->volume + 0.5);
+}
+
+void
+acme_volume_set_volume (AcmeVolume *self, gint val)
+{
+	GList *t;
+
+	g_return_if_fail(acme_volume_open(self));
+
+	val = CLAMP (val, 0, 100);
+
+	for (t = self->_priv->mixer_tracks; t != NULL; t = t->next) {
+		GstMixerTrack *track = GST_MIXER_TRACK (t->data);
+		gint *volumes, n;
+		gdouble scale = (track->max_volume - track->min_volume) / 100.0;
+		gint vol = (gint) (val * scale + track->min_volume + 0.5);
+
+		volumes = g_new (gint, track->num_channels);
+		for (n = 0; n < track->num_channels; n++)
+			volumes[n] = vol;
+		gst_mixer_set_volume (self->_priv->mixer, track, volumes);
+		g_free (volumes);
+	}
+
+	/* update state */
+	self->_priv->volume = val;
+
+	acme_volume_close (self);
+}
+
+void
+acme_volume_mute_toggle (AcmeVolume *self)
+{
+	gboolean muted;
+
+	g_return_if_fail (self != NULL);
+	g_return_if_fail (ACME_IS_VOLUME(self));
+
+	muted = acme_volume_get_mute(self);
+	acme_volume_set_mute(self, !muted);
+}
+
+gint
+acme_volume_get_threshold (AcmeVolume *self)
+{
+	GList *t;
+	gint steps = 101;
+
+	g_return_val_if_fail(acme_volume_open(self), 1);
+
+	for (t = self->_priv->mixer_tracks; t != NULL; t = t->next) {
+		GstMixerTrack *track = GST_MIXER_TRACK (t->data);
+		gint track_steps = track->max_volume - track->min_volume;
+		if (track_steps > 0 && track_steps < steps)
+			steps = track_steps;
+	}
+
+	acme_volume_close (self);
+
+	return 100 / steps + 1;
+}
+
+static gboolean
+acme_volume_close_real (AcmeVolume *self)
+{
+	if (self->_priv->mixer != NULL)
+	{
+		gst_element_set_state (GST_ELEMENT (self->_priv->mixer), GST_STATE_NULL);
+		gst_object_unref (GST_OBJECT (self->_priv->mixer));
+		g_list_foreach (self->_priv->mixer_tracks, (GFunc) g_object_unref, NULL);
+		g_list_free (self->_priv->mixer_tracks);
+		self->_priv->mixer = NULL;
+		self->_priv->mixer_tracks = NULL;
+	}
+
+	self->_priv->timer_id = 0;
+	return FALSE;
+}
+
+/*
+ * _acme_set_mixer
+ * @mixer  A pointer to mixer element
+ * @data   A pointer to user data (AcmeVolume instance to be modified)
+ * @return A gboolean indicating success if Master track was found, failed otherwises.
+ */
+static gboolean
+_acme_set_mixer(GstMixer *mixer, gpointer user_data)
+{
+	const GList *tracks;
+
+	for (tracks = gst_mixer_list_tracks (mixer); tracks != NULL; tracks = tracks->next) {
+		GstMixerTrack *track = GST_MIXER_TRACK (tracks->data);
+
+		if (GST_MIXER_TRACK_HAS_FLAG (track, GST_MIXER_TRACK_MASTER)) {
+			AcmeVolume *self;
+
+			self = ACME_VOLUME (user_data);
+
+			self->_priv->mixer = mixer;
+			self->_priv->mixer_tracks = g_list_append (self->_priv->mixer_tracks, g_object_ref (track));
+			return TRUE;
+		}
+
+		continue;
+	}
+
+	return FALSE;
+}
+
+/* This is a modified version of code from gnome-media's gst-mixer */
+static gboolean
+acme_volume_open (AcmeVolume *self)
+{
+	gchar *mixer_device, **factory_and_device = NULL;
+	GList *mixer_list;
+
+	if (self->_priv->timer_id != 0) {
+		g_source_remove (self->_priv->timer_id);
+		self->_priv->timer_id = 0;
+		return TRUE;
+	}
+
+	mixer_device = gconf_client_get_string (self->_priv->gconf_client, DEFAULT_MIXER_DEVICE_KEY, NULL);
+	if (mixer_device != NULL)
+		factory_and_device = g_strsplit (mixer_device, ":", 2);
+
+	if (factory_and_device != NULL && factory_and_device[0] != NULL) {
+		GstElement *element;
+
+		element = gst_element_factory_make (factory_and_device[0], NULL);
+
+		if (element != NULL) {
+			if (factory_and_device[1] != NULL &&
+			    g_object_class_find_property (G_OBJECT_GET_CLASS (element), "device"))
+				g_object_set (G_OBJECT (element), "device", factory_and_device[1], NULL);
+			gst_element_set_state (element, GST_STATE_READY);
+
+			if (GST_IS_MIXER (element))
+				self->_priv->mixer = GST_MIXER (element);
+			else {
+				gst_element_set_state (element, GST_STATE_NULL);
+				gst_object_unref (element);
+			}
+		}
+	}
+
+	g_free (mixer_device);
+	g_strfreev (factory_and_device);
+
+	if (self->_priv->mixer != NULL) {
+		const GList *m;
+		GSList *tracks, *t;
+		GError *error = NULL;
+
+		/* Try to use tracks saved in GConf 
+		   Note: errors need to be treated , for example if the user set a non type list for this key
+		   or if the elements type_list are not "matched" */
+		tracks = gconf_client_get_list (self->_priv->gconf_client, DEFAULT_MIXER_TRACKS_KEY, 
+						GCONF_VALUE_STRING, &error);
+
+		if (error) {
+			g_warning("ERROR: %s\n", error->message);
+			g_error_free(error);
+		}
+
+		/* We use these tracks ONLY if they are supported on the system with the following mixer */
+		for (m = gst_mixer_list_tracks (self->_priv->mixer); m != NULL; m = m->next) {
+			GstMixerTrack *track = GST_MIXER_TRACK (m->data);
+
+			for (t = tracks; t != NULL; t = t->next)
+				if (!strcmp (t->data, track->label))
+					self->_priv->mixer_tracks = g_list_append (self->_priv->mixer_tracks, g_object_ref (track));
+
+		}
+
+		g_slist_foreach (tracks, (GFunc)g_free, NULL);
+		g_slist_free (tracks);
+
+		/* If no track stored in GConf is avaiable try to use Master track */
+		if (self->_priv->mixer_tracks == NULL) {
+			for (m = gst_mixer_list_tracks (self->_priv->mixer); m != NULL; m = m->next) {
+				GstMixerTrack *track = GST_MIXER_TRACK (m->data);
+
+				if (GST_MIXER_TRACK_HAS_FLAG (track, GST_MIXER_TRACK_MASTER)) {
+					self->_priv->mixer_tracks = g_list_append (self->_priv->mixer_tracks, g_object_ref (track));
+					break;
+				}
+			}
+		}
+
+		if (self->_priv->mixer_tracks != NULL)
+			return TRUE;
+		else {
+			gst_element_set_state (GST_ELEMENT (self->_priv->mixer), GST_STATE_NULL);
+			gst_object_unref (self->_priv->mixer);
+		}
+	}
+
+	/* Go through all elements of a certain class and check whether
+	 * they implement a mixer. If so, walk through the tracks and look
+	 * for first one named "volume".
+	 *
+	 * We should probably do something intelligent if we don't find an
+	 * appropriate mixer/track.  But now we do something stupid...
+	 * everything just becomes a no-op.
+	 */
+	mixer_list = gst_audio_default_registry_mixer_filter (_acme_set_mixer,
+			TRUE,
+			self);
+
+	if (mixer_list == NULL)
+		return FALSE;
+
+	/* do not unref the mixer as we keep the ref for self->priv->mixer */
+	g_list_free (mixer_list);
+
+	return TRUE;
+}
+
+static void
+acme_volume_close (AcmeVolume *self)
+{
+	self->_priv->timer_id = g_timeout_add_seconds (TIMEOUT,
+			(GSourceFunc) acme_volume_close_real, self);
+}
+
+static void
+acme_volume_init (AcmeVolume *self)
+{
+	self->_priv = ACME_VOLUME_GET_PRIVATE (self);
+	self->_priv->gconf_client = gconf_client_get_default ();
+}
+
+static void
+acme_volume_class_init (AcmeVolumeClass *klass)
+{
+	G_OBJECT_CLASS (klass)->finalize = acme_volume_finalize;
+
+	gst_init (NULL, NULL);
+
+	g_type_class_add_private (klass, sizeof (AcmeVolumePrivate));
+}
+
+/* acme_volume_new
+ * @return A singleton instance of type AcmeVolume
+ */
+AcmeVolume *
+acme_volume_new (void)
+{
+	if (acme_volume_object == NULL) {
+		acme_volume_object = g_object_new (ACME_TYPE_VOLUME, NULL);
+		return ACME_VOLUME(acme_volume_object);
+	}
+	g_object_ref(acme_volume_object);
+	return ACME_VOLUME(acme_volume_object);
+}
+
diff -Nur gnome-settings-daemon-2.29.91.1.orig/plugins/media-keys/cut-n-paste/gvc-gstreamer-acme-vol.h gnome-settings-daemon-2.29.91.1/plugins/media-keys/cut-n-paste/gvc-gstreamer-acme-vol.h
--- gnome-settings-daemon-2.29.91.1.orig/plugins/media-keys/cut-n-paste/gvc-gstreamer-acme-vol.h	1970-01-01 02:00:00.000000000 +0200
+++ gnome-settings-daemon-2.29.91.1/plugins/media-keys/cut-n-paste/gvc-gstreamer-acme-vol.h	2010-02-25 17:40:02.000000000 +0200
@@ -0,0 +1,56 @@
+/* acme-volume.h
+
+   Copyright (C) 2002, 2003 Bastien Nocera
+   Copyright (C) 2004 Novell, Inc.
+   Copyright (C) 2009 PERIER Romain <mrpouet@tuxfamily.org>
+
+   The Gnome Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The Gnome Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the Gnome Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+
+   Author: Bastien Nocera <hadess@hadess.net>
+           Jon Trowbridge <trow@ximian.com>
+ */
+
+#include <glib-object.h>
+
+#define ACME_TYPE_VOLUME                        (acme_volume_get_type ())
+#define ACME_VOLUME(obj)		        (G_TYPE_CHECK_INSTANCE_CAST ((obj), ACME_TYPE_VOLUME, AcmeVolume))
+#define ACME_VOLUME_CLASS(klass)	        (G_TYPE_CHECK_CLASS_CAST ((klass),  ACME_TYPE_VOLUME, AcmeVolumeClass))
+#define ACME_IS_VOLUME(obj)	                (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ACME_TYPE_VOLUME))
+#define ACME_VOLUME_GET_CLASS(obj)	        (G_TYPE_INSTANCE_GET_CLASS ((obj), ACME_TYPE_VOLUME, AcmeVolumeClass))
+
+typedef struct AcmeVolume AcmeVolume;
+typedef struct AcmeVolumeClass AcmeVolumeClass;
+typedef struct AcmeVolumePrivate AcmeVolumePrivate;
+
+struct AcmeVolume {
+	GObject parent;
+	AcmeVolumePrivate *_priv;
+};
+
+struct AcmeVolumeClass {
+	GObjectClass parent;
+};
+
+GType       acme_volume_get_type      (void);
+AcmeVolume *acme_volume_new           (void);
+void        acme_volume_set_mute      (AcmeVolume *self, gboolean val);
+void        acme_volume_mute_toggle   (AcmeVolume *self);
+gboolean    acme_volume_get_mute      (AcmeVolume *self);
+void        acme_volume_set_volume    (AcmeVolume *self, gint val);
+gint        acme_volume_get_volume    (AcmeVolume *self);
+gint        acme_volume_get_threshold (AcmeVolume *self);
+
+
diff -Nur gnome-settings-daemon-2.29.91.1.orig/plugins/media-keys/cut-n-paste/Makefile.am gnome-settings-daemon-2.29.91.1/plugins/media-keys/cut-n-paste/Makefile.am
--- gnome-settings-daemon-2.29.91.1.orig/plugins/media-keys/cut-n-paste/Makefile.am	2009-08-19 19:16:15.000000000 +0300
+++ gnome-settings-daemon-2.29.91.1/plugins/media-keys/cut-n-paste/Makefile.am	2010-02-25 17:40:02.000000000 +0200
@@ -4,16 +4,24 @@
 
 INCLUDES =					\
 	$(WARN_CFLAGS)				\
-	$(VOLUME_CONTROL_CFLAGS)		\
-	$(PULSE_CFLAGS)				\
 	$(NULL)
 
 libgvc_la_LIBADD =		\
-	$(VOLUME_CONTROL_LIBS)	\
-	$(PULSE_LIBS)		\
 	$(NULL)
 
 libgvc_la_SOURCES =			\
+	$(NULL)
+
+if HAVE_PULSE
+INCLUDES +=					\
+	$(VOLUME_CONTROL_CFLAGS)		\
+	$(PULSE_CFLAGS)
+
+libgvc_la_LIBADD +=		\
+	$(VOLUME_CONTROL_LIBS)	\
+	$(PULSE_LIBS)
+
+libgvc_la_SOURCES +=			\
 	gvc-mixer-stream.h		\
 	gvc-mixer-stream.c		\
 	gvc-channel-map.h		\
@@ -31,8 +39,22 @@
 	gvc-mixer-event-role.h		\
 	gvc-mixer-event-role.c		\
 	gvc-mixer-control.h		\
-	gvc-mixer-control.c		\
-	$(NULL)
+	gvc-mixer-control.c
+endif
+
+if HAVE_GSTREAMER
+INCLUDES +=					\
+	$(SETTINGS_PLUGIN_CFLAGS)		\
+	$(AM_CFLAGS)				\
+	$(GST_CFLAGS)
+
+libgvc_la_LIBADD +=		\
+	$(GST_LIBS)
+
+libgvc_la_SOURCES +=			\
+	gvc-gstreamer-acme-vol.c	\
+	gvc-gstreamer-acme-vol.h
+endif
 
 MAINTAINERCLEANFILES =                  \
         *~                              \
diff -Nur gnome-settings-daemon-2.29.91.1.orig/plugins/media-keys/gsd-media-keys-manager.c gnome-settings-daemon-2.29.91.1/plugins/media-keys/gsd-media-keys-manager.c
--- gnome-settings-daemon-2.29.91.1.orig/plugins/media-keys/gsd-media-keys-manager.c	2010-02-17 00:40:19.000000000 +0200
+++ gnome-settings-daemon-2.29.91.1/plugins/media-keys/gsd-media-keys-manager.c	2010-02-25 17:45:01.000000000 +0200
@@ -53,6 +53,8 @@
 #ifdef HAVE_PULSE
 #include <canberra-gtk.h>
 #include "gvc-mixer-control.h"
+#elif defined(HAVE_GSTREAMER)
+#include "gvc-gstreamer-acme-vol.h"
 #endif /* HAVE_PULSE */
 
 #define GSD_DBUS_PATH "/org/gnome/SettingsDaemon"
@@ -84,6 +86,8 @@
         /* Volume bits */
         GvcMixerControl *volume;
         GvcMixerStream  *stream;
+#elif defined(HAVE_GSTREAMER)
+        AcmeVolume      *volume;
 #endif /* HAVE_PULSE */
         GtkWidget       *dialog;
         GConfClient     *conf_client;
@@ -647,7 +651,9 @@
                                 CA_PROP_APPLICATION_ID, "org.gnome.VolumeControl",
                                 NULL);
 }
+#endif /* HAVE_PULSE */
 
+#if defined(HAVE_PULSE) || defined(HAVE_GSTREAMER)
 static void
 do_sound_action (GsdMediaKeysManager *manager,
                  int                  type)
@@ -656,7 +662,11 @@
         guint vol, norm_vol_step;
         int vol_step;
 
+#ifdef HAVE_PULSE
         if (manager->priv->stream == NULL)
+#else
+        if (manager->priv->volume == NULL)
+#endif
                 return;
 
         vol_step = gconf_client_get_int (manager->priv->conf_client,
@@ -666,18 +676,34 @@
         if (vol_step <= 0 || vol_step > 100)
                 vol_step = VOLUME_STEP;
 
+#ifdef HAVE_PULSE
         norm_vol_step = PA_VOLUME_NORM * vol_step / 100;
 
         /* FIXME: this is racy */
         vol = gvc_mixer_stream_get_volume (manager->priv->stream);
         muted = gvc_mixer_stream_get_is_muted (manager->priv->stream);
 
+#else
+        if (vol_step > 0) {
+                gint threshold = acme_volume_get_threshold (manager->priv->volume);
+                if (vol_step < threshold)
+                        vol_step = threshold;
+                g_debug ("Using volume step of %d", vol_step);
+        }
+        vol = acme_volume_get_volume (manager->priv->volume);
+        muted = acme_volume_get_mute (manager->priv->volume);
+#endif
         switch (type) {
         case MUTE_KEY:
+#ifdef HAVE_PULSE
                 muted = !muted;
                 gvc_mixer_stream_change_is_muted (manager->priv->stream, muted);
+#else
+                acme_volume_mute_toggle (manager->priv->volume);
+#endif
                 break;
         case VOLUME_DOWN_KEY:
+#ifdef HAVE_PULSE
                 if (!muted && (vol <= norm_vol_step)) {
                         muted = !muted;
                         vol = 0;
@@ -689,11 +715,17 @@
                         if (gvc_mixer_stream_set_volume (manager->priv->stream, vol) != FALSE)
                                 gvc_mixer_stream_push_volume (manager->priv->stream);
                 }
+#else
+                if (!muted && (vol <= vol_step))
+                        acme_volume_mute_toggle (manager->priv->volume);
+                acme_volume_set_volume (manager->priv->volume, vol - vol_step);
+#endif
                 break;
         case VOLUME_UP_KEY:
                 if (muted) {
                         muted = !muted;
                         if (vol == 0) {
+#ifdef HAVE_PULSE
                                vol = vol + norm_vol_step;
                                gvc_mixer_stream_change_is_muted (manager->priv->stream, muted);
                                if (gvc_mixer_stream_set_volume (manager->priv->stream, vol) != FALSE)
@@ -701,7 +733,15 @@
                         } else {
                                 gvc_mixer_stream_change_is_muted (manager->priv->stream, muted);
                         }
+#else
+                                /* We need to unmute otherwise vol is blocked (and muted) */
+                                acme_volume_set_mute   (manager->priv->volume, FALSE);
+                        }
+                        acme_volume_set_volume (manager->priv->volume, vol + vol_step);
+                        
+#endif
                 } else {
+#ifdef HAVE_PULSE
                         if (vol < MAX_VOLUME) {
                                 if (vol + norm_vol_step >= MAX_VOLUME) {
                                         vol = MAX_VOLUME;
@@ -711,13 +751,35 @@
                                 if (gvc_mixer_stream_set_volume (manager->priv->stream, vol) != FALSE)
                                         gvc_mixer_stream_push_volume (manager->priv->stream);
                         }
+#else
+                        acme_volume_set_volume (manager->priv->volume, vol + vol_step);
+#endif
                 }
                 break;
         }
 
+#ifdef HAVE_PULSE
         update_dialog (manager, vol, muted);
+#else
+        muted = acme_volume_get_mute (manager->priv->volume);
+        vol = acme_volume_get_volume (manager->priv->volume);
+
+        /* FIXME: AcmeVolume should probably emit signals
+           instead of doing it like this */
+        dialog_init (manager);
+        gsd_media_keys_window_set_volume_muted (GSD_MEDIA_KEYS_WINDOW (manager->priv->dialog),
+                                                muted);
+        gsd_media_keys_window_set_volume_level (GSD_MEDIA_KEYS_WINDOW (manager->priv->dialog),
+                                                vol);
+        gsd_media_keys_window_set_action (GSD_MEDIA_KEYS_WINDOW (manager->priv->dialog),
+                                          GSD_MEDIA_KEYS_WINDOW_ACTION_VOLUME);
+        dialog_show (manager);
+#endif /* HAVE_PULSE */
 }
 
+#endif /* defined(HAVE_PULSE) || defined(HAVE_GSTREAMER) */
+
+#ifdef HAVE_PULSE
 static void
 update_default_sink (GsdMediaKeysManager *manager)
 {
@@ -879,9 +941,9 @@
         case MUTE_KEY:
         case VOLUME_DOWN_KEY:
         case VOLUME_UP_KEY:
-#ifdef HAVE_PULSE
+#if defined(HAVE_PULSE) || defined(HAVE_GSTREAMER)
                 do_sound_action (manager, type);
-#endif /* HAVE_PULSE */
+#endif /* HAVE_PULSE || HAVE_GSTREAMER */
                 break;
         case POWER_KEY:
                 do_exit_action (manager);
@@ -1081,6 +1143,10 @@
         gvc_mixer_control_open (manager->priv->volume);
 
         gnome_settings_profile_end ("gvc_mixer_control_new");
+#elif defined(HAVE_GSTREAMER)
+        gnome_settings_profile_start ("acme_volume_new");
+        manager->priv->volume = acme_volume_new ();
+        gnome_settings_profile_end ("acme_volume_new");
 #endif /* HAVE_PULSE */
         g_idle_add ((GSourceFunc) start_media_keys_idle_cb, manager);
 
@@ -1153,6 +1219,7 @@
                 g_object_unref (priv->stream);
                 priv->stream = NULL;
         }
+#elif defined(HAVE_GSTREAMER)
 
         if (priv->volume) {
                 g_object_unref (priv->volume);
diff -Nur gnome-settings-daemon-2.29.91.1.orig/plugins/media-keys/gsd-media-keys-manager.c.orig gnome-settings-daemon-2.29.91.1/plugins/media-keys/gsd-media-keys-manager.c.orig
--- gnome-settings-daemon-2.29.91.1.orig/plugins/media-keys/gsd-media-keys-manager.c.orig	1970-01-01 02:00:00.000000000 +0200
+++ gnome-settings-daemon-2.29.91.1/plugins/media-keys/gsd-media-keys-manager.c.orig	2010-02-17 00:40:19.000000000 +0200
@@ -0,0 +1,1327 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2001-2003 Bastien Nocera <hadess@hadess.net>
+ * Copyright (C) 2006-2007 William Jon McCann <mccann@jhu.edu>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include "config.h"
+
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <string.h>
+#include <errno.h>
+
+#include <locale.h>
+
+#include <glib.h>
+#include <glib/gi18n.h>
+#include <gdk/gdk.h>
+#include <gdk/gdkx.h>
+#include <gtk/gtk.h>
+#include <gconf/gconf-client.h>
+
+#include <dbus/dbus-glib.h>
+#include <dbus/dbus-glib-lowlevel.h>
+
+#include "gnome-settings-profile.h"
+#include "gsd-marshal.h"
+#include "gsd-media-keys-manager.h"
+#include "gsd-media-keys-manager-glue.h"
+
+#include "eggaccelerators.h"
+#include "acme.h"
+#include "gsd-media-keys-window.h"
+
+#ifdef HAVE_PULSE
+#include <canberra-gtk.h>
+#include "gvc-mixer-control.h"
+#endif /* HAVE_PULSE */
+
+#define GSD_DBUS_PATH "/org/gnome/SettingsDaemon"
+#define GSD_DBUS_NAME "org.gnome.SettingsDaemon"
+#define GSD_MEDIA_KEYS_DBUS_PATH GSD_DBUS_PATH "/MediaKeys"
+#define GSD_MEDIA_KEYS_DBUS_NAME GSD_DBUS_NAME ".MediaKeys"
+
+#define TOUCHPAD_ENABLED_KEY "/desktop/gnome/peripherals/touchpad/touchpad_enabled"
+
+#define VOLUME_STEP 6           /* percents for one volume button press */
+#define MAX_VOLUME 65536.0
+
+#if defined(__OpenBSD__)
+# define EJECT_COMMAND "eject -t /dev/rcd0c"
+#else
+# define EJECT_COMMAND "eject -T"
+#endif
+
+#define GSD_MEDIA_KEYS_MANAGER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GSD_TYPE_MEDIA_KEYS_MANAGER, GsdMediaKeysManagerPrivate))
+
+typedef struct {
+        char   *application;
+        guint32 time;
+} MediaPlayer;
+
+struct GsdMediaKeysManagerPrivate
+{
+#ifdef HAVE_PULSE
+        /* Volume bits */
+        GvcMixerControl *volume;
+        GvcMixerStream  *stream;
+#endif /* HAVE_PULSE */
+        GtkWidget       *dialog;
+        GConfClient     *conf_client;
+
+        /* Multihead stuff */
+        GdkScreen       *current_screen;
+        GSList          *screens;
+
+        GList           *media_players;
+
+        DBusGConnection *connection;
+        guint            notify[HANDLED_KEYS];
+};
+
+enum {
+        MEDIA_PLAYER_KEY_PRESSED,
+        LAST_SIGNAL
+};
+
+static guint signals[LAST_SIGNAL] = { 0 };
+
+static void     gsd_media_keys_manager_class_init  (GsdMediaKeysManagerClass *klass);
+static void     gsd_media_keys_manager_init        (GsdMediaKeysManager      *media_keys_manager);
+static void     gsd_media_keys_manager_finalize    (GObject                  *object);
+
+G_DEFINE_TYPE (GsdMediaKeysManager, gsd_media_keys_manager, G_TYPE_OBJECT)
+
+static gpointer manager_object = NULL;
+
+
+static void
+init_screens (GsdMediaKeysManager *manager)
+{
+        GdkDisplay *display;
+        int i;
+
+        display = gdk_display_get_default ();
+        for (i = 0; i < gdk_display_get_n_screens (display); i++) {
+                GdkScreen *screen;
+
+                screen = gdk_display_get_screen (display, i);
+                if (screen == NULL) {
+                        continue;
+                }
+                manager->priv->screens = g_slist_append (manager->priv->screens, screen);
+        }
+
+        manager->priv->current_screen = manager->priv->screens->data;
+}
+
+
+static void
+acme_error (char * msg)
+{
+        GtkWidget *error_dialog;
+
+        error_dialog = gtk_message_dialog_new (NULL,
+                                               GTK_DIALOG_MODAL,
+                                               GTK_MESSAGE_ERROR,
+                                               GTK_BUTTONS_OK,
+                                               msg, NULL);
+        gtk_dialog_set_default_response (GTK_DIALOG (error_dialog),
+                                         GTK_RESPONSE_OK);
+        gtk_widget_show (error_dialog);
+        g_signal_connect (error_dialog,
+                          "response",
+                          G_CALLBACK (gtk_widget_destroy),
+                          NULL);
+}
+
+static char *
+get_term_command (GsdMediaKeysManager *manager)
+{
+        char *cmd_term;
+        char *cmd = NULL;
+
+        cmd_term = gconf_client_get_string (manager->priv->conf_client,
+                                            "/desktop/gnome/applications/terminal/exec", NULL);
+        if ((cmd_term != NULL) && (strcmp (cmd_term, "") != 0)) {
+                char *cmd_args;
+                cmd_args = gconf_client_get_string (manager->priv->conf_client,
+                                                    "/desktop/gnome/applications/terminal/exec_arg", NULL);
+                if ((cmd_args != NULL) && (strcmp (cmd_term, "") != 0)) {
+                        cmd = g_strdup_printf ("%s %s -e", cmd_term, cmd_args);
+                } else {
+                        cmd = g_strdup_printf ("%s -e", cmd_term);
+                }
+
+                g_free (cmd_args);
+        }
+
+        g_free (cmd_term);
+
+        return cmd;
+}
+
+static void
+execute (GsdMediaKeysManager *manager,
+         char                *cmd,
+         gboolean             sync,
+         gboolean             need_term)
+{
+        gboolean retval;
+        char   **argv;
+        int      argc;
+        char    *exec;
+        char    *term = NULL;
+
+        retval = FALSE;
+
+        if (need_term) {
+                term = get_term_command (manager);
+                if (term == NULL) {
+                        acme_error (_("Could not get default terminal. Verify that your default "
+                                      "terminal command is set and points to a valid application."));
+                        return;
+                }
+        }
+
+        if (term) {
+                exec = g_strdup_printf ("%s %s", term, cmd);
+                g_free (term);
+        } else {
+                exec = g_strdup (cmd);
+        }
+
+        if (g_shell_parse_argv (exec, &argc, &argv, NULL)) {
+                if (sync != FALSE) {
+                        retval = g_spawn_sync (g_get_home_dir (),
+                                               argv,
+                                               NULL,
+                                               G_SPAWN_SEARCH_PATH,
+                                               NULL,
+                                               NULL,
+                                               NULL,
+                                               NULL,
+                                               NULL,
+                                               NULL);
+                } else {
+                        retval = g_spawn_async (g_get_home_dir (),
+                                                argv,
+                                                NULL,
+                                                G_SPAWN_SEARCH_PATH,
+                                                NULL,
+                                                NULL,
+                                                NULL,
+                                                NULL);
+                }
+                g_strfreev (argv);
+        }
+
+        if (retval == FALSE) {
+                char *msg;
+                msg = g_strdup_printf (_("Couldn't execute command: %s\n"
+                                         "Verify that this is a valid command."),
+                                       exec);
+
+                acme_error (msg);
+                g_free (msg);
+        }
+        g_free (exec);
+}
+
+static void
+do_sleep_action (char *cmd1,
+                 char *cmd2)
+{
+        if (g_spawn_command_line_async (cmd1, NULL) == FALSE) {
+                if (g_spawn_command_line_async (cmd2, NULL) == FALSE) {
+                        acme_error (_("Couldn't put the machine to sleep.\n"
+                                        "Verify that the machine is correctly configured."));
+                }
+        }
+}
+
+static void
+dialog_init (GsdMediaKeysManager *manager)
+{
+        if (manager->priv->dialog != NULL
+            && !gsd_osd_window_is_valid (GSD_OSD_WINDOW (manager->priv->dialog))) {
+                gtk_widget_destroy (manager->priv->dialog);
+                manager->priv->dialog = NULL;
+        }
+
+        if (manager->priv->dialog == NULL) {
+                manager->priv->dialog = gsd_media_keys_window_new ();
+        }
+}
+
+static gboolean
+is_valid_shortcut (const char *string)
+{
+        if (string == NULL || string[0] == '\0') {
+                return FALSE;
+        }
+        if (strcmp (string, "disabled") == 0) {
+                return FALSE;
+        }
+
+        return TRUE;
+}
+
+static void
+update_kbd_cb (GConfClient         *client,
+               guint                id,
+               GConfEntry          *entry,
+               GsdMediaKeysManager *manager)
+{
+        int      i;
+        gboolean need_flush = TRUE;
+
+        g_return_if_fail (entry->key != NULL);
+
+        gdk_error_trap_push ();
+
+        /* Find the key that was modified */
+        for (i = 0; i < HANDLED_KEYS; i++) {
+                if (strcmp (entry->key, keys[i].gconf_key) == 0) {
+                        char *tmp;
+                        Key  *key;
+
+                        if (keys[i].key != NULL) {
+                                need_flush = TRUE;
+                                grab_key_unsafe (keys[i].key, FALSE, manager->priv->screens);
+                        }
+
+                        g_free (keys[i].key);
+                        keys[i].key = NULL;
+
+                        tmp = gconf_client_get_string (manager->priv->conf_client,
+                                                       keys[i].gconf_key, NULL);
+
+                        if (is_valid_shortcut (tmp) == FALSE) {
+                                g_free (tmp);
+                                break;
+                        }
+
+                        key = g_new0 (Key, 1);
+                        if (!egg_accelerator_parse_virtual (tmp, &key->keysym, &key->keycodes, &key->state)) {
+                                g_free (tmp);
+                                g_free (key);
+                                break;
+                        }
+
+                        need_flush = TRUE;
+                        grab_key_unsafe (key, TRUE, manager->priv->screens);
+                        keys[i].key = key;
+
+                        g_free (tmp);
+
+                        break;
+                }
+        }
+
+        if (need_flush)
+                gdk_flush ();
+        if (gdk_error_trap_pop ())
+                g_warning ("Grab failed for some keys, another application may already have access the them.");
+}
+
+static void
+init_kbd (GsdMediaKeysManager *manager)
+{
+        int i;
+        gboolean need_flush = FALSE;
+
+        gnome_settings_profile_start (NULL);
+
+        gdk_error_trap_push ();
+
+        for (i = 0; i < HANDLED_KEYS; i++) {
+                char *tmp;
+                Key  *key;
+
+                manager->priv->notify[i] =
+                        gconf_client_notify_add (manager->priv->conf_client,
+                                                 keys[i].gconf_key,
+                                                 (GConfClientNotifyFunc) update_kbd_cb,
+                                                 manager,
+                                                 NULL,
+                                                 NULL);
+
+                tmp = gconf_client_get_string (manager->priv->conf_client,
+                                               keys[i].gconf_key,
+                                               NULL);
+
+                if (!is_valid_shortcut (tmp)) {
+                        g_debug ("Not a valid shortcut: '%s'", tmp);
+                        g_free (tmp);
+                        continue;
+                }
+
+                key = g_new0 (Key, 1);
+                if (!egg_accelerator_parse_virtual (tmp, &key->keysym, &key->keycodes, &key->state)) {
+                        g_debug ("Unable to parse: '%s'", tmp);
+                        g_free (tmp);
+                        g_free (key);
+                        continue;
+                }
+
+                g_free (tmp);
+
+                keys[i].key = key;
+
+                need_flush = TRUE;
+                grab_key_unsafe (key, TRUE, manager->priv->screens);
+        }
+
+        if (need_flush)
+                gdk_flush ();
+        if (gdk_error_trap_pop ())
+                g_warning ("Grab failed for some keys, another application may already have access the them.");
+
+        gnome_settings_profile_end (NULL);
+}
+
+static void
+dialog_show (GsdMediaKeysManager *manager)
+{
+        int            orig_w;
+        int            orig_h;
+        int            screen_w;
+        int            screen_h;
+        int            x;
+        int            y;
+        int            pointer_x;
+        int            pointer_y;
+        GtkRequisition win_req;
+        GdkScreen     *pointer_screen;
+        GdkRectangle   geometry;
+        int            monitor;
+
+        gtk_window_set_screen (GTK_WINDOW (manager->priv->dialog),
+                               manager->priv->current_screen);
+
+        /*
+         * get the window size
+         * if the window hasn't been mapped, it doesn't necessarily
+         * know its true size, yet, so we need to jump through hoops
+         */
+        gtk_window_get_default_size (GTK_WINDOW (manager->priv->dialog), &orig_w, &orig_h);
+        gtk_widget_size_request (manager->priv->dialog, &win_req);
+
+        if (win_req.width > orig_w) {
+                orig_w = win_req.width;
+        }
+        if (win_req.height > orig_h) {
+                orig_h = win_req.height;
+        }
+
+        pointer_screen = NULL;
+        gdk_display_get_pointer (gdk_screen_get_display (manager->priv->current_screen),
+                                 &pointer_screen,
+                                 &pointer_x,
+                                 &pointer_y,
+                                 NULL);
+        if (pointer_screen != manager->priv->current_screen) {
+                /* The pointer isn't on the current screen, so just
+                 * assume the default monitor
+                 */
+                monitor = 0;
+        } else {
+                monitor = gdk_screen_get_monitor_at_point (manager->priv->current_screen,
+                                                           pointer_x,
+                                                           pointer_y);
+        }
+
+        gdk_screen_get_monitor_geometry (manager->priv->current_screen,
+                                         monitor,
+                                         &geometry);
+
+        screen_w = geometry.width;
+        screen_h = geometry.height;
+
+        x = ((screen_w - orig_w) / 2) + geometry.x;
+        y = geometry.y + (screen_h / 2) + (screen_h / 2 - orig_h) / 2;
+
+        gtk_window_move (GTK_WINDOW (manager->priv->dialog), x, y);
+
+        gtk_widget_show (manager->priv->dialog);
+
+        gdk_display_sync (gdk_screen_get_display (manager->priv->current_screen));
+}
+
+static void
+do_unknown_action (GsdMediaKeysManager *manager,
+                   const char          *url)
+{
+        char *string;
+
+        g_return_if_fail (url != NULL);
+
+        string = gconf_client_get_string (manager->priv->conf_client,
+                                          "/desktop/gnome/url-handlers/unknown/command",
+                                          NULL);
+
+        if ((string != NULL) && (strcmp (string, "") != 0)) {
+                char *cmd;
+                cmd = g_strdup_printf (string, url);
+                execute (manager, cmd, FALSE, FALSE);
+                g_free (cmd);
+        }
+        g_free (string);
+}
+
+static void
+do_help_action (GsdMediaKeysManager *manager)
+{
+        char *string;
+
+        string = gconf_client_get_string (manager->priv->conf_client,
+                                          "/desktop/gnome/url-handlers/ghelp/command",
+                                          NULL);
+
+        if ((string != NULL) && (strcmp (string, "") != 0)) {
+                char *cmd;
+                cmd = g_strdup_printf (string, "");
+                execute (manager, cmd, FALSE, FALSE);
+                g_free (cmd);
+        } else {
+                do_unknown_action (manager, "ghelp:");
+        }
+
+        g_free (string);
+}
+
+static void
+do_mail_action (GsdMediaKeysManager *manager)
+{
+        char *string;
+
+        string = gconf_client_get_string (manager->priv->conf_client,
+                                          "/desktop/gnome/url-handlers/mailto/command",
+                                          NULL);
+
+        if ((string != NULL) && (strcmp (string, "") != 0)) {
+                char *cmd;
+                cmd = g_strdup_printf (string, "");
+                execute (manager,
+                         cmd,
+                         FALSE,
+                         gconf_client_get_bool (manager->priv->conf_client,
+                                                "/desktop/gnome/url-handlers/mailto/needs_terminal", NULL));
+                g_free (cmd);
+        }
+        g_free (string);
+}
+
+static void
+do_media_action (GsdMediaKeysManager *manager)
+{
+        char *command;
+
+        command = gconf_client_get_string (manager->priv->conf_client,
+                                           "/desktop/gnome/applications/media/exec", NULL);
+        if ((command != NULL) && (strcmp (command, "") != 0)) {
+                execute (manager,
+                         command,
+                         FALSE,
+                         gconf_client_get_bool (manager->priv->conf_client,
+                                                "/desktop/gnome/applications/media/needs_term", NULL));
+        }
+        g_free (command);
+}
+
+static void
+do_www_action (GsdMediaKeysManager *manager,
+               const char          *url)
+{
+        char *string;
+
+        string = gconf_client_get_string (manager->priv->conf_client,
+                                          "/desktop/gnome/url-handlers/http/command",
+                                          NULL);
+
+        if ((string != NULL) && (strcmp (string, "") != 0)) {
+                gchar *cmd;
+
+                if (url == NULL) {
+                        cmd = g_strdup_printf (string, "");
+                } else {
+                        cmd = g_strdup_printf (string, url);
+                }
+
+                execute (manager,
+                         cmd,
+                         FALSE,
+                         gconf_client_get_bool (manager->priv->conf_client,
+                                                "/desktop/gnome/url-handlers/http/needs_terminal", NULL));
+                g_free (cmd);
+        } else {
+                do_unknown_action (manager, url ? url : "");
+        }
+        g_free (string);
+}
+
+static void
+do_exit_action (GsdMediaKeysManager *manager)
+{
+        execute (manager, "gnome-session-save --shutdown-dialog", FALSE, FALSE);
+}
+
+static void
+do_eject_action (GsdMediaKeysManager *manager)
+{
+        char *command;
+
+        dialog_init (manager);
+        gsd_media_keys_window_set_action_custom (GSD_MEDIA_KEYS_WINDOW (manager->priv->dialog),
+                                                 "media-eject",
+                                                 FALSE);
+        dialog_show (manager);
+
+        command = gconf_client_get_string (manager->priv->conf_client,
+                                           GCONF_MISC_DIR "/eject_command",
+                                           NULL);
+        if ((command != NULL) && (strcmp (command, "") != 0)) {
+                execute (manager, command, FALSE, FALSE);
+        } else {
+                execute (manager, EJECT_COMMAND, FALSE, FALSE);
+        }
+
+        g_free (command);
+}
+
+static void
+do_touchpad_action (GsdMediaKeysManager *manager)
+{
+        GConfClient *client = manager->priv->conf_client;
+        gboolean state = gconf_client_get_bool (client, TOUCHPAD_ENABLED_KEY, NULL);
+
+        dialog_init (manager);
+        gsd_media_keys_window_set_action_custom (GSD_MEDIA_KEYS_WINDOW (manager->priv->dialog),
+                                                 (!state) ? "touchpad-enabled" : "touchpad-disabled",
+                                                 FALSE);
+        dialog_show (manager);
+
+        gconf_client_set_bool (client, TOUCHPAD_ENABLED_KEY, !state, NULL);
+}
+
+#ifdef HAVE_PULSE
+static void
+update_dialog (GsdMediaKeysManager *manager,
+               guint vol,
+               gboolean muted)
+{
+        vol = (int) (100 * (double) vol / PA_VOLUME_NORM);
+        vol = CLAMP (vol, 0, 100);
+
+        dialog_init (manager);
+        gsd_media_keys_window_set_volume_muted (GSD_MEDIA_KEYS_WINDOW (manager->priv->dialog),
+                                                muted);
+        gsd_media_keys_window_set_volume_level (GSD_MEDIA_KEYS_WINDOW (manager->priv->dialog), vol);
+        gsd_media_keys_window_set_action (GSD_MEDIA_KEYS_WINDOW (manager->priv->dialog),
+                                          GSD_MEDIA_KEYS_WINDOW_ACTION_VOLUME);
+        dialog_show (manager);
+
+        ca_gtk_play_for_widget (manager->priv->dialog, 0,
+                                CA_PROP_EVENT_ID, "audio-volume-change",
+                                CA_PROP_EVENT_DESCRIPTION, "volume changed through key press",
+                                CA_PROP_APPLICATION_ID, "org.gnome.VolumeControl",
+                                NULL);
+}
+
+static void
+do_sound_action (GsdMediaKeysManager *manager,
+                 int                  type)
+{
+        gboolean muted;
+        guint vol, norm_vol_step;
+        int vol_step;
+
+        if (manager->priv->stream == NULL)
+                return;
+
+        vol_step = gconf_client_get_int (manager->priv->conf_client,
+                                         GCONF_MISC_DIR "/volume_step",
+                                         NULL);
+
+        if (vol_step <= 0 || vol_step > 100)
+                vol_step = VOLUME_STEP;
+
+        norm_vol_step = PA_VOLUME_NORM * vol_step / 100;
+
+        /* FIXME: this is racy */
+        vol = gvc_mixer_stream_get_volume (manager->priv->stream);
+        muted = gvc_mixer_stream_get_is_muted (manager->priv->stream);
+
+        switch (type) {
+        case MUTE_KEY:
+                muted = !muted;
+                gvc_mixer_stream_change_is_muted (manager->priv->stream, muted);
+                break;
+        case VOLUME_DOWN_KEY:
+                if (!muted && (vol <= norm_vol_step)) {
+                        muted = !muted;
+                        vol = 0;
+                        gvc_mixer_stream_change_is_muted (manager->priv->stream, muted);
+                        if (gvc_mixer_stream_set_volume (manager->priv->stream, vol) != FALSE)
+                                gvc_mixer_stream_push_volume (manager->priv->stream);
+                } else if (!muted) {
+                        vol = vol - norm_vol_step;
+                        if (gvc_mixer_stream_set_volume (manager->priv->stream, vol) != FALSE)
+                                gvc_mixer_stream_push_volume (manager->priv->stream);
+                }
+                break;
+        case VOLUME_UP_KEY:
+                if (muted) {
+                        muted = !muted;
+                        if (vol == 0) {
+                               vol = vol + norm_vol_step;
+                               gvc_mixer_stream_change_is_muted (manager->priv->stream, muted);
+                               if (gvc_mixer_stream_set_volume (manager->priv->stream, vol) != FALSE)
+                                        gvc_mixer_stream_push_volume (manager->priv->stream);
+                        } else {
+                                gvc_mixer_stream_change_is_muted (manager->priv->stream, muted);
+                        }
+                } else {
+                        if (vol < MAX_VOLUME) {
+                                if (vol + norm_vol_step >= MAX_VOLUME) {
+                                        vol = MAX_VOLUME;
+                                } else {
+                                        vol = vol + norm_vol_step;
+                                }
+                                if (gvc_mixer_stream_set_volume (manager->priv->stream, vol) != FALSE)
+                                        gvc_mixer_stream_push_volume (manager->priv->stream);
+                        }
+                }
+                break;
+        }
+
+        update_dialog (manager, vol, muted);
+}
+
+static void
+update_default_sink (GsdMediaKeysManager *manager)
+{
+        GvcMixerStream *stream;
+
+        stream = gvc_mixer_control_get_default_sink (manager->priv->volume);
+        if (stream == manager->priv->stream)
+                return;
+
+        if (manager->priv->stream != NULL) {
+                g_object_unref (manager->priv->stream);
+                manager->priv->stream = NULL;
+        }
+
+        if (stream != NULL) {
+                manager->priv->stream = g_object_ref (stream);
+        } else {
+                g_warning ("Unable to get default sink");
+        }
+}
+
+static void
+on_control_ready (GvcMixerControl     *control,
+                  GsdMediaKeysManager *manager)
+{
+        update_default_sink (manager);
+}
+
+static void
+on_control_default_sink_changed (GvcMixerControl     *control,
+                                 guint                id,
+                                 GsdMediaKeysManager *manager)
+{
+        update_default_sink (manager);
+}
+
+#endif /* HAVE_PULSE */
+
+static gint
+find_by_application (gconstpointer a,
+                     gconstpointer b)
+{
+        return strcmp (((MediaPlayer *)a)->application, b);
+}
+
+static gint
+find_by_time (gconstpointer a,
+              gconstpointer b)
+{
+        return ((MediaPlayer *)a)->time < ((MediaPlayer *)b)->time;
+}
+
+/*
+ * Register a new media player. Most applications will want to call
+ * this with time = GDK_CURRENT_TIME. This way, the last registered
+ * player will receive media events. In some cases, applications
+ * may want to register with a lower priority (usually 1), to grab
+ * events only nobody is interested.
+ */
+gboolean
+gsd_media_keys_manager_grab_media_player_keys (GsdMediaKeysManager *manager,
+                                               const char          *application,
+                                               guint32              time,
+                                               GError             **error)
+{
+        GList       *iter;
+        MediaPlayer *media_player;
+
+        if (time == GDK_CURRENT_TIME) {
+                GTimeVal tv;
+
+                g_get_current_time (&tv);
+                time = tv.tv_sec * 1000 + tv.tv_usec / 1000;
+        }
+
+        iter = g_list_find_custom (manager->priv->media_players,
+                                   application,
+                                   find_by_application);
+
+        if (iter != NULL) {
+                if (((MediaPlayer *)iter->data)->time < time) {
+                        g_free (((MediaPlayer *)iter->data)->application);
+                        g_free (iter->data);
+                        manager->priv->media_players = g_list_delete_link (manager->priv->media_players, iter);
+                } else {
+                        return TRUE;
+                }
+        }
+
+        g_debug ("Registering %s at %u", application, time);
+        media_player = g_new0 (MediaPlayer, 1);
+        media_player->application = g_strdup (application);
+        media_player->time = time;
+
+        manager->priv->media_players = g_list_insert_sorted (manager->priv->media_players,
+                                                             media_player,
+                                                             find_by_time);
+
+        return TRUE;
+}
+
+gboolean
+gsd_media_keys_manager_release_media_player_keys (GsdMediaKeysManager *manager,
+                                                  const char          *application,
+                                                  GError             **error)
+{
+        GList *iter;
+
+        iter = g_list_find_custom (manager->priv->media_players,
+                                   application,
+                                   find_by_application);
+
+        if (iter != NULL) {
+                g_debug ("Deregistering %s", application);
+                g_free (((MediaPlayer *)iter->data)->application);
+                g_free (iter->data);
+                manager->priv->media_players = g_list_delete_link (manager->priv->media_players, iter);
+        }
+
+        return TRUE;
+}
+
+static gboolean
+gsd_media_player_key_pressed (GsdMediaKeysManager *manager,
+                              const char          *key)
+{
+        const char *application = NULL;
+        gboolean    have_listeners;
+
+        have_listeners = (manager->priv->media_players != NULL);
+
+        if (have_listeners) {
+                application = ((MediaPlayer *)manager->priv->media_players->data)->application;
+        }
+
+        g_signal_emit (manager, signals[MEDIA_PLAYER_KEY_PRESSED], 0, application, key);
+
+        return !have_listeners;
+}
+
+static gboolean
+do_multimedia_player_action (GsdMediaKeysManager *manager,
+                             const char          *key)
+{
+        return gsd_media_player_key_pressed (manager, key);
+}
+
+static gboolean
+do_action (GsdMediaKeysManager *manager,
+           int                  type)
+{
+        char *cmd;
+        char *path;
+
+        switch (type) {
+        case TOUCHPAD_KEY:
+                do_touchpad_action (manager);
+                break;
+        case MUTE_KEY:
+        case VOLUME_DOWN_KEY:
+        case VOLUME_UP_KEY:
+#ifdef HAVE_PULSE
+                do_sound_action (manager, type);
+#endif /* HAVE_PULSE */
+                break;
+        case POWER_KEY:
+                do_exit_action (manager);
+                break;
+        case EJECT_KEY:
+                do_eject_action (manager);
+                break;
+        case HOME_KEY:
+                path = g_shell_quote (g_get_home_dir ());
+                cmd = g_strconcat ("nautilus --no-desktop ", path, NULL);
+                g_free (path);
+                execute (manager, cmd, FALSE, FALSE);
+                g_free (cmd);
+                break;
+        case SEARCH_KEY:
+                cmd = NULL;
+                if ((cmd = g_find_program_in_path ("beagle-search"))) {
+                        execute (manager, "beagle-search", FALSE, FALSE);
+                } else if ((cmd = g_find_program_in_path ("tracker-search-tool"))) {
+                        execute (manager, "tracker-search-tool", FALSE, FALSE);
+                } else {
+                        execute (manager, "gnome-search-tool", FALSE, FALSE);
+                }
+                g_free (cmd);
+                break;
+        case EMAIL_KEY:
+                do_mail_action (manager);
+                break;
+        case SCREENSAVER_KEY:
+                if ((cmd = g_find_program_in_path ("gnome-screensaver-command"))) {
+                        execute (manager, "gnome-screensaver-command --lock", FALSE, FALSE);
+                } else {
+                        execute (manager, "xscreensaver-command -lock", FALSE, FALSE);
+                }
+
+                g_free (cmd);
+                break;
+        case HELP_KEY:
+                do_help_action (manager);
+                break;
+        case WWW_KEY:
+                do_www_action (manager, NULL);
+                break;
+        case MEDIA_KEY:
+                do_media_action (manager);
+                break;
+        case CALCULATOR_KEY:
+                execute (manager, "gcalctool", FALSE, FALSE);
+                break;
+        case PLAY_KEY:
+                return do_multimedia_player_action (manager, "Play");
+                break;
+        case PAUSE_KEY:
+                return do_multimedia_player_action (manager, "Pause");
+                break;
+        case STOP_KEY:
+                return do_multimedia_player_action (manager, "Stop");
+                break;
+        case PREVIOUS_KEY:
+                return do_multimedia_player_action (manager, "Previous");
+                break;
+        case NEXT_KEY:
+                return do_multimedia_player_action (manager, "Next");
+                break;
+        default:
+                g_assert_not_reached ();
+        }
+
+        return FALSE;
+}
+
+static GdkScreen *
+acme_get_screen_from_event (GsdMediaKeysManager *manager,
+                            XAnyEvent           *xanyev)
+{
+        GdkWindow *window;
+        GdkScreen *screen;
+        GSList    *l;
+
+        /* Look for which screen we're receiving events */
+        for (l = manager->priv->screens; l != NULL; l = l->next) {
+                screen = (GdkScreen *) l->data;
+                window = gdk_screen_get_root_window (screen);
+
+                if (GDK_WINDOW_XID (window) == xanyev->window) {
+                        return screen;
+                }
+        }
+
+        return NULL;
+}
+
+static GdkFilterReturn
+acme_filter_events (GdkXEvent           *xevent,
+                    GdkEvent            *event,
+                    GsdMediaKeysManager *manager)
+{
+        XEvent    *xev = (XEvent *) xevent;
+        XAnyEvent *xany = (XAnyEvent *) xevent;
+        int        i;
+
+        /* verify we have a key event */
+        if (xev->type != KeyPress && xev->type != KeyRelease) {
+                return GDK_FILTER_CONTINUE;
+        }
+
+        for (i = 0; i < HANDLED_KEYS; i++) {
+                if (match_key (keys[i].key, xev)) {
+                        switch (keys[i].key_type) {
+                        case VOLUME_DOWN_KEY:
+                        case VOLUME_UP_KEY:
+                                /* auto-repeatable keys */
+                                if (xev->type != KeyPress) {
+                                        return GDK_FILTER_CONTINUE;
+                                }
+                                break;
+                        default:
+                                if (xev->type != KeyRelease) {
+                                        return GDK_FILTER_CONTINUE;
+                                }
+                        }
+
+                        manager->priv->current_screen = acme_get_screen_from_event (manager, xany);
+
+                        if (do_action (manager, keys[i].key_type) == FALSE) {
+                                return GDK_FILTER_REMOVE;
+                        } else {
+                                return GDK_FILTER_CONTINUE;
+                        }
+                }
+        }
+
+        return GDK_FILTER_CONTINUE;
+}
+
+static gboolean
+start_media_keys_idle_cb (GsdMediaKeysManager *manager)
+{
+        GSList *l;
+
+        g_debug ("Starting media_keys manager");
+        gnome_settings_profile_start (NULL);
+        manager->priv->conf_client = gconf_client_get_default ();
+
+        gconf_client_add_dir (manager->priv->conf_client,
+                              GCONF_BINDING_DIR,
+                              GCONF_CLIENT_PRELOAD_ONELEVEL,
+                              NULL);
+
+        init_screens (manager);
+        init_kbd (manager);
+
+        /* Start filtering the events */
+        for (l = manager->priv->screens; l != NULL; l = l->next) {
+                gnome_settings_profile_start ("gdk_window_add_filter");
+
+                g_debug ("adding key filter for screen: %d",
+                         gdk_screen_get_number (l->data));
+
+                gdk_window_add_filter (gdk_screen_get_root_window (l->data),
+                                       (GdkFilterFunc)acme_filter_events,
+                                       manager);
+                gnome_settings_profile_end ("gdk_window_add_filter");
+        }
+
+        gnome_settings_profile_end (NULL);
+
+        return FALSE;
+}
+
+gboolean
+gsd_media_keys_manager_start (GsdMediaKeysManager *manager,
+                              GError             **error)
+{
+        gnome_settings_profile_start (NULL);
+
+#ifdef HAVE_PULSE
+        /* initialise Volume handler
+         *
+         * We do this one here to force checking gstreamer cache, etc.
+         * The rest (grabbing and setting the keys) can happen in an
+         * idle.
+         */
+        gnome_settings_profile_start ("gvc_mixer_control_new");
+
+        manager->priv->volume = gvc_mixer_control_new ("GNOME Volume Control Media Keys");
+
+        g_signal_connect (manager->priv->volume,
+                          "ready",
+                          G_CALLBACK (on_control_ready),
+                          manager);
+        g_signal_connect (manager->priv->volume,
+                          "default-sink-changed",
+                          G_CALLBACK (on_control_default_sink_changed),
+                          manager);
+
+        gvc_mixer_control_open (manager->priv->volume);
+
+        gnome_settings_profile_end ("gvc_mixer_control_new");
+#endif /* HAVE_PULSE */
+        g_idle_add ((GSourceFunc) start_media_keys_idle_cb, manager);
+
+        gnome_settings_profile_end (NULL);
+
+        return TRUE;
+}
+
+void
+gsd_media_keys_manager_stop (GsdMediaKeysManager *manager)
+{
+        GsdMediaKeysManagerPrivate *priv = manager->priv;
+        GSList *ls;
+        GList *l;
+        int i;
+        gboolean need_flush;
+
+        g_debug ("Stopping media_keys manager");
+
+        for (ls = priv->screens; ls != NULL; ls = ls->next) {
+                gdk_window_remove_filter (gdk_screen_get_root_window (ls->data),
+                                          (GdkFilterFunc) acme_filter_events,
+                                          manager);
+        }
+
+        if (priv->conf_client) {
+                gconf_client_remove_dir (priv->conf_client,
+                                         GCONF_BINDING_DIR,
+                                         NULL);
+
+                for (i = 0; i < HANDLED_KEYS; ++i) {
+                        if (priv->notify[i] != 0) {
+                                gconf_client_notify_remove (priv->conf_client, priv->notify[i]);
+                                priv->notify[i] = 0;
+                        }
+                }
+
+                g_object_unref (priv->conf_client);
+                priv->conf_client = NULL;
+        }
+
+        if (priv->connection != NULL) {
+                dbus_g_connection_unref (priv->connection);
+                priv->connection = NULL;
+        }
+
+        need_flush = FALSE;
+        gdk_error_trap_push ();
+
+        for (i = 0; i < HANDLED_KEYS; ++i) {
+                if (keys[i].key) {
+                        need_flush = TRUE;
+                        grab_key_unsafe (keys[i].key, FALSE, priv->screens);
+
+                        g_free (keys[i].key->keycodes);
+                        g_free (keys[i].key);
+                        keys[i].key = NULL;
+                }
+        }
+
+        if (need_flush)
+                gdk_flush ();
+        gdk_error_trap_pop ();
+
+        g_slist_free (priv->screens);
+        priv->screens = NULL;
+
+#ifdef HAVE_PULSE
+        if (priv->stream) {
+                g_object_unref (priv->stream);
+                priv->stream = NULL;
+        }
+
+        if (priv->volume) {
+                g_object_unref (priv->volume);
+                priv->volume = NULL;
+        }
+#endif /* HAVE_PULSE */
+
+        if (priv->dialog != NULL) {
+                gtk_widget_destroy (priv->dialog);
+                priv->dialog = NULL;
+        }
+
+        for (l = priv->media_players; l; l = l->next) {
+                MediaPlayer *mp = l->data;
+                g_free (mp->application);
+                g_free (mp);
+        }
+        g_list_free (priv->media_players);
+        priv->media_players = NULL;
+}
+
+static void
+gsd_media_keys_manager_set_property (GObject        *object,
+                               guint           prop_id,
+                               const GValue   *value,
+                               GParamSpec     *pspec)
+{
+        GsdMediaKeysManager *self;
+
+        self = GSD_MEDIA_KEYS_MANAGER (object);
+
+        switch (prop_id) {
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+                break;
+        }
+}
+
+static void
+gsd_media_keys_manager_get_property (GObject        *object,
+                               guint           prop_id,
+                               GValue         *value,
+                               GParamSpec     *pspec)
+{
+        GsdMediaKeysManager *self;
+
+        self = GSD_MEDIA_KEYS_MANAGER (object);
+
+        switch (prop_id) {
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+                break;
+        }
+}
+
+static GObject *
+gsd_media_keys_manager_constructor (GType                  type,
+                              guint                  n_construct_properties,
+                              GObjectConstructParam *construct_properties)
+{
+        GsdMediaKeysManager      *media_keys_manager;
+        GsdMediaKeysManagerClass *klass;
+
+        klass = GSD_MEDIA_KEYS_MANAGER_CLASS (g_type_class_peek (GSD_TYPE_MEDIA_KEYS_MANAGER));
+
+        media_keys_manager = GSD_MEDIA_KEYS_MANAGER (G_OBJECT_CLASS (gsd_media_keys_manager_parent_class)->constructor (type,
+                                                                                                      n_construct_properties,
+                                                                                                      construct_properties));
+
+        return G_OBJECT (media_keys_manager);
+}
+
+static void
+gsd_media_keys_manager_dispose (GObject *object)
+{
+        GsdMediaKeysManager *media_keys_manager;
+
+        media_keys_manager = GSD_MEDIA_KEYS_MANAGER (object);
+
+        G_OBJECT_CLASS (gsd_media_keys_manager_parent_class)->dispose (object);
+}
+
+static void
+gsd_media_keys_manager_class_init (GsdMediaKeysManagerClass *klass)
+{
+        GObjectClass   *object_class = G_OBJECT_CLASS (klass);
+
+        object_class->get_property = gsd_media_keys_manager_get_property;
+        object_class->set_property = gsd_media_keys_manager_set_property;
+        object_class->constructor = gsd_media_keys_manager_constructor;
+        object_class->dispose = gsd_media_keys_manager_dispose;
+        object_class->finalize = gsd_media_keys_manager_finalize;
+
+       signals[MEDIA_PLAYER_KEY_PRESSED] =
+               g_signal_new ("media-player-key-pressed",
+                             G_OBJECT_CLASS_TYPE (klass),
+                             G_SIGNAL_RUN_LAST,
+                             G_STRUCT_OFFSET (GsdMediaKeysManagerClass, media_player_key_pressed),
+                             NULL,
+                             NULL,
+                             gsd_marshal_VOID__STRING_STRING,
+                             G_TYPE_NONE,
+                             2,
+                             G_TYPE_STRING,
+                             G_TYPE_STRING);
+
+        dbus_g_object_type_install_info (GSD_TYPE_MEDIA_KEYS_MANAGER, &dbus_glib_gsd_media_keys_manager_object_info);
+
+        g_type_class_add_private (klass, sizeof (GsdMediaKeysManagerPrivate));
+}
+
+static void
+gsd_media_keys_manager_init (GsdMediaKeysManager *manager)
+{
+        manager->priv = GSD_MEDIA_KEYS_MANAGER_GET_PRIVATE (manager);
+
+}
+
+static void
+gsd_media_keys_manager_finalize (GObject *object)
+{
+        GsdMediaKeysManager *media_keys_manager;
+
+        g_return_if_fail (object != NULL);
+        g_return_if_fail (GSD_IS_MEDIA_KEYS_MANAGER (object));
+
+        media_keys_manager = GSD_MEDIA_KEYS_MANAGER (object);
+
+        g_return_if_fail (media_keys_manager->priv != NULL);
+
+        G_OBJECT_CLASS (gsd_media_keys_manager_parent_class)->finalize (object);
+}
+
+static gboolean
+register_manager (GsdMediaKeysManager *manager)
+{
+        GError *error = NULL;
+
+        manager->priv->connection = dbus_g_bus_get (DBUS_BUS_SESSION, &error);
+        if (manager->priv->connection == NULL) {
+                if (error != NULL) {
+                        g_error ("Error getting session bus: %s", error->message);
+                        g_error_free (error);
+                }
+                return FALSE;
+        }
+
+        dbus_g_connection_register_g_object (manager->priv->connection, GSD_MEDIA_KEYS_DBUS_PATH, G_OBJECT (manager));
+
+        return TRUE;
+}
+
+GsdMediaKeysManager *
+gsd_media_keys_manager_new (void)
+{
+        if (manager_object != NULL) {
+                g_object_ref (manager_object);
+        } else {
+                gboolean res;
+
+                manager_object = g_object_new (GSD_TYPE_MEDIA_KEYS_MANAGER, NULL);
+                g_object_add_weak_pointer (manager_object,
+                                           (gpointer *) &manager_object);
+                res = register_manager (manager_object);
+                if (! res) {
+                        g_object_unref (manager_object);
+                        return NULL;
+                }
+        }
+
+        return GSD_MEDIA_KEYS_MANAGER (manager_object);
+}
diff -Nur gnome-settings-daemon-2.29.91.1.orig/plugins/media-keys/Makefile.am gnome-settings-daemon-2.29.91.1/plugins/media-keys/Makefile.am
--- gnome-settings-daemon-2.29.91.1.orig/plugins/media-keys/Makefile.am	2010-02-17 00:40:19.000000000 +0200
+++ gnome-settings-daemon-2.29.91.1/plugins/media-keys/Makefile.am	2010-02-25 17:40:02.000000000 +0200
@@ -3,13 +3,8 @@
 
 NULL =
 
-SUBDIRS =
-plugin_LTLIBRARIES =
-
-if HAVE_PULSE
-SUBDIRS += cut-n-paste
-plugin_LTLIBRARIES += libmedia-keys.la
-endif
+SUBDIRS = cut-n-paste
+plugin_LTLIBRARIES = libmedia-keys.la
 
 BUILT_SOURCES = 			\
 	gsd-media-keys-manager-glue.h	\
@@ -100,16 +95,14 @@
 
 libmedia_keys_la_LIBADD  = 		\
 	$(top_builddir)/plugins/common/libcommon.la			\
-	$(top_builddir)/plugins/media-keys/cut-n-paste/libgvc.la	\
+	$(top_builddir)/plugins/media-keys/cut-n-paste/libgvc.la        \
 	$(SETTINGS_PLUGIN_LIBS)						\
 	$(XF86MISC_LIBS)
 
 plugin_in_files = 		\
 	media-keys.gnome-settings-plugin.in
 
-if HAVE_PULSE
 plugin_DATA = $(plugin_in_files:.gnome-settings-plugin.in=.gnome-settings-plugin)
-endif
 
 noinst_PROGRAMS =				\
 	test-media-keys				\
@@ -173,9 +166,7 @@
 	$(XF86MISC_LIBS)			\
 	$(GST_LIBS)
 
-if HAVE_PULSE
 test_media_keys_LDADD += $(top_builddir)/plugins/media-keys/cut-n-paste/libgvc.la
-endif
 
 gtkbuilderdir = $(pkgdatadir)
 gtkbuilder_DATA =	\
diff -Nur gnome-settings-daemon-2.29.91.1.orig/plugins/media-keys/Makefile.am.orig gnome-settings-daemon-2.29.91.1/plugins/media-keys/Makefile.am.orig
--- gnome-settings-daemon-2.29.91.1.orig/plugins/media-keys/Makefile.am.orig	1970-01-01 02:00:00.000000000 +0200
+++ gnome-settings-daemon-2.29.91.1/plugins/media-keys/Makefile.am.orig	2010-02-17 00:40:19.000000000 +0200
@@ -0,0 +1,202 @@
+icondir = $(datadir)/icons/hicolor
+context = actions
+
+NULL =
+
+SUBDIRS =
+plugin_LTLIBRARIES =
+
+if HAVE_PULSE
+SUBDIRS += cut-n-paste
+plugin_LTLIBRARIES += libmedia-keys.la
+endif
+
+BUILT_SOURCES = 			\
+	gsd-media-keys-manager-glue.h	\
+	gsd-marshal.h			\
+	gsd-marshal.c			\
+	$(NULL)
+
+ICON_FILES = 			\
+	touchpad-disabled-16.png	\
+	touchpad-enabled-16.png		\
+	touchpad-disabled-22.png	\
+	touchpad-enabled-22.png		\
+	touchpad-disabled-24.png	\
+	touchpad-enabled-24.png		\
+	touchpad-disabled-32.png	\
+	touchpad-enabled-32.png		\
+	touchpad-disabled-48.png	\
+	touchpad-enabled-48.png		\
+	touchpad-disabled.svg		\
+	touchpad-enabled.svg
+
+install-data-local:
+	$(mkinstalldirs) $(DESTDIR)$(icondir)/16x16/$(context)
+	$(mkinstalldirs) $(DESTDIR)$(icondir)/22x22/$(context)
+	$(mkinstalldirs) $(DESTDIR)$(icondir)/24x24/$(context)
+	$(mkinstalldirs) $(DESTDIR)$(icondir)/32x32/$(context)
+	$(mkinstalldirs) $(DESTDIR)$(icondir)/scalable/$(context)
+	$(INSTALL_DATA) $(srcdir)/touchpad-enabled-16.png $(DESTDIR)$(icondir)/16x16/$(context)/touchpad-enabled.png
+	$(INSTALL_DATA) $(srcdir)/touchpad-enabled-22.png $(DESTDIR)$(icondir)/22x22/$(context)/touchpad-enabled.png
+	$(INSTALL_DATA) $(srcdir)/touchpad-enabled-24.png $(DESTDIR)$(icondir)/24x24/$(context)/touchpad-enabled.png
+	$(INSTALL_DATA) $(srcdir)/touchpad-enabled-32.png $(DESTDIR)$(icondir)/32x32/$(context)/touchpad-enabled.png
+	$(INSTALL_DATA) $(srcdir)/touchpad-enabled.svg $(DESTDIR)$(icondir)/scalable/$(context)/touchpad-enabled.svg
+	$(INSTALL_DATA) $(srcdir)/touchpad-disabled-16.png $(DESTDIR)$(icondir)/16x16/$(context)/touchpad-disabled.png
+	$(INSTALL_DATA) $(srcdir)/touchpad-disabled-22.png $(DESTDIR)$(icondir)/22x22/$(context)/touchpad-disabled.png
+	$(INSTALL_DATA) $(srcdir)/touchpad-disabled-24.png $(DESTDIR)$(icondir)/24x24/$(context)/touchpad-disabled.png
+	$(INSTALL_DATA) $(srcdir)/touchpad-disabled-32.png $(DESTDIR)$(icondir)/32x32/$(context)/touchpad-disabled.png
+	$(INSTALL_DATA) $(srcdir)/touchpad-disabled.svg $(DESTDIR)$(icondir)/scalable/$(context)/touchpad-disabled.svg
+
+uninstall-local:
+	rm -f $(DESTDIR)$(icondir)/16x16/$(context)/touchpad-enabled.png
+	rm -f $(DESTDIR)$(icondir)/22x22/$(context)/touchpad-enabled.png
+	rm -f $(DESTDIR)$(icondir)/24x24/$(context)/touchpad-enabled.png
+	rm -f $(DESTDIR)$(icondir)/32x32/$(context)/touchpad-enabled.png
+	rm -f $(DESTDIR)$(icondir)/scalable/$(context)/touchpad-enabled.svg
+	rm -f $(DESTDIR)$(icondir)/16x16/$(context)/touchpad-disabled.png
+	rm -f $(DESTDIR)$(icondir)/22x22/$(context)/touchpad-disabled.png
+	rm -f $(DESTDIR)$(icondir)/24x24/$(context)/touchpad-disabled.png
+	rm -f $(DESTDIR)$(icondir)/32x32/$(context)/touchpad-disabled.png
+	rm -f $(DESTDIR)$(icondir)/scalable/$(context)/touchpad-disabled.svg
+
+gsd-media-keys-manager-glue.h: gsd-media-keys-manager.xml Makefile
+	dbus-binding-tool --prefix=gsd_media_keys_manager --mode=glib-server $< > xgen-$(@F) \
+	&& ( cmp -s xgen-$(@F) $@ || cp xgen-$(@F) $@ ) \
+	&& rm -f xgen-$(@F)
+
+gsd-marshal.c: gsd-marshal.list
+	$(GLIB_GENMARSHAL) --prefix=gsd_marshal $< --header --body --internal > $@
+
+gsd-marshal.h: gsd-marshal.list
+	$(GLIB_GENMARSHAL) --prefix=gsd_marshal $< --header --internal > $@
+
+libmedia_keys_la_SOURCES = 		\
+	gsd-media-keys-plugin.h		\
+	gsd-media-keys-plugin.c		\
+	gsd-media-keys-manager.h	\
+	gsd-media-keys-manager.c	\
+	gsd-media-keys-window.h		\
+	gsd-media-keys-window.c		\
+	acme.h				\
+	$(BUILT_SOURCES)		\
+	$(NULL)
+
+libmedia_keys_la_CPPFLAGS = \
+	-I$(top_srcdir)/gnome-settings-daemon			\
+	-I$(top_srcdir)/plugins/common				\
+	-I$(top_srcdir)/plugins/media-keys/cut-n-paste		\
+	-DPIXMAPDIR=\""$(pkgdatadir)"\"				\
+	-DGTKBUILDERDIR=\""$(pkgdatadir)"\"			\
+	-DGNOME_SETTINGS_LOCALEDIR=\""$(datadir)/locale"\"	\
+	$(AM_CPPFLAGS)
+
+libmedia_keys_la_CFLAGS = \
+	$(SETTINGS_PLUGIN_CFLAGS)	\
+	$(AM_CFLAGS)
+
+libmedia_keys_la_LDFLAGS = 		\
+	$(GSD_PLUGIN_LDFLAGS)
+
+libmedia_keys_la_LIBADD  = 		\
+	$(top_builddir)/plugins/common/libcommon.la			\
+	$(top_builddir)/plugins/media-keys/cut-n-paste/libgvc.la	\
+	$(SETTINGS_PLUGIN_LIBS)						\
+	$(XF86MISC_LIBS)
+
+plugin_in_files = 		\
+	media-keys.gnome-settings-plugin.in
+
+if HAVE_PULSE
+plugin_DATA = $(plugin_in_files:.gnome-settings-plugin.in=.gnome-settings-plugin)
+endif
+
+noinst_PROGRAMS =				\
+	test-media-keys				\
+	test-media-window			\
+	$(NULL)
+
+test_media_window_SOURCES =			\
+	gsd-media-keys-window.c			\
+	gsd-media-keys-window.h			\
+	test-media-window.c			\
+	$(NULL)
+
+test_media_window_CPPFLAGS = \
+	-I$(top_srcdir)/gnome-settings-daemon			\
+	-I$(top_srcdir)/plugins/common				\
+	-I$(top_srcdir)/plugins/media-keys/cut-n-paste		\
+	-DDATADIR=\""$(datadir)"\"				\
+	-DPIXMAPDIR=\""$(pkgdatadir)"\"				\
+	-DGTKBUILDERDIR=\""$(pkgdatadir)"\"			\
+	-DGNOME_SETTINGS_LOCALEDIR=\""$(datadir)/locale"\"	\
+	$(AM_CPPFLAGS)
+
+test_media_window_CFLAGS = \
+	$(SETTINGS_PLUGIN_CFLAGS)	\
+	$(AM_CFLAGS)
+
+test_media_window_LDADD = \
+	$(top_builddir)/plugins/common/libcommon.la			\
+	$(SETTINGS_DAEMON_LIBS)			\
+	$(SETTINGS_PLUGIN_LIBS)			\
+	$(XF86MISC_LIBS)			\
+	$(GST_LIBS)
+
+test_media_keys_SOURCES =			\
+	gsd-media-keys-manager.c		\
+	gsd-media-keys-manager.h		\
+	gsd-media-keys-window.h			\
+	gsd-media-keys-window.c			\
+	test-media-keys.c			\
+	$(BUILT_SOURCES)			\
+	$(NULL)
+
+test_media_keys_CPPFLAGS = \
+	-I$(top_srcdir)/gnome-settings-daemon			\
+	-I$(top_srcdir)/plugins/common				\
+	-I$(top_srcdir)/plugins/media-keys/cut-n-paste		\
+	-DPIXMAPDIR=\""$(pkgdatadir)"\"				\
+	-DGTKBUILDERDIR=\""$(pkgdatadir)"\"			\
+	-DGNOME_SETTINGS_LOCALEDIR=\""$(datadir)/locale"\"	\
+	$(AM_CPPFLAGS)
+
+test_media_keys_CFLAGS = \
+	$(SETTINGS_PLUGIN_CFLAGS)	\
+	$(AM_CFLAGS)
+
+test_media_keys_LDADD = \
+	$(top_builddir)/gnome-settings-daemon/libgsd-profile.la		\
+	$(top_builddir)/plugins/common/libcommon.la			\
+	$(SETTINGS_DAEMON_LIBS)			\
+	$(SETTINGS_PLUGIN_LIBS)			\
+	$(XF86MISC_LIBS)			\
+	$(GST_LIBS)
+
+if HAVE_PULSE
+test_media_keys_LDADD += $(top_builddir)/plugins/media-keys/cut-n-paste/libgvc.la
+endif
+
+gtkbuilderdir = $(pkgdatadir)
+gtkbuilder_DATA =	\
+	acme.ui		\
+	$(NULL)
+
+DIST_SUBDIRS = cut-n-paste
+
+EXTRA_DIST = 				\
+	gsd-media-keys-manager.xml	\
+	gsd-marshal.list		\
+	$(plugin_in_files)		\
+	$(gtkbuilder_DATA)		\
+	$(pixmaps_DATA)			\
+	$(ICON_FILES)
+
+CLEANFILES = 			\
+	$(BUILT_SOURCES)	\
+	$(plugin_DATA)
+
+DISTCLEANFILES =		\
+	$(plugin_DATA)
+
+@GSD_INTLTOOL_PLUGIN_RULE@
