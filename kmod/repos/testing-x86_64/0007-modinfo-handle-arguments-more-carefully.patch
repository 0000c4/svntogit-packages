From 2b77a48833818feb8cf35ffac3adcba8de503aec Mon Sep 17 00:00:00 2001
From: Dan McGee <dan@archlinux.org>
Date: Fri, 3 Feb 2012 20:20:21 -0600
Subject: [PATCH 7/8] modinfo: handle arguments more carefully

A simple case of breakage before this commit:

    $ touch aes
    $ modinfo aes
    filename:       /tmp/aes
    ERROR: could not get modinfo from 'aes': Invalid argument

Add a new is_module_filename() function that attempts to do more than
just check if the passed argument is a regular file. We look at the name
for a '.ko' string, and if that is found, ensure it is either at the end
of the string or followed by another '.' (for .gz and .xz modules, for
instance). We don't make this second option conditional on the way the
tools are built with compression support; the file is a module file
regardless and should always be treated that way.

When doing this, and noticed in the test suite output, we open the
system modules index unconditionally, even if it is never going to be
used during the modinfo call, which is the case when passing module
filenames directly. Delay the opening of the index file until we get an
argument that is not a module filename.

With-help-from: Dave Reisner <dreisner@archlinux.org>
Signed-off-by: Dan McGee <dan@archlinux.org>
---
 tools/kmod-modinfo.c |   20 +++++++++++++++++---
 1 files changed, 17 insertions(+), 3 deletions(-)

diff --git a/tools/kmod-modinfo.c b/tools/kmod-modinfo.c
index 87483a5..ace5d3f 100644
--- a/tools/kmod-modinfo.c
+++ b/tools/kmod-modinfo.c
@@ -19,6 +19,7 @@
 
 #include <stdio.h>
 #include <stdlib.h>
+#include <stdbool.h>
 #include <getopt.h>
 #include <errno.h>
 #include <string.h>
@@ -332,6 +333,21 @@ static void help(const char *progname)
 		progname);
 }
 
+static bool is_module_filename(const char *name)
+{
+	struct stat st;
+	const char *ptr;
+	if (stat(name, &st) == 0 && S_ISREG(st.st_mode) &&
+			(ptr = strstr(name, ".ko")) != NULL) {
+		/* we screened for .ko; make sure this is either at the end of the name
+		 * or followed by another '.' (e.g. gz or xz modules) */
+		if(ptr[3] != '\0' && ptr[3] != '.')
+			return false;
+		return true;
+	}
+	return false;
+}
+
 static int do_modinfo(int argc, char *argv[])
 {
 	struct kmod_ctx *ctx;
@@ -418,15 +434,13 @@ static int do_modinfo(int argc, char *argv[])
 		fputs("Error: kmod_new() failed!\n", stderr);
 		return EXIT_FAILURE;
 	}
-	kmod_load_resources(ctx);
 
 	err = 0;
 	for (i = optind; i < argc; i++) {
 		const char *name = argv[i];
-		struct stat st;
 		int r;
 
-		if (stat(name, &st) == 0 && S_ISREG(st.st_mode))
+		if (is_module_filename(name))
 			r = modinfo_path_do(ctx, name);
 		else
 			r = modinfo_alias_do(ctx, name);
-- 
1.7.9

